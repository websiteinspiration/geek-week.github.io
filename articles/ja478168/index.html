<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😒 🤬 🤲🏻 Goでの計画：パートI-OSプランナー 🔸 ✊🏿 〽️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！内部Goスケジューラのしくみについて、Bill Kennedyによる記事「Scheduling In Go：Part I-OS Scheduler」の翻訳を紹介します。
 
 これは、Goのスケジューラの根底にあるメカニズムとセマンティクスのアイデアを提供する3部構成のシリーズの...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Goでの計画：パートI-OSプランナー</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478168/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！</font><font style="vertical-align: inherit;">内部Goスケジューラのしくみについて、Bill Kennedyによる</font><font style="vertical-align: inherit;">記事</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「Scheduling In Go：Part I-OS Scheduler」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の翻訳を紹介</font><font style="vertical-align: inherit;">します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Goのスケジューラの根底にあるメカニズムとセマンティクスのアイデアを提供する3部構成のシリーズの最初の投稿です。</font><font style="vertical-align: inherit;">この投稿は、オペレーティングシステムプランナーに関するものです。</font><font style="vertical-align: inherit;">始めましょう！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goの内部スケジューラアーキテクチャにより、マルチスレッドプログラムをより効率的かつ生産的にすることができます。</font><font style="vertical-align: inherit;">マルチスレッドソフトウェアを適切に設計するには、OSスケジューラとGoスケジューラがどのように機能するかを共通に理解することが重要です。</font><font style="vertical-align: inherit;">実際にどのように機能するかを視覚化して、より良い意思決定を行うために十分な詳細を説明します。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OSスケジューラ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オペレーティングシステムスケジューラは高度なソフトウェアです。運用する機器の場所と構成を検討する必要があります。これには、複数のプロセッサとコア、CPUキャッシュ、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUMA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が含まれますが、これらに限定されません</font><font style="vertical-align: inherit;">。この知識がなければ、プランナーは可能な限り効果的ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたのプログラムは単に次々と順次実行されなければならない機械命令のセットです。これを実現するために、オペレーティングシステムはフローの概念を使用します。ストリームのタスクは、割り当てられた一連の命令を記録して順次実行することです。スレッドによる実行の指示がなくなるまで、実行は継続されます。そのため、私はその流れを「充実の道」と呼んでいます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行する各プログラムはプロセスを作成し、各プロセスは初期スレッドを作成します。スレッドには、さらにスレッドを作成する機能があります。これらの異なるスレッドはすべて互いに独立して機能し、スケジューリングの決定はプロセスレベルではなくスレッドレベルで行われます。ストリームは、同時に（それぞれが個別のコアで）動作することも、並行して（それぞれが異なるコアで同時に動作する）することもできます。ストリームは、独自の状態を維持して、命令が安全に、ローカルで、独立して実行されるようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OSスケジューラーは、実行可能なスレッドがある場合にカーネルがアイドル状態にならないようにする責任があります。</font><font style="vertical-align: inherit;">これにより、実行可能なすべてのスレッドが同時に実行されているような錯覚も生じるはずです。</font><font style="vertical-align: inherit;">このイリュージョンを作成するプロセスでは、スケジューラは、優先度の低いスレッドよりも優先度の高いスレッドを開始する必要があります。</font><font style="vertical-align: inherit;">ただし、優先度の低いスレッドからランタイムを奪うことはできません。</font><font style="vertical-align: inherit;">計画担当者は、迅速かつスマートな決定を行うことにより、計画の遅延を最小限に抑える必要もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべてをよりよく理解するには、いくつかの重要な概念を説明および定義することが役立ちます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指示に従ってください</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令カウンタ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（これも（命令ポインタ）（IP）により、スレッドは実行する次のコマンドを追跡できます。ほとんどのプロセッサでは、IPは現在の命令ではなく、次の命令を指します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/9c0/190/f64/9c0190f6480a44bccd3665c73ba2fff6.jpg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goプログラムからのスタックトレースを見たことがある場合は、これらの小さな16進数が各行の終わりにあることに気付くでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト1の</font><font style="vertical-align: inherit;">+ 0x39および+ 0x72を参照してください。</font><font style="vertical-align: inherit;">リスト1</font></font><br>
<br>
<pre><code class="go hljs">goroutine <span class="hljs-number">1</span> [running]:<font></font>
   main.example(<span class="hljs-number">0xc000042748</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x4</span>, <span class="hljs-number">0x106abae</span>, <span class="hljs-number">0x5</span>, <span class="hljs-number">0xa</span>)<font></font>
       stack_trace/example1/example1.<span class="hljs-keyword">go</span>:<span class="hljs-number">13</span> +<span class="hljs-number">0x39</span>                 &lt;- <font></font>
   main.main()<font></font>
       stack_trace/example1/example1.<span class="hljs-keyword">go</span>:<span class="hljs-number">8</span> +<span class="hljs-number">0x72</span>                  &lt;-  
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの数値は、対応する関数の上からのIP値のオフセットを表します。 IPのオフセット値+ 0x39は、プログラムがパニックにならなかった場合に、サンプル関数内でスレッドが実行する次の命令を表します。制御がこの関数に戻る場合、IPオフセット値0 + x72はメイン関数内の次の命令です。さらに重要なことに、ポインタの前の命令は、実行された命令を示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下のリスト2のプログラムを見てください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト</font><font style="vertical-align: inherit;">1のスタックトレースが原因です。</font><font style="vertical-align: inherit;">リスト2</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-comment">// https://github.com/ardanlabs/gotraining/blob/master/topics/go/profiling/stack_trace/example1/example1.go</span>
<span class="hljs-number">07</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">08</span>     example(<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>), <span class="hljs-string">"hello"</span>, <span class="hljs-number">10</span>)
<span class="hljs-number">09</span> }<font></font>
<font></font>
<span class="hljs-number">12</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">example</span><span class="hljs-params">(slice []<span class="hljs-keyword">string</span>, str <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>)</span></span> {
<span class="hljs-number">13</span>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">"Want stack trace"</span>)
<span class="hljs-number">14</span> }
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16進数+ 0x39は、サンプル関数内の命令のIPオフセットを表します。これは、関数の最初の命令より57（10進）バイト下です。</font><font style="vertical-align: inherit;">以下のリスト3に、バイナリファイルの関数のobjdumpの例を示します。</font><font style="vertical-align: inherit;">以下にリストされている12番目の命令を見つけます。</font><font style="vertical-align: inherit;">この命令の上のコード行に注意してください-パニックコール。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト3</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">example</span><span class="hljs-params">(slice []<span class="hljs-keyword">string</span>, str <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>)</span></span> {
  <span class="hljs-number">0x104dfa</span>    <span class="hljs-number">065488</span>b0c2530000000  MOVQ GS:<span class="hljs-number">0x30</span>, CX
  <span class="hljs-number">0x104dfa9</span>   <span class="hljs-number">483</span>b6110             CMPQ <span class="hljs-number">0x10</span>(CX), SP
  <span class="hljs-number">0x104dfad</span>   <span class="hljs-number">762</span>c                 JBE <span class="hljs-number">0x104dfdb</span>
  <span class="hljs-number">0x104dfaf</span>   <span class="hljs-number">4883</span>ec18             SUBQ $<span class="hljs-number">0x18</span>, SP
  <span class="hljs-number">0x104dfb3</span>   <span class="hljs-number">48896</span>c2410           MOVQ BP, <span class="hljs-number">0x10</span>(SP)
  <span class="hljs-number">0x104dfb8</span>   <span class="hljs-number">488</span>d6c2410           LEAQ <span class="hljs-number">0x10</span>(SP), BP
	<span class="hljs-built_in">panic</span>(<span class="hljs-string">"Want stack trace"</span>)
  <span class="hljs-number">0x104dfbd</span>   <span class="hljs-number">488</span>d059ca20000	   LEAQ runtime.types+<span class="hljs-number">41504</span>(SB), AX
  <span class="hljs-number">0x104dfc4</span>   <span class="hljs-number">48890424</span>		   MOVQ AX, <span class="hljs-number">0</span>(SP)
  <span class="hljs-number">0x104dfc8</span>   <span class="hljs-number">488</span>d05a1870200	   LEAQ main.statictmp_0(SB), AX
  <span class="hljs-number">0x104dfcf</span>   <span class="hljs-number">4889442408</span>           MOVQ AX, <span class="hljs-number">0x8</span>(SP)
  <span class="hljs-number">0x104dfd4</span>   e8c735fdff           CALL runtime.gopanic(SB)
  <span class="hljs-number">0x104dfd9</span>   <span class="hljs-number">0</span>f0b                 UD2 &lt;---  IP(+<span class="hljs-number">0x39</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
覚えておいてください：IPは現在の命令ではなく、次の命令を示します。</font><font style="vertical-align: inherit;">リスト3は、このGoプログラムのスレッドが順次実行するamd64ベースの命令の良い例を示しています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリームの状態</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの重要な概念は、フローの状態です。スレッドは、待機中、準備完了、実行中の3つの状態のいずれかになります。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保留中</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：これは、スレッドが停止し、何かが継続するのを待っていることを意味します。これは、ハードウェア（ディスク、ネットワーク）、オペレーティングシステム（システムコール）、または同期呼び出し（アトミック、ミューテックス）の待機などの理由で発生する可能性があります。これらのタイプの遅延は、パフォーマンスの低下の主な原因です。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準備</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：これは、スレッドがカーネルで時間がかかるため、割り当てられたマシン命令を実行できることを意味します。</font><font style="vertical-align: inherit;">時間を必要とする多くのスレッドがある場合、スレッドは時間を取得するためにより長く待機する必要があります。</font><font style="vertical-align: inherit;">さらに、より多くのスレッドが時間をかけて競合するため、各スレッドが受け取る個々の時間は短縮されます。</font><font style="vertical-align: inherit;">このタイプのスケジューリング遅延も、パフォーマンスの低下を引き起こす可能性があります。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：これは、スレッドがカーネル上にあり、そのマシン命令を実行することを意味します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕事の種類</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッドは2つのタイプの作業を実行できます。</font><font style="vertical-align: inherit;">1つ目はCPUバインドと呼ばれ、2つ目はIOバインドです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CPUバウンド：これは、スレッドがスタンバイ状態になる可能性のある状況を決して作成しないジョブです。</font><font style="vertical-align: inherit;">これは常に計算を行う仕事です。</font><font style="vertical-align: inherit;">PiからN桁目を計算するスレッドは、CPUに関連付けられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IOバインド：これは、スレッドをアイドル状態に移行させるジョブです。</font><font style="vertical-align: inherit;">これは、ネットワークを介したリソースへのアクセスのリクエスト、またはオペレーティングシステムでのシステムコールの作成を伴うジョブです。</font><font style="vertical-align: inherit;">データベースへのアクセスが必要なスレッドはIOバインドされます。</font><font style="vertical-align: inherit;">このカテゴリの一部として、スレッドを待機させる同期イベント（ミューテックス、アトミック）を含めます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテキストスイッチ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linux、Mac、またはWindowsで作業する場合は、プリエンプティブスケジューラを使用してオペレーティングシステムで作業します。 </font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非プリエンプティブアルゴリズムは、アクティブなスレッドがそれ自身の主導でオペレーティングシステムを制御し、実行可能な別のスレッドをキューから選択するまで実行を許可されるという事実に基づいています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プリエンプティブアルゴリズムはスレッドスケジューリングの方法であり、プロセッサを1つのスレッドの実行から別のスレッドの実行に切り替える決定は、アクティブタスクではなくオペレーティングシステムによって行われます。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはいくつかの重要なことを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、これは、どのスレッドがいつでも実行するように選択されるかに関して、スケジューラーが予測できないことを意味します。フローの優先順位とイベント（ネットワークでのデータの受信など）により、スケジューラーが何をいつ選択するかを決定できなくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二に、これはあなたが経験できて幸運ないくつかの想定される振る舞いに基づいてコードを書くべきではないことを意味しますが、毎回起こることは保証されていません。考えるのは簡単です。私はそれが1000回どのように発生したかを見たので、これは保証された動作です。アプリケーションで確定性が必要な場合は、スレッドのタイミングとオーケストレーションを制御する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセッサによる1つのタスクの実行を終了して、中断された場所からの後続の継続に必要なすべての情報と状態を保存し、プロセッサが進んだタスクの状態を復元してロードするプロセスは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテキストスイッチング</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（PC）</font><font style="vertical-align: inherit;">と呼ばれ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。 PCは、スケジューラーがカーネルから実行のスレッドを取得して、作動可能状態のスレッドに置き換えるときに発生します。実行キューから選択されたスレッドは、「実行」状態になります。取得されたスレッドは、準備完了状態（まだ開始する機能がある場合）または待機状態（IO-Bound要求タイプのために置き換えられた場合）に戻ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PCは高価な操作と見なされます。 PCで発生する遅延の量はさまざまな要因に依存しますが、約1000ナノ秒から約1500ナノ秒かかることは妥当です。ハードウェアがコアあたり1ナノ秒あたり12命令を（平均して）インテリジェントに実行できる必要がある場合、コンテキストの切り替えには約12,000から最大18,000の遅延命令が必要になります。基本的に、プログラムは、コンテキストの切り替え中に多数の命令を実行する機能を失います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IOに関連する作業に焦点を当てたプログラムがある場合は、コンテキスト切り替えが有利です。</font><font style="vertical-align: inherit;">スレッドが待機状態になるとすぐに、作動可能状態の別のスレッドがその位置を占めます。</font><font style="vertical-align: inherit;">これにより、カーネルは常に作業を行うことができます。</font><font style="vertical-align: inherit;">これは計画の最も重要な側面の1つです。</font><font style="vertical-align: inherit;">作業がある場合（スレッドが準備完了状態の場合）は、カーネルをアイドル状態にしないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムがCPU指向の場合、コンテキストの切り替えはパフォーマンスの悪夢になります。</font><font style="vertical-align: inherit;">スレッドには常に作業があるため、コンテキスト切り替えはこの作業を停止します。</font><font style="vertical-align: inherit;">この状況は、IOバインド負荷で何が起こっているかとは対照的です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少ない-多い</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前は、プロセッサにコアが1つしかない場合、スケジューリングはそれほど複雑ではありませんでした。</font><font style="vertical-align: inherit;">コアが1つのプロセッサが1つあるため、同時に実行できるスレッドは1つだけです。</font><font style="vertical-align: inherit;">アイデアは、スケジューラの期間を決定し、この期間中に準備完了状態ですべてのスレッドを実行しようとすることでした。</font><font style="vertical-align: inherit;">問題ありません。計画期間を取り、完了する必要のあるスレッドの数で割ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、スケジューラの期間を10ミリ秒（ミリ秒）と定義し、2つのスレッドがある場合、各スレッドはそれぞれ5ミリ秒を受け取ります。</font><font style="vertical-align: inherit;">5つのスレッドがある場合、各スレッドは2 msを取得します。</font><font style="vertical-align: inherit;">しかし、100のスレッドがあるとどうなりますか？</font><font style="vertical-align: inherit;">PCでかなりの時間を費やすため、各スレッドに10μs（マイクロ秒）のタイムスパンを設定しても機能しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要なのは、タイムスライスをどれだけ短くできるかを制限することです。最後のシナリオでは、最小時間間隔が2ミリ秒で、スレッド数が100の場合、スケジューラーの期間を2000ミリ秒または2秒に増やす必要があります。スレッド数が1000の場合、スケジューラーの期間は20秒です。この単純な例では、各スレッドが独自の時間間隔を使用している場合、すべてのスレッドが20秒間1回開始されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはこれらの問題を非常に単純に見たものであることを覚えておいてください。</font><font style="vertical-align: inherit;">計画担当者は、さらに多くの問題を考慮する必要があります。</font><font style="vertical-align: inherit;">アプリケーションで使用するスレッドの数を制御します。</font><font style="vertical-align: inherit;">より多くのスレッドを検討する必要がある場合、IOに関連する作業が発生すると、さらに多くの混乱と非決定的な動作が発生します。</font><font style="vertical-align: inherit;">問題解決には、計画と実行に時間がかかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、「少ないほど良い」というルールが適用されます。</font><font style="vertical-align: inherit;">準備完了状態のスレッドが少ないほど、スケジューリングコストが少なくなり、各スレッドが受け取る時間が長くなります。</font><font style="vertical-align: inherit;">Ready状態のスレッドが多いほど、各スレッドが受け取る時間は短くなります。</font><font style="vertical-align: inherit;">これは、時間の経過とともに行われる作業が少なくなることを意味します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バランスを探しています</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用しているコアの数と、アプリケーションの最大スループットを達成するために必要なスレッドの数のバランスをとる必要があります。このバランスを管理することになると、スレッドプールは素晴らしい答えでした。第二部では囲碁はもう必要ないことをお見せします。これは、マルチスレッドアプリケーションの開発を容易にするためにGoが行った素晴らしいことの1つだと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goでコードを記述する前に、C ++およびC＃for NTでコードを記述しました。このオペレーティングシステムでは、IOCPコンプリーションポート（IOCP）を使用することが、マルチスレッドソフトウェアを作成する上で重要でした。エンジニアは、コアの数に対するスループットを最大化するために、必要なスレッドプールの数と特定のプールの最大スレッド数を把握する必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースと対話するWebサービスを作成する場合、コアあたり3スレッドという魔法の数が常にNTで最高のスループットを提供しました。つまり、コアあたり3つのスレッドにより、コンテキストの切り替えに費やされる時間が最小化され、コアでのランタイムが最大化されました。 IOCPスレッドプールを作成したとき、ホストコンピューターで識別されたコアごとに、最小1スレッド、最大3スレッドで開始する必要があることを知っていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コアあたり2つのスレッドを使用すると、すべての作業を実行するのに時間がかかります。これは、作業を実行できるときに単純なスレッドがあったためです。コアごとに4つのスレッドを使用した場合、PCでの遅延が多くなったため、さらに時間がかかりました。何らかの理由でコアあたり3スレッドのバランスは、常にNTのマジックナンバーのように見えました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サービスがさまざまなタイプのタスクを実行する場合はどうなりますか？</font><font style="vertical-align: inherit;">これにより、さまざまな矛盾する遅延が生じる可能性があります。</font><font style="vertical-align: inherit;">おそらく、処理する必要のあるさまざまなシステムイベントも作成します。</font><font style="vertical-align: inherit;">すべての異なるワークロードで常に機能するマジックナンバーを見つけることができない場合があります。</font><font style="vertical-align: inherit;">スレッドプールを使用してサービスのパフォーマンスを調整する場合、正しい一貫した構成を見つけるのは非常に困難です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセッサキャッシュ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインメモリからデータにアクセスすると、遅延コストが非常に高く（約100〜300クロックサイクル）、プロセッサとコアに、それらを必要とするハードウェアフローに近いデータを保存するためのローカルキャッシュがあります。キャッシュへのアクセスに応じて、キャッシュからのデータへのアクセスははるかに安価です（3から40サイクル）。今日、パフォーマンスの1つの側面は、データをプロセッサーに効率的に転送して、これらのデータアクセス遅延を削減できることです。状態が変化するマルチスレッドアプリケーションを作成する場合は、キャッシュシステムのメカニズムを考慮する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/651/c69/a66/651c69a66100d43d43768fb9caf5863e.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャッシュラインを使用して、プロセッサとメインメモリの間でデータが交換されます。キャッシュラインは、メインメモリとキャッシングシステムの間で交換される64バイトのメモリです。各コアは、必要なキャッシュラインの独自のコピーを取得します。つまり、ハードウェアは値のセマンティクスを使用します。これが、マルチスレッドアプリケーションのメモリの変更がパフォーマンスの悪夢を生む理由です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並行して実行されている複数のスレッドが同じデータ値または互いに隣接するデータ値にアクセスする場合、それらは同じキャッシュラインのデータにアクセスします。コアで実行されているスレッドは、同じキャッシュラインのコピーを受け取ります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/75c/d60/548/75cd605483853e4c7145e5779eb5c08f.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定のカーネルの1つのスレッドがキャッシュラインのコピーに変更を加える場合、ハードウェアの助けを借りて、同じキャッシュラインの他のすべてのコピーをダーティとしてマークする必要があります。スレッドがダーティキャッシュラインへの読み取りまたは書き込みアクセスを試行する場合、キャッシュラインの新しいコピーを取得するには、メインメモリへのアクセス（約100〜300クロックサイクル）が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たぶん2コアプロセッサではこれはそれほど重要ではありませんが、32スレッドが並列に動作する32コアプロセッサでは、すべてが1つのキャッシュラインでデータを受信および変更しますか？</font><font style="vertical-align: inherit;">それぞれ16コアの2つの物理プロセッサーを備えたシステムはどうですか？</font><font style="vertical-align: inherit;">これは、プロセッサ間の通信のための追加の遅延のために悪化します。</font><font style="vertical-align: inherit;">アプリケーションはメモリを反復処理し、パフォーマンスはひどくなり、その理由を理解できない可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュコヒーレンスの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題と呼ばれ、</font><font style="vertical-align: inherit;">誤った共有などの問題にもつながります。</font><font style="vertical-align: inherit;">一般的な状態を変更するマルチスレッドアプリケーションを作成する場合は、キャッシュシステムを考慮する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合計</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
投稿のこの最初の部分では、マルチスレッドアプリケーションを作成するときにスレッドとOSスケジューラに関して考慮すべき点について説明します。</font><font style="vertical-align: inherit;">これらのことはGoスケジューラによって考慮されます。</font><font style="vertical-align: inherit;">次の投稿では、Goスケジューラのセマンティクスと、それらがこの情報とどのように関連するかについて説明します。</font><font style="vertical-align: inherit;">そして、最後に、これらすべてが動作していることを確認し、いくつかのプログラムを実行します。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja478154/index.html">ブラックフライデーが大企業の株式の振る舞いにどのように影響するか（そして、そのような関係はまったくあるか）</a></li>
<li><a href="../ja478156/index.html">PostgRESTについて話し合う-Haskell上のオープンソースWebサーバー</a></li>
<li><a href="../ja478158/index.html">プログラムでElseの使用を停止する</a></li>
<li><a href="../ja478162/index.html">学習と娯楽のためのホログラム</a></li>
<li><a href="../ja478164/index.html">マイクロソフトの研究者が量子コンピューティングへの貢献により、権威ある理論物理学賞を受賞</a></li>
<li><a href="../ja478170/index.html">レールブレーキの真実：パート1</a></li>
<li><a href="../ja478176/index.html">投票率は失敗しました。AgentTeslaをきれいな水に持ち込みました。パート1</a></li>
<li><a href="../ja478178/index.html">Windows Terminal Preview 0.7がリリースされました</a></li>
<li><a href="../ja478182/index.html">Intel Myriad Xチップとニューラルネットワーク推論におけるスケーラビリティ</a></li>
<li><a href="../ja478184/index.html">マウスの代わりのKDE接続、または最初の接続の落とし穴</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>