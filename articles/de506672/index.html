<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úâÔ∏è üíÜüèæ üë¶ SwiftUI in den Regalen: Animation, Teil 2 üê∂ üóÑÔ∏è üçπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist der zweite Teil der Animationsgeschichte in SwiftUI. Im ersten Artikel haben wir uns einfache Beispiele f√ºr die Grundlagen der Funktionsweise...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SwiftUI in den Regalen: Animation, Teil 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506672/"><img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist der zweite Teil der Animationsgeschichte in SwiftUI. Im ersten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel haben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir uns einfache Beispiele f√ºr die Grundlagen der Funktionsweise von Animation in SwiftUI angesehen. In diesem Teil werden wir weiter gehen und das angek√ºndigte Beispiel mit Regenbogenanimation detailliert analysieren. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter dem Schnitt finden Sie eine Analyse des Timings der Animation, die Erstellung eines eigenen Timing-Kurvenmechanismus f√ºr die Arbeit in einer linearen Schleifenanimation, Beispiele f√ºr die Implementierung verschiedener Verl√§ufe und einige interessante Tricks, die Ihnen helfen, die Animation unter der Haube zu verstehen.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich m√∂chte Sie daran erinnern, dass ich die Idee ausspioniert habe, eine solche Animation </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu implementieren </font><font style="vertical-align: inherit;">. Dort gingen die Autoren den Weg des geringsten Widerstands und implementierten den naheliegendsten Weg, um dieses Konzept durch Animieren der Form umzusetzen. Das Prinzip ist einfach: Jede Welle ist eine Kontur, die durch eine Bezier-Kurve umrissen wird, und der Parameter ‚ÄûZeit‚Äú beeinflusst die Position der rechten Grenze dieser Welle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht die fertige Animation aus: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7a7/cbf/7a0/7a7cbf7a05561123ceff4be47fff5ed6.gif" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus Gr√ºnden der Klarheit werde ich die Wellen ein wenig vertikal verteilen. Dies ist einfach, ich habe gerade am Ende von NotchWave hinzugef√ºgt, dass die gesamte Kontur entsprechend der aktuellen Phase der Animation auf die H√∂he der Welle verschoben wird:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">return</span> p.applying(.<span class="hljs-keyword">init</span>(translationX: <span class="hljs-number">0</span>, y: height * <span class="hljs-keyword">self</span>.phase))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gut und auch .drowingGroup () muss man nicht vergessen, die Verbindung zu trennen - das bedeutet nicht, dass das Bild √ºber die Grenzen des festen Rahmens hinausgeht. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z3/zv/bi/z3zvbiseywno8t1fnt-i0ugcqgm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Ansatz ist einfach, er liefert das gew√ºnschte Ergebnis ... aber er kam mir zu langweilig vor. </font><font style="vertical-align: inherit;">Mein Weg war viel l√§nger und ich w√ºrde nicht sagen, dass das Endergebnis zumindest etwas besser w√§re, aber es w√§re auf dem Weg interessant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie die Prinzipien der Animationsarbeit in SwiftUI noch nicht genau kennen, empfehle ich dringend, den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorherigen Artikel zu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lesen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Und ich m√∂chte mich mit dem Quellcode auf dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github befassen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbeiten Sie mit Farbverl√§ufen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ganz am Anfang habe ich einen anderen Ansatz gew√§hlt. Ich fand es viel n√ºtzlicher, mich mit der Animation der Verschiebung von Objekten zu befassen als mit der Animation der Formulare (ich nenne immer noch die Formstrukturform). Der Versatz kann mit allem funktionieren - mit verschiedenen Formen, Bildern und anderen Ansichten. Als p√§dagogische Aufgabe wollte ich einen reibungslosen Farb√ºbergang von einer Welle zur anderen implementieren. Im urspr√ºnglichen Konzept war so etwas so. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Insgesamt bietet SwiftIUI drei Verwendungsm√∂glichkeiten des Gradienten - linear, kreisf√∂rmig und eckig. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t7/o6/7d/t7o67dwcm_v5svufist7tfp0kwe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Code sieht dies wie eine Art Blockkonstruktor aus. Beachten Sie, wie die gesamte Welle segmentiert ist.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wa/af/el/waafeltt9cgiasfzxg1gjexwc8i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein linearer Gradient ist durch einen Start- und Endpunkt f√ºr den Gradienten gekennzeichnet. </font><font style="vertical-align: inherit;">Dies sind keine CGPoint-Punkte mit absoluten Koordinaten (x: y :), sondern UnitPoint-Punkte, d.h. </font><font style="vertical-align: inherit;">relative Koordinaten, wobei x: y: in Bruchteilen der Breite und H√∂he des f√ºr diese Ansicht ausgew√§hlten Bereichs angegeben werden. </font><font style="vertical-align: inherit;">Es gibt auch vordefinierte Punkte, die den Ecken (.topLeading, .bottomTrailing usw.) und den Mittelpunkten der Seiten (.top, .trailing usw.) entsprechen.</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-type">Rectangle</span>()<font></font>
    .fill(<span class="hljs-type">LinearGradient</span>(<font></font>
         gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
          startPoint: .leading,<font></font>
          endPoint: .trailing))<font></font>
    .frame(width: <span class="hljs-keyword">self</span>.gradientLength)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das lineare Gradientensegment ist "Gummi". </font><font style="vertical-align: inherit;">Es hat eine feste Breite, aber seine H√∂he ist nicht angegeben. </font><font style="vertical-align: inherit;">Somit wird der gesamte bereitgestellte Betrag ausgef√ºllt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine etwas kompliziertere Geschichte mit einem kreisf√∂rmigen Farbverlauf. </font><font style="vertical-align: inherit;">Wir geben den Punkt an - den Mittelpunkt des Kreises, den Radius des Beginns des Verlaufs und den Radius des Endes des Verlaufs. </font><font style="vertical-align: inherit;">Die Radien sind bereits absolut, d.h. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Punkte</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Mittelpunkt des Kreises ist weiterhin als UnitPoint festgelegt.</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-type">Rectangle</span>()<font></font>
     .fill(<span class="hljs-type">RadialGradient</span>(<font></font>
          gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">0</span>),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">1</span>)]),<font></font>
          center: .bottomTrailing,<font></font>
          startRadius: <span class="hljs-keyword">self</span>.topRadius,<font></font>
          endRadius: <span class="hljs-keyword">self</span>.topRadius + <span class="hljs-keyword">self</span>.gradientLength)<font></font>
                )<font></font>
    .frame(height: <span class="hljs-keyword">self</span>.topRadius)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein St√ºck mit einem oberen Kreis hat eine feste H√∂he, erstreckt sich jedoch horizontal. Schlie√ülich setzen wir bestimmte feste Radien in Punkten, sodass kein zus√§tzliches Streckrechteck der Grundfarbe aufgeklebt werden muss, wie dies bei einem linearen Farbverlauf der Fall ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am schwierigsten anzuwenden ist ein Winkelgradient. Sie ergibt sich aus dem Start- und Endwinkel sowie der Richtung. Wie Sie der Codeliste entnehmen k√∂nnen, ist das Arbeiten mit Ecken nicht sehr praktisch. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie m√ºssen sich an den Schulkurs der Trigonometrie erinnern, um den erforderlichen Winkel zu berechnen, wenn Sie den Winkelgradienten an einem Punkt beginnen und an einem anderen beenden m√ºssen.</font></font><br>
<br>
<pre><code class="swift hljs">       
<span class="hljs-type">Rectangle</span>()<font></font>
      .fill(<span class="hljs-type">AngularGradient</span>(<font></font>
            gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.angularGradientMiddleStop(blockWidth: geometry.size.width)),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
            center: .bottomLeading,<font></font>
            startAngle: <span class="hljs-keyword">self</span>.directionTo(gradientPart: <span class="hljs-keyword">self</span>.start, blockWidth: geometry.size.width),<font></font>
            endAngle: <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)))<font></font>
<font></font>
...<font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">directionTo</span><span class="hljs-params">(gradientPart: Color, blockWidth: CGFloat)</span></span> -&gt; <span class="hljs-type">Angle</span>{
        <span class="hljs-keyword">let</span> angleOf = gradientAngles(blockWidth: blockWidth)
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>.zero
        <span class="hljs-keyword">switch</span> gradientPart{
            <span class="hljs-keyword">case</span> start: angle = angleOf.start
            <span class="hljs-keyword">case</span> middle: angle = angleOf.middle
            <span class="hljs-keyword">case</span> end: angle = angleOf.end
            <span class="hljs-keyword">default</span>: <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"there is no gradient stop with that color: \(gradientPart)"</span>)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gradientAngles</span><span class="hljs-params">(blockWidth: CGFloat)</span></span> -&gt; (start: <span class="hljs-type">Angle</span>, middle: <span class="hljs-type">Angle</span>, end: <span class="hljs-type">Angle</span>){
        <span class="hljs-keyword">let</span> blockHeight = <span class="hljs-keyword">self</span>.bottomRadius
        <span class="hljs-keyword">let</span> center = <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: blockHeight)
        <span class="hljs-keyword">let</span> topRight = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength)
        <span class="hljs-keyword">let</span> topGradientStarts = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength * (<span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop))
        <span class="hljs-keyword">let</span> startAngle = center.radialDirection(to: topRight)
        <span class="hljs-keyword">let</span> middleAngle = center.radialDirection(to: topGradientStarts)
        <span class="hljs-keyword">let</span> endAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)
        <span class="hljs-keyword">return</span> (start: startAngle, middle: middleAngle, end: endAngle)<font></font>
    }<font></font>
<font></font>
...<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">CGPoint</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">radialDirection</span><span class="hljs-params">(to point: CGPoint)</span></span> -&gt; <span class="hljs-type">Angle</span>{
        <span class="hljs-keyword">let</span> deltaX =  point.x - <span class="hljs-keyword">self</span>.x
        <span class="hljs-keyword">let</span> deltaY =  point.y - <span class="hljs-keyword">self</span>.y
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)
        <span class="hljs-keyword">if</span> deltaX == <span class="hljs-number">0</span>{
            <span class="hljs-keyword">if</span> deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaY == <span class="hljs-number">0</span>{
            <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaX / -deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(-deltaX / deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Winkelgradient, der das Ende der Welle darstellt, ist ebenfalls aus Gummi, aber bereits breit - er nimmt die H√§lfte der verbleibenden Gr√∂√üe ein. Deshalb gibt es so viel Trigonometrie. Ich kenne die Position bestimmter Punkte am Bildschirmrand, an denen eine bestimmte Farbe sein sollte (da ich einen kreisf√∂rmigen Farbverlauf mit einem eckigen klebe). Dar√ºber hinaus h√§ngen die Werte der Winkel nicht nur von den Radien des unteren Gradienten ab, sondern auch von der Breite des Blocks selbst mit dem Gradienten. Zum ersten Mal seit der Schule nahm ich einen Bleistift und erinnerte mich an die Algebra :)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle drei Optionen verwenden eine einzige Beschreibung der Farben innerhalb des Verlaufs. </font><font style="vertical-align: inherit;">Dies ist eine einfache Auflistung von Farben in einem Array. </font><font style="vertical-align: inherit;">Ihre Verteilung wird √ºber ein bestimmtes Segment gleichm√§√üig sein. </font><font style="vertical-align: inherit;">Sie k√∂nnen die Verteilung mithilfe eines Arrays von Stop-Elementen verfeinern. </font><font style="vertical-align: inherit;">Tats√§chlich ist dies die gleiche Aufz√§hlung von Farben, nur f√ºr jede von ihnen wird auch die Koordinate auf einem einzelnen Segment angezeigt, in dem sie sich befinden wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So habe ich eine Welle mit ungef√§hr der gleichen Form wie im urspr√ºnglichen Konzept erzeugt. </font><font style="vertical-align: inherit;">Der √úbergang von einer Farbe zur anderen ist jetzt jedoch nicht scharf, sondern gegl√§ttet, was die Animation m√∂glicherweise glatter machen sollte.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbe ist nicht das, was es scheint</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt einen Punkt in Bezug auf Farbe. </font><font style="vertical-align: inherit;">Um den Effekt einer rollenden Welle zu erzeugen, habe ich beschlossen, den √úbergang zwischen Farben nicht ganz linear zu gestalten. </font><font style="vertical-align: inherit;">Wenn Sie genau hinschauen, werden Sie feststellen, dass der Farbverlauf am Rand selbst sch√§rfer ist und je weiter er vom Rand entfernt ist, desto glatter flie√üt er in die Hauptfarbe. </font></font><br>
<img src="https://habrastorage.org/webt/hb/k-/f-/hbk-f-u1tcrri8furxdgeg8tx50.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies habe ich erreicht, indem ich die Zwischenfarbe berechnet und mit dieser Verteilung einen Farbverlauf erstellt habe:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anfangsfarbe - 0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zwischenfarbe - 0,3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Endfarbe - 1</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem trat bei der Berechnung des Durchschnitts zweier Farben auf. SwiftUI bedeutet, das Color-Objekt f√ºr Farbverl√§ufe zu verwenden, und ich wurde verf√ºhrt. Wenn Sie wie bei RGB-Objekten mit Farben arbeiten m√∂chten, verwenden Sie zun√§chst UIColor in Ihrem Modell, da Color keinen direkten Zugriff auf Farben hat. Sie k√∂nnen es auch nicht einfach wieder in UIColor konvertieren. Die einzige </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(nicht)</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ad√§quate L√∂sung, die ich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gefunden </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">habe,</font></a><font style="vertical-align: inherit;"> besteht darin, die Spiegelreflexion mit einer Analyse der Zeichenfolgendarstellung zu erhalten. Solch ein Boilerplate, aber es gibt noch keine anderen Optionen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und das ist kein Fehler, keine Unterlassung. </font><font style="vertical-align: inherit;">Der Punkt ist, dass die SwiftUI im Color-Objekt die Funktionalit√§t von UIColor nicht dupliziert. </font><font style="vertical-align: inherit;">Wenn Sie mit RGB-Kan√§len arbeiten m√ºssen, verwenden Sie diese. </font><font style="vertical-align: inherit;">Farbe in SwiftUI ist eine Ansicht mit einer Grundfarbe, deren spezifischer Wert je nach Position der Sterne am Himmel geringf√ºgig variieren kann. Eine bestimmte RGB-Farbe wird nur zum Zeitpunkt des Zeichnens auf dem Bildschirm festgelegt. </font><font style="vertical-align: inherit;">Die Dokumentation sagt</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SwiftUI l√∂st es nur in einen konkreten Wert auf, bevor es in einer bestimmten Umgebung verwendet wird.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber was ist mit Umgebung gemeint: Die Farbe der Wand hinter dem R√ºcken des Benutzers oder das iOS-Designthema ist nicht klar. </font><font style="vertical-align: inherit;">Wenn dies nicht zu Ihnen passt, verwenden Sie UIColor nativ.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endlose Animation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Animation wird durch den Modifikator .animation () angegeben und beginnt, nachdem View im Modifikator </font></font><code>.onAppear()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durch √Ñndern der </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variablen </font><font style="vertical-align: inherit;">initialisiert wurde </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Infolgedessen </font></font><code>.rotationEffect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abonniert </font><font style="vertical-align: inherit;">der Modifikator </font><font style="vertical-align: inherit;">den Empfang von animatableData im Intervall von "war" bis "wurde", was mit dem System-Timer √ºbereinstimmt. </font><font style="vertical-align: inherit;">Wir haben im letzten Teil dar√ºber gesprochen.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
       <span class="hljs-keyword">return</span> <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>))
            <span class="hljs-type">Spacer</span>()<font></font>
       }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/fl/dw/_0/fldw_0xguydvz5fe_-2tpcp3qkm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie endlose Animationen auf diese Weise ausf√ºhren, sollten Sie verstehen, dass jede sp√§tere √Ñnderung an animierten Modifikatoren diese "kaputt macht". </font><font style="vertical-align: inherit;">Wenn Sie beispielsweise nach dem Start aus irgendeinem Grund den Winkelwert auf 0 √§ndern, erhalten Sie folgenden Effekt:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ad/vi/iv/adviivgxhwuw0rwwv1itknh2kie.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum? Die Antwort liegt im Animationsmechanismus des √úbergangs von einer Animation zur anderen. In unserem Beispiel haben wir beim ersten Erscheinen der Ansicht auf dem Bildschirm einen animierten √úbergang von 0 nach 90 gestartet. In der Ansicht wird nur der Endwert 90 gespeichert, und der urspr√ºngliche Wert 0 wird nirgendwo gespeichert. Die Animations-Engine kennt die aktuelle Zeitposition der Animation und den aktuellen Wert von AnimatableData. Zum Zeitpunkt 0,5 ist es 45. Was passiert, wenn der Benutzer zu diesem Zeitpunkt den Wert auf 0 √§ndert? Antwort: Die Animation zum √Ñndern des Werts von 45 auf 0 beginnt. Alles ist noch in einer Schleife. Aber nur optisch ist der Kreislauf nicht geschlossen, sondern gebrochen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus gibt es F√§lle, in denen die Animation auch "unterbrochen" wird, wenn Ihre Ansicht @ObservedObject oder andere Parameter verwendet, die dazu f√ºhren, dass die Ansicht erneut gerendert wird. Um dieses Problem zu l√∂sen, verf√ºgt der Modifikator .animation √ºber den Parameter .animation (: value :). Wenn Sie den Wert dort √ºbergeben, geben wir dem Renderer an, dass der Neustart der Animation nur erforderlich ist, wenn sich dieser Wert √§ndert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns jedoch herausfinden, wie Sie die Animation stoppen k√∂nnen, wenn wir sie nicht mehr ben√∂tigen. Dazu m√ºssen Sie zwei Dinge angeben. Nat√ºrlich m√ºssen wir SwiftUI mitteilen, dass die endlose Animation nicht mehr ben√∂tigt wird, und sie durch die √ºbliche endg√ºltige ersetzen. Das reicht aber nicht. Der Modifikator .animation () ist eine Anweisung, welche Timings verwendet werden sollen. Die Rotation selbst wird jedoch im Modifikator .rotationEffect () beschrieben und ist bereits abonniert, um neue Werte des Rotationswinkels per Timer zu erhalten. Um die Rotation zu stoppen, m√ºssen wir auch ihren Wert √§ndern.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animation)<font></font>
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.angle == <span class="hljs-number">90</span>{
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">self</span>.animation = .<span class="hljs-keyword">default</span>
                }<span class="hljs-keyword">else</span>{
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span>
                    <span class="hljs-keyword">self</span>.animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/-o/-d/ui/-o-dui_0ep12qm5zwovo2iedvjm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach wie vor f√ºhrte das √Ñndern des Winkelwerts zum Start einer neuen Animation (die fehlerhaft aussah). Diese √Ñnderung wird ebenfalls animiert, jetzt jedoch mit den Timings der normalen Animation. Deshalb h√∂rt unser Quadrat nicht sofort auf, sich zu drehen, sondern wie mit einer Verlangsamung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dasselbe kann etwas pr√§gnanter geschrieben werden, wenn Sie alle Funktionen f√ºr eine </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variable vom Typ Ein / Aus </font><font style="vertical-align: inherit;">aussetzen </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isStarted = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bis zu diesem Punkt war alles relativ einfach. Beachten Sie jedoch, dass alle Ereignisse hier in der Ansicht generiert werden. </font></font><code>.onAppear{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird vom System und </font></font><code>onTapGesture{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nat√ºrlich vom Benutzer </font><font style="vertical-align: inherit;">aufgerufen </font><font style="vertical-align: inherit;">. Was ist jedoch, wenn Sie die gesamte Animation in einer Ansicht zusammenfassen und nur ein- und ausschalten m√∂chten? SwiftUI impliziert nicht die M√∂glichkeit √ºbergeordneter Methoden aus der √ºbergeordneten Ansicht. Theoretisch k√∂nnen Sie die untergeordnete Ansicht als Struktur speichern und ihre Mutationsmethoden aufrufen, aber </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variablen der untergeordneten Ansicht k√∂nnen auf diese Weise nicht ge√§ndert werden. Ich habe es versucht - es funktioniert nicht. Die einzige M√∂glichkeit, so etwas zu tun, besteht darin, das PassthroughSubject des Kombinats zu verwenden, wie Sie es im Artikel getan haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Tat ist alles viel einfacher. Wenn klar in den Regalen im Kopf gelegt, das</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist der interne Status der Ansicht. Wenn Sie nicht versuchen, sie von au√üen zu manipulieren, ist die richtige L√∂sung sehr einfach:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButtonFromOutside</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> isStarted: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectParentView</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isOn = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">AnimatedRectStopButtonFromOutside</span>(isStarted: isOn)
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">self</span>.isOn.toggle()<font></font>
            }<font></font>
        }.onAppear(){<font></font>
            <span class="hljs-keyword">self</span>.isOn = <span class="hljs-literal">true</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall ben√∂tigen wir kein </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abonnement, um die Ansicht in der untergeordneten Ansicht zu aktualisieren. Sie wird bereits als Ganzes aktualisiert, wenn sich der externe Parameter √§ndert. </font><font style="vertical-align: inherit;">Manchmal ist es nicht bequem. </font><font style="vertical-align: inherit;">Manchmal m√∂chten wir die untergeordnete Ansicht nicht erneut initialisieren - zum Beispiel, um die Animation nicht zu unterbrechen, oder in init () treten einige komplexe und ressourcenintensive Berechnungen (z. B. Abfragen) auf. </font><font style="vertical-align: inherit;">In diesen F√§llen ist es besser, Objektentit√§ten zu verwenden, deren √Ñnderungen mit dem Modifikator onReceive √ºberwacht werden k√∂nnen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status w√§hrend der Ansichtsaktualisierung √§ndern</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt noch eine Sache, die es wert ist, behandelt zu werden. Wir haben nur mit zwei Werten von 0 und 90 Grad gearbeitet. Durch Ausschalten der Animation wird der Winkel auf 0 zur√ºckgesetzt. Ist es jedoch m√∂glich, die Animation in dem Moment anzuhalten, in dem wir auf die Schaltfl√§che geklickt haben, und sie an derselben Stelle erneut fortzusetzen, wenn Sie fortfahren? Schauen wir uns den Code an, der dies erm√∂glicht:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRect</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalStarted: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">let</span> externalStarted = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">init</span>(started externalStarted: <span class="hljs-type">Bool</span>){
        <span class="hljs-keyword">self</span>.externalStarted = externalStarted
        <span class="hljs-keyword">self</span>._internalStarted = <span class="hljs-type">State</span>(initialValue: !externalStarted)<span class="hljs-comment">//forse to start animation</span><font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-comment">//thats wrong. It just hiding a problem from SwiftUI not solving it</span>
        <span class="hljs-type">DispatchQueue</span>.main.async {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted == <span class="hljs-literal">false</span>{
                <span class="hljs-comment">// print("stop animation")</span>
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">false</span>
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted {
             <span class="hljs-comment">//    print("start animation")</span>
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">true</span>
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
       }<font></font>
         <font></font>
       <span class="hljs-keyword">return</span>  <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.red)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(internalStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/e9/ci/ge/e9cigegcoxid1l9skuw2qxle238.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hauptidee besteht darin, die Zeit zu Beginn der Animation zu verfolgen. Nach einiger Zeit, wenn es an uns liegt, die Animation zu stoppen, k√∂nnen wir √ºberpr√ºfen, wie viele vollst√§ndige Animationszyklen vergangen sind, und erraten, welchen Drehwinkel des Quadrats wir gerade sehen. Danach k√∂nnen wir </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Drehwinkelvariablen genau diesen Wert </font><font style="vertical-align: inherit;">zuweisen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit dieser Ansatz funktioniert, m√ºssen wir den Anfang und das Ende der Animation verfolgen. Init () funktioniert nicht. Wir k√∂nnen nicht auf vorhandene </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter </font><font style="vertical-align: inherit;">zugreifen </font><font style="vertical-align: inherit;">, um die vorherige Startzeit der Animation abzurufen. Dies ist ein Token von </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variablen. In init k√∂nnen Sie nur den Anfangszustand dieser Variablen festlegen. Wenn jedoch am Ende der Initialisierung View bereits vor init () vorhanden war, wird der Wert der </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variablen wiederhergestellt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher wird hier der Parameter let externalStarted implementiert (den wir von au√üen steuern) und der interne Parameter </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var internalStarted, mit dem wir die Animation direkt steuern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es fehlte nur einer - ein Modifikator, der die Konformit√§t √ºberpr√ºft und bei Bedarf aktualisiert, wie z. B. .onRecieve (), um nur mit jedem Rendering zu arbeiten. </font><font style="vertical-align: inherit;">Und dann dachte ich - schlie√ülich wird der K√∂rper f√ºr jede Zeichnung aufgerufen. Warum also nicht direkt darin einchecken? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellte sich heraus, dass SwiftUI sehr schw√∂rt, wenn die Ansicht w√§hrend des Rendervorgangs den Wert der </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variablen </font><font style="vertical-align: inherit;">√§ndert, die sie </font><font style="vertical-align: inherit;">angibt</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie den Status w√§hrend der Ansichtsaktualisierung √§ndern, f√ºhrt dies zu undefiniertem Verhalten.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und blockiert eine solche √Ñnderung. Dann machte ich einen schmutzigen Hack und benutzte DispatchQueue.main.async. Aber mal sehen, warum dies ein schmutziger Hack ist und warum dies niemals getan werden sollte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist eigentlich das Problem. Wenn wir in den K√∂rper schreiben, ist eine offensichtliche Dummheit wie i + = 1, wo ich eine Art von ist</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel, dann erhalten wir eine Endlosschleife. Zum Zeitpunkt des Renderns machen wir die Ansicht im Speicher nicht relevant, da wir die Anfangsdaten f√ºr das Rendern ge√§ndert haben. Dies bedeutet, dass unsere Ansicht unmittelbar nach Abschluss des Renderns zum erneuten Rendern in die Warteschlange gestellt wird, aber selbst dann wird sie sofort wieder irrelevant. Wir schaffen mit unseren eigenen H√§nden einen endlosen Kreislauf. Ein asynchroner Aufruf √§ndert in diesem Fall nichts. Der Beginn der n√§chsten Runde wird nur geringf√ºgig auf den Moment ‚Äûunmittelbar nach dem Rendern‚Äú verschoben. Ein asynchroner Aufruf l√∂st das Problem also nicht, sondern verschleiert es nur und verhindert, dass SwiftUI uns mit der Nase st√∂√üt. Es ist wie in einem Auto, wenn die Gl√ºhbirne "Motor pr√ºfen" abgerissen ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einerseits, was ist daran falsch? In jeder Programmiersprache gibt es unz√§hlige M√∂glichkeiten, sich in den Fu√ü zu schie√üen, wenn Sie nicht verstehen, was Sie tun. Andererseits ist dieser Ansatz √ºberhaupt nicht so, wie SwiftUI funktionieren sollte. Die Arbeit mit View zur Laufzeit ist schlecht. Ja, Sie k√∂nnen Ihre Fersen in die Brust schlagen und sicherstellen, dass Sie immer den richtigen Code schreiben, der niemals in einer Endlosschleife endet ... Aber es ist wie beim unsicheren Abrufen einer Option - dies ist nur eine schlechte Praxis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie gesagt, in solchen F√§llen sollten Sie Combine verwenden und mit PassthroughSubject einen neuen Wert √ºbergeben. Sie k√∂nnen jedoch mit dem √ºblichen ObservableObject auskommen, indem Sie das willChange-Ereignis abonnieren.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandlerTest</span>
    <span class="hljs-keyword">let</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandlerTest</span>){
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)<font></font>
       }.onReceive(animationHandler.objectWillChange){<font></font>
            <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted
            <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span>
                withAnimation(.<span class="hljs-keyword">none</span>){<span class="hljs-comment">//not working:(((</span>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
                }<font></font>
            }<span class="hljs-keyword">else</span> {
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
        }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span>
            <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der umstrittene Punkt hierbei ist die Verwendung der Werte des Objekts selbst im Abonnement der Benachrichtigung, dass das Objekt nur ge√§ndert wird. </font><font style="vertical-align: inherit;">Bisher habe ich in meinen Beispielen ein bereits modifiziertes Objekt. </font><font style="vertical-align: inherit;">Anscheinend kommen Benachrichtigungen mit einer gewissen Verz√∂gerung. </font><font style="vertical-align: inherit;">Ich kann jedoch nicht garantieren, dass dies immer der Fall ist. Daher empfehle ich, entweder die selbst erstellten didChange-Benachrichtigungen oder PassthroughSubject zu verwenden und den neuen Wert zu √ºbergeben.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wj/ou/nd/wjoundfihtxhnar7iucx7rrkvnm.gif"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animation Animations√§nderungen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie auf dem GIF sehen k√∂nnen, stoppt die Animation nicht sofort. </font><font style="vertical-align: inherit;">Sie braucht etwas Zeit. </font><font style="vertical-align: inherit;">Dies liegt daran, dass wir beim Zuweisen eines Zwischenwerts zum Winkel auch eine bestimmte Animation verwenden - die Standardanimation.</font></font><br>
<br>
<pre><code class="swift hljs">.animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies f√ºhrt zu ungew√∂hnlichem Verhalten. </font><font style="vertical-align: inherit;">Trotz der relativen Einfachheit von allem, was ich beschreibe, bleiben eine Reihe von Interaktionsnuancen unter der Haube, so dass das Bild immer glatt aussieht, auch wenn der nachl√§ssige Programmierer nichts anzeigte. </font><font style="vertical-align: inherit;">Daher ist die Standardanimation Fr√ºhling. </font><font style="vertical-align: inherit;">Es eignet sich am besten zur Simulation der Gesetze der Physik. </font><font style="vertical-align: inherit;">Dar√ºber hinaus ist dies eine ziemlich kurze Animation, etwa 0,2 Sekunden. </font><font style="vertical-align: inherit;">Wenn die Animation des √úbergangs in einen neuen Zustand (der von uns berechnete und angegebene Winkel) keine Zeit hat, sich perfekt in die Standard-0,2 Sekunden einzuf√ºgen, um von der aktuellen Animationsgeschwindigkeit mit einer sch√∂nen Verlangsamung zu einem vollst√§ndigen Stopp zu wechseln, f√ºgt SwiftUI selbst eine weitere Schleife endloser Animationen hinzu, die in der beschleunigten Version abgespielt werden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z0/b0/so/z0b0soljlzjqudxhek_irdxgyoy.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dies zu vermeiden, reicht es aus, die Standardanimation nicht zu verwenden. </font><font style="vertical-align: inherit;">F√ºr das untere Quadrat habe ich die Rotationsstopp-Animation folgenderma√üen deaktiviert:</font></font><br>
<br>
<pre><code class="swift hljs">                
.animation(animationHandler.isStarted ? animation : <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oder Sie k√∂nnen den erforderlichen Wert des Parameters zum Zeitpunkt des Stopps genauer berechnen. Dazu m√ºssen Sie jedoch den aktuellen Moment der Animation nicht nur ann√§hernd annehmen, sondern ihn auch genau kennen. </font><font style="vertical-align: inherit;">Ich werde unten zeigen, wie das geht.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bewegung mehrerer Wellen in einer Animation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur√ºck zur Regenbogenanimation. </font><font style="vertical-align: inherit;">Also, wir haben die Wellen selbst, lasst uns ihnen beibringen, sich zu bewegen. </font><font style="vertical-align: inherit;">Das erste, was ich tun m√∂chte, ist eine endlose Animation auszuf√ºhren. </font><font style="vertical-align: inherit;">Ich habe mich dazu entschlossen: Ich werde eine </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variable haben, die f√ºr die aktuelle Position der Animation verantwortlich ist. </font><font style="vertical-align: inherit;">Im Zustand 0 befindet sich die erste Welle ganz am Anfang und die letzte ganz am Ende. </font><font style="vertical-align: inherit;">Die Wellen selbst √ºberlappen sich. </font><font style="vertical-align: inherit;">Somit h√§ngt die L√§nge des sichtbaren Teils jeder Welle von der Anzahl der Wellen ab. </font><font style="vertical-align: inherit;">Ich habe dies mit ZStack implementiert, in dem alle Wellen aufgelistet sind, und mit meinem eigenen Modifikator .wavePosition, in dem ich die aktuelle Position jeder Welle zum Zeitpunkt der Animation und die Reihenfolge ihrer √úberlappung berechne.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">viel Code</font></font></b>
                        <div class="spoiler_text"><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpWavePosition</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">let</span> wave: <span class="hljs-type">WaveDescription</span>
    <span class="hljs-keyword">let</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    <span class="hljs-keyword">var</span> time: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> currentPosition: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> { time}
        <span class="hljs-keyword">set</span> {
                <span class="hljs-keyword">self</span>.time = newValue
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">init</span>(wave: <span class="hljs-type">WaveDescription</span>, time: <span class="hljs-type">CGFloat</span>, animationHandler: <span class="hljs-type">AnimationHandler</span>){
        <span class="hljs-keyword">self</span>.wave = wave
        <span class="hljs-keyword">self</span>.time = time
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-number">0</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(forWave: Int, ofWaves: Int, overTime: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{<font></font>
<font></font>
        <span class="hljs-keyword">let</span> time = overTime - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(overTime))
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(ofWaves)
        <span class="hljs-keyword">let</span> initialPosition = oneWaveWidth * <span class="hljs-type">CGFloat</span>(forWave)
        <span class="hljs-keyword">let</span> currentPosition = initialPosition + time
        <span class="hljs-keyword">let</span> fullRounds = <span class="hljs-type">Int</span>(currentPosition)
        <span class="hljs-keyword">var</span> result = currentPosition - <span class="hljs-type">CGFloat</span>(fullRounds)
        <span class="hljs-keyword">if</span> fullRounds &gt; <span class="hljs-number">0</span> &amp;&amp; result == <span class="hljs-number">0</span>{
            <span class="hljs-comment">// at the end of the round it should be 1, not 0</span>
            result = <span class="hljs-number">1</span><font></font>
        }<font></font>
 <span class="hljs-comment">//       print("wave \(forWave) in time \(overTime) was at position \(result)")</span>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(wave.totalWavesCount)
        <span class="hljs-keyword">var</span> thisIsFirstWave = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> currentPosition &lt; oneWaveWidth{<font></font>
            thisIsFirstWave = <span class="hljs-literal">true</span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span>
            <span class="hljs-type">Group</span>{<font></font>
                content<font></font>
                            .offset(x: -wave.width + currentPosition * (wave.width +  wave.gradientLength),<font></font>
                            <span class="hljs-comment">//to watch how waves move uncoment this</span>
                           <span class="hljs-comment">// y: CGFloat(self.waveInd * 20))</span>
                        y:<span class="hljs-number">0</span>)<font></font>
                    .zIndex(-<span class="hljs-type">Double</span>(currentPosition))<font></font>
                    .transition(.identity)<font></font>
                    .animation(<span class="hljs-literal">nil</span>)<font></font>
<font></font>
                <span class="hljs-keyword">if</span> thisIsFirstWave{<font></font>
                    content<font></font>
                        .offset(x: wave.gradientLength, y: <span class="hljs-number">0</span>)<font></font>
                        .zIndex(-<span class="hljs-number">2</span>)<font></font>
                        .transition(.identity)<font></font>
                        .animation(<span class="hljs-literal">nil</span>)<font></font>
                }<font></font>
            }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">positionOfSharp</span><span class="hljs-params">(wave: WaveDescription, inTime: CGFloat, animationHandler: AnimationHandler)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">SharpWavePosition</span>(wave: wave, time: inTime, animationHandler: animationHandler))<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpRainbowView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">let</span> waves: [<span class="hljs-type">SharpGradientBorder</span>]
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-comment">//@ObservedObject</span>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> rainbowPosition: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandler</span>,<font></font>
        backgroundColor: <span class="hljs-type">Color</span> = .clear<font></font>
    ){<font></font>
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">let</span> bottomRadius = animationHandler.waveGeometry.bottomRadius
        <span class="hljs-keyword">let</span> topRadius = animationHandler.waveGeometry.topRadius
        <span class="hljs-keyword">let</span> gradientLength = animationHandler.waveGeometry.gradientLength
        <span class="hljs-keyword">let</span> rainbowColors = animationHandler.rainbowColors
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">var</span> lastColor = rainbowColors.last <span class="hljs-keyword">else</span> {<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"no colors to display in rainbow"</span>)}
        <span class="hljs-keyword">var</span> allWaves = [<span class="hljs-type">SharpGradientBorder</span>]()
        <span class="hljs-keyword">for</span> color <span class="hljs-keyword">in</span> rainbowColors{
            <span class="hljs-keyword">let</span> view = <span class="hljs-type">SharpGradientBorder</span>(start: color,<font></font>
                                      end: lastColor,<font></font>
                                      bottomRadius: bottomRadius,<font></font>
                                      topRadius: topRadius,<font></font>
                                      gradientLength: gradientLength)<font></font>
            allWaves.append(view)<font></font>
            lastColor = color<font></font>
        }<font></font>
        <span class="hljs-keyword">self</span>.waves = allWaves<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span>
            <span class="hljs-type">VStack</span>{
                <span class="hljs-type">ZStack</span>{
                    <span class="hljs-type">ForEach</span>(<span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){ind <span class="hljs-keyword">in</span>
                        <span class="hljs-keyword">self</span>.waves[ind]<font></font>
                            .positionOfSharp(wave: <span class="hljs-type">WaveDescription</span>(ind: ind,<font></font>
                                                    totalWavesCount: <span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">count</span>,<font></font>
                                                    width: geometry.size.width,<font></font>
                                                    baseColor: <span class="hljs-keyword">self</span>.waves[ind].end,<font></font>
                                                    gradientLength: <span class="hljs-keyword">self</span>.waves[ind].bottomRadius + <span class="hljs-keyword">self</span>.waves[ind].topRadius),<font></font>
                                             inTime: <span class="hljs-keyword">self</span>.rainbowPosition,<font></font>
                                             animationHandler: <span class="hljs-keyword">self</span>.animationHandler)<font></font>
                            .animation(<span class="hljs-keyword">self</span>.animationHandler.isStarted ? <span class="hljs-keyword">self</span>.animation : .linear(duration: <span class="hljs-number">0</span>))<font></font>
                    }<font></font>
                }<font></font>
     <span class="hljs-comment">//           .clipped()</span><font></font>
            }<font></font>
<font></font>
        }<font></font>
        .onAppear(){<font></font>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.animationHandler.isStarted{
                <span class="hljs-keyword">self</span>.rainbowPosition = <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
        .onReceive(animationHandler.objectWillChange){<font></font>
             <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted
             <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{
                <span class="hljs-keyword">let</span> newPosition = <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"animated from \(self.rainbowPosition - 1) to \(self.rainbowPosition) stopped at \(newPosition)"</span>)
                    <span class="hljs-keyword">self</span>.rainbowPosition = newPosition<font></font>
             }<span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">self</span>.rainbowPosition += <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
 </code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Ansicht zum ersten Mal auf dem Bildschirm angezeigt wird, √§ndern wir den Status von 0 auf 1, wodurch die Wellen unter Ber√ºcksichtigung der deklarierten linearen Animation endlos √ºber den Bildschirm laufen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/vr/ym/bgvrymyoubpekjmpgnsrtxxgco8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Rand der Welle den rechten Rand erreicht, befindet sich ihre n√§chste Position ganz am Anfang, jenseits des Bildschirmrandes. Es sieht so aus, als w√ºrde es einfach vom Ende der Welle verschwinden und das Hintergrundsubstrat freilegen, was wir vermeiden m√∂chten. Zu diesem Zweck wurde der if {...} -Block im Modifikator in der body () -Funktion angezeigt, in der eine Kopie der ersten auf dem Bildschirm fehlenden Welle gezeichnet wird.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/si/6m/vt/si6mvtiimlv73kxy4c4imperxc4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass ich die geometrischen Eigenschaften jeder Welle in Form von Modifikatorparametern √ºbertragen musste. </font><font style="vertical-align: inherit;">Das Problem war, dass ich den Z-Index jeder Welle basierend auf der aktuellen Animationsphase neu definieren musste. </font><font style="vertical-align: inherit;">Ich konnte die Breite des sichtbaren Bereichs mithilfe des GeometryReader {} -Modifikators im Inneren extrahieren. Ich war jedoch mit der Tatsache konfrontiert, dass er die √Ñnderung der Reihenfolge der √úberlagerung von Wellen blockiert. </font><font style="vertical-align: inherit;">Der Modifikator .zIndex () funktioniert nur im Kontext des ersten ZStack {} -Containers in der Ansichtshierarchie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GeometryReader unterbricht diese Verbindung und zIndex () funktioniert nicht mehr. </font><font style="vertical-align: inherit;">Wenn Sie bis zu diesem Zeitpunkt dachten, dass GeometryReader eine harmlose M√∂glichkeit ist, Daten √ºber die Gr√∂√üe der aktuellen Ansicht abzurufen, ist dies nicht ganz richtig.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flow-Animation</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer wichtiger Punkt ist das Verst√§ndnis der Animation der integrierten Modifikatoren in Ihren eigenen Modifikatoren. Irgendwann n√§hert sich jede Welle dem Bildschirmrand, um den maximalen horizontalen Versatz zu erhalten, und geht dann zur Startposition, um den minimalen Versatz zu erhalten. Dies ist die gleiche √Ñnderung wie jede andere und wird auch innerhalb der Animation animiert. Schlie√ülich ist Animation nur eine sehr h√§ufige √úbertragung von Werten an den Modifikator, und sie wird auch mit der Animation ausgef√ºhrt, egal wie seltsam sie klingt. Es stellt sich heraus, dass wir innerhalb der Animation, wenn wir innerhalb dieses Modifikators einen neuen Wert √ºbergeben, nur den Endpunkt der aktuellen Bewegungsanimation √§ndern. Es stellt sich heraus, dass sich jede Welle, die den Rand des Bildschirms erreicht, umdreht und zur√ºckschwebt. Aber es erreicht auch nicht den Start, sondern holt fr√ºher oder sp√§ter die erforderliche Position ein.und bewegt sich dann wieder von links nach rechts.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/aj/xp/ky/ajxpkyp6nxn-e6ixzzrv7y-g-c4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen dieses Problem l√∂sen, indem Sie den Modifikator .animation (nil) einf√ºgen. Daher deaktiviere ich die Animation aller oben im Text angewendeten Modifikatoren. Dies ist die allgemeine Logik der Arbeit eines Modifikators: Sie √§ndert, was sich auf seiner Eingabe befindet, und auf der Eingabe haben wir das Ergebnis aller vorherigen Modifikatoren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Generell funktioniert hier eine ganze Hierarchie verschiedener Animationen. Die Standardeinstellung wird verwendet, um √Ñnderungen an allen Modifikatoren anzuzeigen, sofern Sie f√ºr Ihre Ansicht nichts anderes angeben. Wir haben einen Ausf√ºhrungsthread (sagen wir, dies ist der Hauptstrang), in dem der K√∂rper aufgerufen wird. Wir gehen davon aus, dass es den Parameter .animation hat, der jedes Mal √ºberpr√ºft wird, wenn ein Modifikator einen neuen Wert erh√§lt. Wenn der Modifikator Animation unterst√ºtzt (entspricht dem AnimatableModifier-Protokoll) und die Animation f√ºr den Stream aktiviert ist (eine bestimmte Animation wird verwendet, nicht .none oder nil), wird die √Ñnderung animiert. Dies ist, was wir tun, indem wir einen Code zum √Ñndern von </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parametern in den withAnimation {} -Block einschlie√üen - wir schreiben eine bestimmte Animation im aktuellen Thread vor und nehmen dann eine Art √Ñnderung vor</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variable. In diesem Fall ist dies mit Animation {} eine Art Transaktions√§quivalent, und alle an dieser Transaktion vorgenommenen √Ñnderungen werden animiert. Infolgedessen beginnt innerhalb desselben Streams ein Zyklus der √úbersetzung dieser √Ñnderungen in alle abh√§ngigen Ansichten. Die Modifikatoren dieser Ansicht erhalten einen neuen Wert und abonnieren, um Zwischenwerte von AnimatableData zu erhalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus gibt es Elemente in der Animation, auf die Sie keinen Einfluss haben. Zum Beispiel wird die Position des Schiebereglers durch interne Mechanismen von selbst animiert, und es ist nichts dagegen zu tun.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit WithAnimation () k√∂nnen Sie daher die Standardanimation f√ºr die ausgef√ºhrte Aktion starten. F√ºr bestimmte Ansichten k√∂nnen Sie jedoch mithilfe des Modifikators .animation () explizit Ihre eigene Animation angeben. In diesem Fall erhalten die Modifikatoren und Formulare, aus denen der an .animation () √ºbergebene Inhalt besteht (alles, was im Code aufgef√ºhrt ist, bevor .animation () angewendet wird), das von Ihnen beschriebene Timing und ignorieren die Stream-Animation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In meinem WavePosition-Modifikator verwende ich .animation (nil), um die integrierte Offset-Animation zu entfernen, und weise mich an, die aktuelle Stream-Animation zu ignorieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die gleiche Geschichte mit der Endkappe. Ich m√∂chte Sie an die Schlussfolgerungen aus dem letzten Artikel erinnern. Tats√§chlich haben wir N WavePosition-Modifikatorstrukturen in unserem Speicher, eine f√ºr jede Welle. Und alle erhalten einen neuen Positionswert vom System-Timer, der die Position jeder Welle zu einem bestimmten Zeitpunkt berechnet. Dies bedeutet, dass wir auch N Endkappen f√ºr jede Welle haben. Es ist nur so, dass dank des if {} -Blocks immer nur einer von ihnen angezeigt wird. Der gleiche Block legt uns jedoch ein Schwein. Das Verschwinden und Erscheinen der Ansicht wird auch mit der Animation des Streams ausgef√ºhrt. Dies bedeutet, dass der Modifikator .transition verwendet wird, um das Erscheinen und Verschwinden der Ansicht nach dem √Ñndern der Bedingung zu animieren. Normalerweise wird standardm√§√üig .opacity verwendet, aus irgendeinem Grund wurde jedoch stattdessen .slide f√ºr mich verwendet. Keiner passt zu mir, also habe ich diese Animation gerade abgesagt.mit .transition (.identity).</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">upd. </font><font style="vertical-align: inherit;">W√§hrend ich den Artikel vorbereitete, kam Xcode 11.4 heraus, in dem anscheinend der √úbergang standardm√§√üig √ºberarbeitet wurde. </font><font style="vertical-align: inherit;">Zumindest habe ich jetzt .transition (.identity) ohne Probleme auskommentiert und das Problem, das mich veranlasst hat, es hinzuzuf√ºgen, nicht erhalten.</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animationszeiten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt kommen wir endlich zu der interessantesten Frage: Wie k√∂nnen sich die Wellen beschleunigen? </font><font style="vertical-align: inherit;">Wie immer komme ich von weit her.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tats√§chlich ist Animation eine Beschreibung der Geschwindigkeit einer bestimmten Animation. Wir k√∂nnen die Route von Punkt A nach Punkt B innerhalb des Modifikators selbst bestimmen, aber SwiftUI entscheidet, wann und welche Art von AnimatableData-Wert an ihn √ºbergeben werden soll. Er macht das mit einer Zeitkurve. Angenommen, wir nehmen Punkt A als Ursprung und markieren Punkt B als Punkt mit Koordinaten (1; 1). Horizontal markieren wir die verstrichene Zeit (die Bewegung von Punkt A nach Punkt B dauert genau 1 Zeiteinheit). Vertikal - Die zur√ºckgelegte Strecke in Bruchteilen einer Einheit. Bei Verwendung der linearen Animation erhalten wir direkt. Wenn wir die Bewegung ein wenig √§hnlich wie in der Gegenwart machen wollen, m√ºssen wir zuerst ein wenig Zeit f√ºr das Beschleunigen und am Ende f√ºr das Bremsen aufwenden. Genau </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen mit verschiedenen Optionen herumspielen, indem Sie Ihre eigene Kurve zeichnen und ihre Bewegungsanimation mit den Standardanimationen vergleichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In SwiftUI werden Bezier-Kurven f√ºr verschiedene Arten von Animationen verwendet. </font><font style="vertical-align: inherit;">In jedem Fall sollte es bei (0; 0) beginnen und bei (1; 1) enden. </font><font style="vertical-align: inherit;">Die Kr√ºmmung der Linie wird durch die Kontrollpunkte bestimmt.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschachtelte Zeitkurve in linearer endloser Animation</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was m√ºssen wir also tun, um die beschleunigte Bewegung jeder Welle (easyIn) innerhalb einer linearen Schleifenanimation zu erreichen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die aufgeschl√ºsseltste Option, die ich finden konnte, war, meine eigene Zeitkurve zu implementieren und den linearen Zeitfluss damit in eine Art .easeIn umzuwandeln. </font><font style="vertical-align: inherit;">Mit diesem Beispiel k√∂nnen Sie sehr gut verstehen, wie dies funktioniert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee ist einfach. Wir werden unsere eigene Klasse basierend auf dem Pfad erstellen - der Bezier-Kurve, mit der wir den Abstand von Punkt A zu Punkt B bestimmen, der zu jedem bestimmten Zeitpunkt angezeigt werden muss. Genau so funktioniert Animation in SwiftUI und in jedem anderen Framework mit √§hnlichen Funktionen. Mithilfe einer Zeitkurve werden echte Sekunden und Millisekunden (die jedoch meistens linear flie√üen) in Bruchteile der Entfernung umgewandelt (genauer gesagt Bruchteile des animierten Segments - der AnimatableData-Vektor, der die vorgenommene √Ñnderung darstellt). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist meine erste Implementierung:</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getActualPosition</span><span class="hljs-params">(of position: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-keyword">let</span> correctPosition = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">min</span>(position, <span class="hljs-number">1</span>), <span class="hljs-number">0</span>) / duration
        <span class="hljs-keyword">let</span> trimmingCurve = <span class="hljs-type">TimingCurve</span>.superEaseInPath
        <span class="hljs-keyword">if</span> correctPosition &lt; <span class="hljs-number">0.0000001</span>{
            <span class="hljs-keyword">let</span> reversedCurve = <span class="hljs-type">Path</span>(<span class="hljs-type">UIBezierPath</span>(cgPath: trimmingCurve.cgPath).reversing().cgPath)
            <span class="hljs-comment">//trim to start point is impossible, so reverce the curve and get last point</span>
            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = reversedCurve.currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve start point"</span>)}
            <span class="hljs-keyword">return</span> point.y<font></font>
        }<font></font>
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = trimmingCurve.trimmedPath(from: <span class="hljs-number">0</span>, to: correctPosition).currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve point at \(position)"</span>)}
        <span class="hljs-keyword">return</span> point.y * <span class="hljs-keyword">self</span>.duration<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anscheinend war ich ein bisschen dumm. Per Definition muss ich einen Punkt auf der Kurve finden, der dem angegebenen Wert von X entspricht, und ihn an Y zur√ºckgeben. Ich konnte keine integrierte Standardmethode zur L√∂sung dieses Problems oder ein beliebtes Muster finden, daher habe ich beschlossen, die vorhandene Trimmmethode f√ºr diese Zwecke anzupassen ( ) Ich entschied, dass ich den Ansatz sehr gut √ºberdenken und den gew√ºnschten Punkt erhalten k√∂nnte, indem ich den Teil des Pfades erhalte, der dem Bruchteil der zur√ºckgelegten Strecke entspricht. F√ºr Null gibt diese Methode 0 zur√ºck, f√ºr 1 gibt sie 1 zur√ºck. In der Mitte ist wahrscheinlich auch alles ungef√§hr korrekt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mir war bewusst, dass ein solcher Ansatz kein sehr genaues Ergebnis liefern w√ºrde. Die Schwere des Problems trat jedoch sp√§ter auf, als ich versuchte, genau dieselbe Animation auf standardm√§√üige Weise zu reproduzieren. Ich war √ºberrascht, wie unterschiedlich es ist, und entschied mich, in der Grafik zu √ºberpr√ºfen, wie weit die auf diese Weise erhaltenen Punkte von der urspr√ºnglichen Kurve entfernt sind. Das Ergebnis hat mir nicht gefallen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fl/ed/s-/fleds-cdj4f8ellnui32gn-kiyk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Punkte sind nicht nur weit von der gew√ºnschten Kurve entfernt, sondern die Art der Kurve ist auch verzerrt. Es gibt einen zus√§tzlichen Knick, den ich √ºberhaupt nicht brauche. Infolgedessen musste ich immer noch einen relativ genauen Weg finden, um einen Punkt auf einer Bezier-Kurve zu finden, wobei ich nur eine Koordinate kannte:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich musste viele Segmente im Speicher speichern, deren Enden auf einer bestimmten Kurve liegen. Eine Suche nach Y durch ein gegebenes X mit diesem Ansatz ist eine Suche nach dem entsprechenden Segment, dessen Aufteilung gegebenenfalls in zwei H√§lften, bis eine der Grenzen eines solchen Segments ausreichend nahe am gew√ºnschten Punkt liegt. In diesem Fall finden wir den Punkt mit der erforderlichen X-Koordinate auf diesem Segment und geben ihn Y zur√ºck. Wenn Sie einfachere Methoden kennen, um einen Punkt auf einer beliebigen Bezier-Kurve mit einer bestimmten Koordinate zu finden, schreiben Sie in die Kommentare. Ich denke, es kann f√ºr viele n√ºtzlich sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen liegen die Punkte ziemlich nahe am Diagramm:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/bk/qi/wxbkqitda0fmf516tl1vjarqgoq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe ein Singlton-Objekt erstellt, um eine Zeitkurve f√ºr Kontrollpunkte zu erstellen und das Array von Segmenten zwischenzuspeichern, mit denen Y gesucht wird. Um einen bestimmten Punkt auf der Kurve zu finden, muss ich nur das Segment finden, in dem dieser Punkt liegt, und es in zwei H√§lften teilen bis eines der Enden des Segments nahe genug an diesem Punkt liegt, um in den gegebenen Fehler zu fallen, und dann den Wert von Y entlang des gegebenen X linear interpolieren und einen Teil der Kurve durch dieses Segment ersetzen. Ich behaupte nicht, dass dies der beste Weg ist und dass es in allen F√§llen funktionieren wird. Schreiben Sie erneut in die Kommentare, wenn Sie bessere M√∂glichkeiten kennen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Hilfe eines solchen Werkzeugs wird die Umwandlung von linearen Animationen in nichtlineare einfach. </font><font style="vertical-align: inherit;">Alles, was ben√∂tigt wird, ist, die Kurve durch zwei Kontrollpunkte zu beschreiben und die Position auf dem Segment gem√§√ü dieser Kurve neu zu berechnen. </font><font style="vertical-align: inherit;">Wenn eine Animation unterschiedlicher Dauer erforderlich ist, verwenden wir weiterhin eine Einheitskurve mit dem entsprechenden Koeffizienten f√ºr die X-Koordinate.</font></font><br>
<br>
<pre><code class="swift hljs">        
<span class="hljs-keyword">self</span>.timing = <span class="hljs-type">TimingCurve</span>.superEaseIn(duration: <span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> animatedPosition = timing.getY(onX: currentPosition)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht die Animation zusammen mit unserer Timing-Kurve aus: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vf/f0/fe/vff0fe07bgvlvqhhuok5vy_w8ga.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Den vollst√§ndigen Code finden Sie im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der TimingCurveView-Datei. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie dieses Beispiel verstanden haben, werden Sie zu 100% verstehen, wie die Animationszeiten angeordnet sind. </font><font style="vertical-align: inherit;">√úbrigens k√∂nnen Sie dieses Wissen nutzen, da Sie mit SwiftUI mithilfe der Funktion timingCurve () eine eigene Timing-Kurve f√ºr Kontrollpunkte erstellen und wie jede andere Animation verwenden k√∂nnen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberleitung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt haben wir eine ertr√§gliche endlose Animation. Es bleibt nur herauszufinden, wie es ein- und ausgeschaltet werden soll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee, das Erscheinungsbild zu animieren, besteht darin, den Animationsblock nur an der bereits eingeschalteten Stelle erscheinen zu lassen, aber der Vorhang wird wie ein Vorhang im Theater zur√ºckgezogen. Wenn wir die Geschwindigkeit des Vorhangs mit der Geschwindigkeit der Wellen innerhalb der Animation synchronisieren und im Vorhang selbst einen Farbverlauf von der Hintergrundfarbe zur Farbe der aktuell einfallenden Welle erzeugen, erhalten wir einen visuellen Effekt, als w√§re dieser Vorhang die erste rollende Welle. Um die Bewegungsgeschwindigkeit zu synchronisieren, verwenden wir einfach dieselbe TimingCurve wie zum Animieren der Bewegung der Welle. Zum Gl√ºck wissen wir jetzt, wie das geht.</font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.timingCurve(<span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.x),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.y),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.x),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.y),<font></font>
                                duration: <span class="hljs-number">1</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Animation.timingCurve (x: y :) k√∂nnen Sie Ihr eigenes Animations-Timing basierend auf den Kontrollpunkten von Bezier-Kurven festlegen. </font><font style="vertical-align: inherit;">Am Ausgang erhalten wir ein vollwertiges Animationsobjekt wie das bekannte .linear (Dauer: 1), das ohne Einschr√§nkungen verwendet werden kann. </font><font style="vertical-align: inherit;">Und wenn ich bedenke, dass ich genau die gleichen Kontrollpunkte f√ºr die Wellenanimation verwende, ist die Animation synchron.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es w√§re bequemer, den Code zu organisieren ...</font></font></b>
                        <div class="spoiler_text">   .<br>
<br>
 ,           ,    ,          ‚Ä¶     ,     ,     .  -  ,        ‚Äî    .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Deaktivieren der Animation kann auf die gleiche Weise erfolgen. Es sollte nur der Vorhang auf den Animationsblock kriechen und ihn allm√§hlich schlie√üen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste Problem trat in dem Moment auf, als ich den aktuellen Status der Animation abrufen musste, um die Farbe des Vorhangs zu w√§hlen. </font><font style="vertical-align: inherit;">Zu diesem Zweck habe ich ein ObservableObject erstellt, das ich im Modifikator √ºbergebe und das ich im AnimatableData-Setter √§ndere. </font><font style="vertical-align: inherit;">Es ist wichtig zu verstehen, dass das 60-malige √Ñndern der @Published-Eigenschaft pro Sekunde √ºberhaupt nicht das ist, was Sie ben√∂tigen. </font><font style="vertical-align: inherit;">So √§ndern Sie </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variablen innerhalb eines Bodyblocks. </font><font style="vertical-align: inherit;">Wir m√ºssen nichts initiieren, wenn sich der Status der Animation √§ndert. </font><font style="vertical-align: inherit;">Wenn n√∂tig, k√∂nnen wir den Status der Animation jederzeit herausfinden.</font></font><br>
<br>
<pre><code class="swift hljs">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> { time}
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">if</span> animationHandler.isStarted{
                <span class="hljs-keyword">self</span>.time = newValue
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.time != <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition{
                    <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition = <span class="hljs-keyword">self</span>.time<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)
            <span class="hljs-keyword">if</span> currentPosition &lt; <span class="hljs-number">0.01</span>{<font></font>
                animationHandler.currentWaveBaseColor = wave.baseColor<font></font>
            }<font></font>
        }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus diesem Grund habe ich SharpRainbowView nicht angemeldet, um √Ñnderungen an AnimationHendler zu verfolgen: </font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-comment">//@ObservedObject</span>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Funktionsweise dieser Vorh√§nge zu veranschaulichen, schalte ich die Anzeige der Vorg√§nge au√üerhalb der Ansicht ein, indem ich .clipped () auskommentiere. Au√üerdem werde ich den Vorhang aus Gr√ºnden der √úbersichtlichkeit leicht √ºber die Animation bewegen. Jetzt ist es klarer, nicht wahr? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/uf/0k/6suf0klfghhgxj95qfnrxd29zpe.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Vorh√§nge mussten kurz sein, damit der von jeder Welle und jedem Vorhang zur√ºckgelegte Weg zusammenfiel (andernfalls w√ºrde sich eine asynchrone Animation ergeben), aber gleichzeitig gelang es ihr, vollst√§ndig vom Bildschirm zu verschwinden. Gleichzeitig ist der Vorhang als Farbverlauf in drei Farben angeordnet. Dies ist am schlie√üenden Vorhang deutlich sichtbar. Das liegt an den langen Schw√§nzen, die mir am Anfang so gut gefallen haben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Sache ist, dass die erste Welle der Gradient der letzten und ersten Farbe des √ºbertragenen Arrays ist. Keiner von ihnen darf mit der Hintergrundfarbe √ºbereinstimmen. Daher bestand im Allgemeinen ein Bedarf an Vorh√§ngen. Um den Vorhang zweifarbig zu machen, von der Hintergrundfarbe bis zur Grundfarbe der ersten Welle, hat mich die L√§nge des Vorhangs daran gehindert. Es √ºberlappt einfach nicht den langen Schwanz der ersten Welle, und es wird ein Rand einer Farbe und der Schwanz einer anderen erhalten. Deshalb musste ich den Vorhang dreifarbig machen - zuerst vom Hintergrund bis zur Farbe der letzten Welle und dann von der Farbe der letzten Welle bis zur ersten. Dann passt der Schwanz der ersten Welle gut zum Rand des Vorhangs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus ungef√§hr den gleichen Gr√ºnden machten sie den schlie√üenden Vorhang auch dreifarbig. Ansonsten sah die Grenze unnat√ºrlich aus. Infolgedessen stellte sich heraus, dass die erste ‚ÄûWelle‚Äú (und jetzt wissen wir, dass dies tats√§chlich der in Transition.truncate beschriebene Vorhang ist) kurz war. Und obwohl es sich vollst√§ndig synchron mit der ersten Welle bewegt, d.h. beschleunigt und nicht linear √§ndert sich seine Breite nicht mit der Zeit, obwohl die Breite nachfolgender Wellen visuell zunimmt. Dies kann durch dynamisches √Ñndern der Breite des Vorhangs besiegt werden, aber ich war ehrlich gesagt faul. Betrachten wir dies als Hausaufgabe f√ºr diejenigen, die in diese Mechanismen eintauchen und einen Code rauchen m√∂chten (ich entschuldige mich im Voraus bei solchen Leuten, es gibt viele Spuren meiner Experimente, die Sie verwirren k√∂nnen).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt ein Problem. </font><font style="vertical-align: inherit;">Wenn Sie die Taste zu einem erfolglosen Zeitpunkt dr√ºcken, deckt der schlie√üende Vorhang die n√§chste Welle kaum ab. </font><font style="vertical-align: inherit;">Es sieht nicht sehr gut aus. </font><font style="vertical-align: inherit;">Sie k√∂nnen das Problem l√∂sen, indem Sie das Ausblenden der Ansicht mit Animation geringf√ºgig verz√∂gern. </font><font style="vertical-align: inherit;">Wir haben eine M√∂glichkeit, die aktuelle Position der Animation herauszufinden. Wir m√ºssen nur den Beginn des √úbergangs ein wenig verschieben, und die letzte Welle wird immer vollst√§ndig angezeigt.</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle animation"</span>).onTapGesture {<font></font>
                withAnimation(){<font></font>
                    <span class="hljs-keyword">var</span> delay: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.isShown{
                        <span class="hljs-keyword">let</span> waveChangeTime: <span class="hljs-type">Double</span> = <span class="hljs-type">Double</span>(<span class="hljs-number">1</span>) /  <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.rainbowColors.<span class="hljs-built_in">count</span>)
                        <span class="hljs-keyword">let</span> currentTime = <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition)
                        <span class="hljs-keyword">let</span> wavesPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(currentTime / waveChangeTime))<font></font>
                        delay =  (wavesPassed + <span class="hljs-number">1</span>) * waveChangeTime - currentTime<font></font>
                        delay = <span class="hljs-built_in">max</span>(delay - <span class="hljs-number">0.05</span>, <span class="hljs-number">0</span>)
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">"currentTime: \(currentTime); delay \(delay)"</span>)<font></font>
                    }<font></font>
                    <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + delay) {
                        <span class="hljs-keyword">self</span>.isShown.toggle()<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nat√ºrlich k√∂nnen Sie den Vorhang auch auf eine variable Breite einstellen, um die Illusion unterschiedlicher Geschwindigkeiten der Grenze zwischen Hintergrund und Vorhang sowie zwischen Vorhang und erster Welle zu erzeugen, aber jetzt sieht die erste Welle etwas unnat√ºrlich aus, aber ich bin bereits zu faul, um mich darum zu k√ºmmern.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transition liebt es, ein Schwein zu f√ºttern</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen sind Animationen von Erscheinung und Verschwinden f√ºr mich ein sehr cooles Werkzeug. Es scheint jedoch, dass dieses Konzept neu ist und nicht alle Tools normalerweise damit umgehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Modifikator .rotation3DEffect () invertiert die Ansicht mit einigen komplexen Animationen recht erfolgreich, wei√ü jedoch nicht, wie .transition invertiert werden soll. Es war so entt√§uschend, einen pr√§zisen Code zu schreiben, zu sehen, wie sich Ihre Wellen von der Mitte des Bildschirms wegstreuen, und dann zu sehen, dass auf der linken Seite die Vorh√§nge von links nach rechts verlaufen. Ich musste ein paar Boilerplates schreiben, damit der √úbergangsmodifikator in beide Richtungen funktionieren konnte.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pn/3c/fg/pn3cfg8f6zsersnfgdv5_ixrqu8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Modifikator drowingGroup (), mit dem Sie Metal verbinden k√∂nnen, um ein ZStack-Rendering mit einer gro√üen Anzahl verschachtelter Ansichten, insbesondere Ansichten mit Verl√§ufen, an die GPU zu √ºbertragen, wei√ü nicht, wie ein √úbergang erfolgen soll. </font><font style="vertical-align: inherit;">Er versteht die von Ihnen beschriebene Animation von Erscheinung und Verschwinden nicht und ersetzt sie durch einige seiner eigenen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber wie verstecken wir die Statusleiste?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sehr einfach. SwiftUI hat den Modifikator .statisBar (versteckt :). Hier ist nur die API zum Steuern des √úbergangs f√ºr die Statusleiste, die SwiftUI nicht bereitstellt. Dazu m√ºssen wir die Funktionen von UIKit nutzen. Die SceneDelegate-Datei verwendet den UIHostingController, um die SwiftUI-Ansicht in einen UIKit ViewController zu verwandeln. In diesem Stadium ist es am bequemsten, einige globale UIKit-Funktionen zu verwenden, z. B. das Arbeiten mit der Statusleiste oder das Deaktivieren von Systemgesten, die dem Bildschirmrand zugeordnet sind (PreferredScreenEdgesDeferringSystemGestures). Sie k√∂nnen von UIHostingController erben, die Werte einiger Systemeigenschaften √ºberschreiben und diesen Nachkommen verwenden, um Ihre Ansicht an rootViewController zu √ºbergeben. Leider kann nur eine begrenzte Anzahl von √úberg√§ngen eine Statusleiste akzeptieren: .fade, .slide und .none. Der Standardwert ist Fade,und es passt hier am besten, also lassen wir es so wie es ist. Hoffen wir, dass diese Funktionalit√§t noch erweitert wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das Ausblenden und das Erscheinungsbild der Statusleiste mit der Bewegung der Welle zu synchronisieren, habe ich eine separate Ansicht erstellt, in der ich den Wert dieses Parameters mit einer Pause √§ndere:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarHider</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> isShown: <span class="hljs-type">Bool</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalIsShown = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">true</span>{
            <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="hljs-number">0.7</span>){
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">false</span>{
            <span class="hljs-type">DispatchQueue</span>.main.async(){
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-type">Spacer</span>()<font></font>
            .statusBar(hidden: internalIsShown)<font></font>
            .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0.3</span>))<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tats√§chlich wird hier ein einfacher Spacer () gebildet, den ich bereits ben√∂tigt habe, aber der StatusBar-Modifikator ist darauf gewickelt. Im Allgemeinen war es f√ºr Apple nat√ºrlich unlogisch, diese Funktionalit√§t an Modifikatoren auszugeben, wie z Dies gilt nicht f√ºr die spezifische Ansicht, die Sie √§ndern, hat aber anscheinend nicht herausgefunden, wie Sie es besser machen k√∂nnen. Viel interessanter ist eine andere. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es verwendet denselben schmutzigen Hack, den wir zuvor in Betracht gezogen haben: Innerhalb des K√∂rpers f√ºhre ich zur Laufzeit einige Aktionen aus, w√§hrend ich den Wert der </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variablen √§ndere. Die Logik ist insgesamt dieselbe, es gibt einen Strukturparameter, der von au√üen √ºbertragen wird, und eine </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variable, die nach einiger Zeit ge√§ndert wird, wodurch die Statusleiste verschwindet oder angezeigt wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall brauchte ich diesen Hack, da die Steuerung der Statusleistenanimation eine UIKit-Funktionalit√§t ist, die in SwiftUI noch ziemlich schlecht entwickelt ist. </font><font style="vertical-align: inherit;">Theoretisch w√ºrde ich die Animation f√ºr den verz√∂gerten Start mit dem Modifikator .statusBar (versteckt :) verschrauben, aber das funktioniert nicht. </font><font style="vertical-align: inherit;">Die Animation des Ausblendens und das Erscheinungsbild der Statusleiste sind korrigiert und k√∂nnen von SwiftUI nicht ge√§ndert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tats√§chlich hinderte mich nichts daran, dieselbe √Ñnderung asynchron mit der gew√ºnschten Verz√∂gerung vorzunehmen, nicht in dieser Ansicht, sondern in der √ºbergeordneten Ansicht, selbst wenn der Benutzer auf die Schaltfl√§che klickte. Lassen Sie uns dies jedoch als Denkmal f√ºr meine Versuche belassen, herauszufinden, was was ist (und ein weiterer Grund, dies zu sagen) dass dies nicht getan werden sollte).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wie wurde die Gr√∂√üe und Position der Statusleiste in @Environment eingef√ºgt?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
@Environment (nicht zu verwechseln mit @EnvironmentObject) ist ein Wrapper, der Zugriff auf eine feste Liste von Variablen bietet, die die Umgebung unserer Anwendung widerspiegeln. Zum Beispiel Bildschirmausrichtung oder Betriebssystemfarbthema. Mit demselben Wrapper kann Ihre Ansicht abonniert werden, um diese Parameter zu √§ndern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Liste kann erweitert werden. Ich dachte mir, dass es richtig w√§re, wenn @Environment Zugriff auf die Gr√∂√üe und Position der Statusleiste h√§tte. So habe ich es gemacht:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarFrame</span>: <span class="hljs-title">EnvironmentKey</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> defaultValue: <span class="hljs-type">CGRect</span> {
        <span class="hljs-type">CGRect</span>()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">EnvironmentValues</span> </span>{
    <span class="hljs-keyword">var</span> statusBarFrame: <span class="hljs-type">CGRect</span>{
        <span class="hljs-keyword">get</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>]<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>] = newValue<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe eine Struktur mit einem statischen Standardwert erstellt. </font><font style="vertical-align: inherit;">Anschlie√üend habe ich die SystemValues-Systemstruktur erweitert, indem ich meine eigene berechnete Eigenschaft hinzugef√ºgt habe, deren Getter und Setter sich auf den von mir erstellten Typ beziehen. </font><font style="vertical-align: inherit;">Der Typ wird hier verwendet, da EnvironmentValues ‚Äã‚Äãeinen Index implementiert, in den Sie den Typ √ºbergeben und den diesem Typ entsprechenden gespeicherten Wert abrufen. </font><font style="vertical-align: inherit;">Nicht der Wert dieses Typs, sondern der im bedingten W√∂rterbuch gespeicherte Wert, wobei der Typ selbst der Schl√ºssel ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf den Wert in @Environment wird mit keyPath \ .statusBarFrame zugegriffen. </font><font style="vertical-align: inherit;">So √ºbergeben Sie beispielsweise den Umgebungswert an alle Ansichten in der Hierarchie:</font></font><br>
<br>
<pre><code class="swift hljs">.environment(\.statusBarFrame, statusBarFrame) 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und in der Ansicht selbst, um den Wert aus dem Gesch√§ft abzurufen:</font></font><br>
<br>
<pre><code class="swift hljs">@<span class="hljs-type">Environment</span>(\.statusBarFrame) <span class="hljs-keyword">var</span> statusBarframe: <span class="hljs-type">CGRect</span> 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr die Arbeit mit der Statusleiste im UIWindowScene-Objekt in IOS 13 wurde √ºbrigens das Attribut statusBarManager angezeigt. </font><font style="vertical-align: inherit;">Daraus k√∂nnen einige Parameter abgeleitet werden. </font><font style="vertical-align: inherit;">Aber jetzt k√∂nnen Sie sie nicht verwalten. </font><font style="vertical-align: inherit;">Soweit ich wei√ü, war es fr√ºher m√∂glich, auf die ViewController-Statusleiste zuzugreifen und ihr eine Unteransicht hinzuzuf√ºgen. </font><font style="vertical-align: inherit;">Anscheinend war der Laden abgedeckt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen w√ºrde ich die Funktionalit√§t des Modifikators .statusBar (versteckt :) genau hier √ºbertragen, hier w√§re es f√ºr mich angemessener. </font><font style="vertical-align: inherit;">Ich denke, fr√ºher oder sp√§ter werden die Entwickler an diesen Punkt gelangen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, ich denke an diesem faszinierenden Beispiel kann ein Ausflug in die Animation mit SwiftUI-Tools als vollst√§ndig angesehen werden. Anhand einfacher Beispiele sprach ich √ºber die wichtigsten Animationswerkzeuge und erkl√§rte, wie genau sie unter der Haube funktionieren, wie sie verwendet werden sollten und warum genau. Anhand komplexerer Beispiele habe ich typische Schwierigkeiten aufgezeigt, auf die Sie sto√üen k√∂nnen, und M√∂glichkeiten, diese zu √ºberwinden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
War mein Code im Vergleich zum Beispiel aus dem obigen Artikel sauberer, klarer, k√ºrzer oder ist er m√∂glicherweise einfacher zu warten? Vielleicht nicht. Verbraucht es weniger Ressourcen? Ach nein. Vielleicht ist mein Ansatz universeller, aber das ist nicht richtig. Es gibt jedoch eine Aufgabe, die er definitiv besser erledigt. Es zeigt viel tiefer die Funktionsweise von SwiftUI unter der Haube. Mit ihm k√∂nnen Sie die Animation in die Regale in Ihrem Kopf stellen und sie frei in Ihren Anwendungen anwenden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftUI wird aktiv ges√§gt. </font><font style="vertical-align: inherit;">Selbst jetzt, zwei Wochen nach dem Schreiben des Codes f√ºr den ersten Artikel, sehe ich beim √úberpr√ºfen des Codes in der aktuellen Version von Xcode, wie einige Fehler, die ich umgehen musste, bereits behoben wurden. </font><font style="vertical-align: inherit;">Deshalb bin ich ein bisschen bei dem Artikel geblieben. </font><font style="vertical-align: inherit;">Etwas musste wegen Irrelevanz und alles andere geschnitten werden - um es noch einmal zu √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Und es gef√§llt. </font><font style="vertical-align: inherit;">SwiftUI ist definitiv die Zukunft der nativen iOS-Entwicklung, und es ist sehr informativ, an seinen Urspr√ºngen zu stehen und zu beobachten, wie es sich entwickelt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachwort</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Vorbereitung der Materialien f√ºr diesen Artikel habe ich auch viele Dinge in meinen Kopf gesteckt. </font><font style="vertical-align: inherit;">Ich fand viele Nuancen heraus, von denen ich keine Ahnung hatte, als ich gerade anfing, sie zu schreiben. </font><font style="vertical-align: inherit;">Daher fordere ich alle auf, die bereits Erfahrung in der SwiftUI-Entwicklung haben - seien Sie nicht sch√ºchtern, teilen Sie Ihre Erfahrungen und Ihr Wissen. </font><font style="vertical-align: inherit;">Dies ist sowohl f√ºr die Community als auch f√ºr die Vollst√§ndigkeit Ihres eigenen Wissens sehr n√ºtzlich. </font><font style="vertical-align: inherit;">Dies ist cooler als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Entleinmethode</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und es besteht auch die Notwendigkeit, die Antwort zu formulieren. </font><font style="vertical-align: inherit;">Die Hauptsache ist, nicht faul zu sein, nach einer solchen Antwort zu suchen, damit es den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jungen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht peinlich ist, sie </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">zu zeigen</font></a><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de506648/index.html">Laravel Digest (8.-14. Juni 2020)</a></li>
<li><a href="../de506658/index.html">GitLab 13.0 mit Gitaly-Clustern, epischer Hierarchie auf Roadmaps und automatischer Bereitstellung f√ºr ECS</a></li>
<li><a href="../de506662/index.html">Adaptive Aufteilung von Bezier-Kurven 2. und 3. Ordnung</a></li>
<li><a href="../de506664/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 419 (8.-14. Juni 2020)</a></li>
<li><a href="../de506666/index.html">ORM-Texturen, aber lohnt es sich?</a></li>
<li><a href="../de506676/index.html">Katar: Weltzentrum f√ºr Transplantationen und Nachtstadt</a></li>
<li><a href="../de506680/index.html">.NET Core vs Node.js. Argumente und Fakten</a></li>
<li><a href="../de506684/index.html">Wie ich dedic.ru auf Github-Seiten √ºbertragen habe und zufrieden war</a></li>
<li><a href="../de506686/index.html">Digitale Veranstaltungen in Moskau vom 15. bis 21. Juni</a></li>
<li><a href="../de506688/index.html">Digitale Veranstaltungen in St. Petersburg vom 15. bis 21. Juni</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>