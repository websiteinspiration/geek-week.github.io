<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✉️ 💆🏾 👦 SwiftUI in den Regalen: Animation, Teil 2 🐶 🗄️ 🍹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist der zweite Teil der Animationsgeschichte in SwiftUI. Im ersten Artikel haben wir uns einfache Beispiele für die Grundlagen der Funktionsweise...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SwiftUI in den Regalen: Animation, Teil 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506672/"><img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist der zweite Teil der Animationsgeschichte in SwiftUI. Im ersten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel haben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir uns einfache Beispiele für die Grundlagen der Funktionsweise von Animation in SwiftUI angesehen. In diesem Teil werden wir weiter gehen und das angekündigte Beispiel mit Regenbogenanimation detailliert analysieren. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter dem Schnitt finden Sie eine Analyse des Timings der Animation, die Erstellung eines eigenen Timing-Kurvenmechanismus für die Arbeit in einer linearen Schleifenanimation, Beispiele für die Implementierung verschiedener Verläufe und einige interessante Tricks, die Ihnen helfen, die Animation unter der Haube zu verstehen.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich möchte Sie daran erinnern, dass ich die Idee ausspioniert habe, eine solche Animation </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu implementieren </font><font style="vertical-align: inherit;">. Dort gingen die Autoren den Weg des geringsten Widerstands und implementierten den naheliegendsten Weg, um dieses Konzept durch Animieren der Form umzusetzen. Das Prinzip ist einfach: Jede Welle ist eine Kontur, die durch eine Bezier-Kurve umrissen wird, und der Parameter „Zeit“ beeinflusst die Position der rechten Grenze dieser Welle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht die fertige Animation aus: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7a7/cbf/7a0/7a7cbf7a05561123ceff4be47fff5ed6.gif" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus Gründen der Klarheit werde ich die Wellen ein wenig vertikal verteilen. Dies ist einfach, ich habe gerade am Ende von NotchWave hinzugefügt, dass die gesamte Kontur entsprechend der aktuellen Phase der Animation auf die Höhe der Welle verschoben wird:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">return</span> p.applying(.<span class="hljs-keyword">init</span>(translationX: <span class="hljs-number">0</span>, y: height * <span class="hljs-keyword">self</span>.phase))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gut und auch .drowingGroup () muss man nicht vergessen, die Verbindung zu trennen - das bedeutet nicht, dass das Bild über die Grenzen des festen Rahmens hinausgeht. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z3/zv/bi/z3zvbiseywno8t1fnt-i0ugcqgm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Ansatz ist einfach, er liefert das gewünschte Ergebnis ... aber er kam mir zu langweilig vor. </font><font style="vertical-align: inherit;">Mein Weg war viel länger und ich würde nicht sagen, dass das Endergebnis zumindest etwas besser wäre, aber es wäre auf dem Weg interessant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie die Prinzipien der Animationsarbeit in SwiftUI noch nicht genau kennen, empfehle ich dringend, den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorherigen Artikel zu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lesen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Und ich möchte mich mit dem Quellcode auf dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github befassen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbeiten Sie mit Farbverläufen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ganz am Anfang habe ich einen anderen Ansatz gewählt. Ich fand es viel nützlicher, mich mit der Animation der Verschiebung von Objekten zu befassen als mit der Animation der Formulare (ich nenne immer noch die Formstrukturform). Der Versatz kann mit allem funktionieren - mit verschiedenen Formen, Bildern und anderen Ansichten. Als pädagogische Aufgabe wollte ich einen reibungslosen Farbübergang von einer Welle zur anderen implementieren. Im ursprünglichen Konzept war so etwas so. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Insgesamt bietet SwiftIUI drei Verwendungsmöglichkeiten des Gradienten - linear, kreisförmig und eckig. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t7/o6/7d/t7o67dwcm_v5svufist7tfp0kwe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Code sieht dies wie eine Art Blockkonstruktor aus. Beachten Sie, wie die gesamte Welle segmentiert ist.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wa/af/el/waafeltt9cgiasfzxg1gjexwc8i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein linearer Gradient ist durch einen Start- und Endpunkt für den Gradienten gekennzeichnet. </font><font style="vertical-align: inherit;">Dies sind keine CGPoint-Punkte mit absoluten Koordinaten (x: y :), sondern UnitPoint-Punkte, d.h. </font><font style="vertical-align: inherit;">relative Koordinaten, wobei x: y: in Bruchteilen der Breite und Höhe des für diese Ansicht ausgewählten Bereichs angegeben werden. </font><font style="vertical-align: inherit;">Es gibt auch vordefinierte Punkte, die den Ecken (.topLeading, .bottomTrailing usw.) und den Mittelpunkten der Seiten (.top, .trailing usw.) entsprechen.</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-type">Rectangle</span>()<font></font>
    .fill(<span class="hljs-type">LinearGradient</span>(<font></font>
         gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
          startPoint: .leading,<font></font>
          endPoint: .trailing))<font></font>
    .frame(width: <span class="hljs-keyword">self</span>.gradientLength)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das lineare Gradientensegment ist "Gummi". </font><font style="vertical-align: inherit;">Es hat eine feste Breite, aber seine Höhe ist nicht angegeben. </font><font style="vertical-align: inherit;">Somit wird der gesamte bereitgestellte Betrag ausgefüllt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine etwas kompliziertere Geschichte mit einem kreisförmigen Farbverlauf. </font><font style="vertical-align: inherit;">Wir geben den Punkt an - den Mittelpunkt des Kreises, den Radius des Beginns des Verlaufs und den Radius des Endes des Verlaufs. </font><font style="vertical-align: inherit;">Die Radien sind bereits absolut, d.h. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Punkte</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Mittelpunkt des Kreises ist weiterhin als UnitPoint festgelegt.</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-type">Rectangle</span>()<font></font>
     .fill(<span class="hljs-type">RadialGradient</span>(<font></font>
          gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">0</span>),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">1</span>)]),<font></font>
          center: .bottomTrailing,<font></font>
          startRadius: <span class="hljs-keyword">self</span>.topRadius,<font></font>
          endRadius: <span class="hljs-keyword">self</span>.topRadius + <span class="hljs-keyword">self</span>.gradientLength)<font></font>
                )<font></font>
    .frame(height: <span class="hljs-keyword">self</span>.topRadius)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Stück mit einem oberen Kreis hat eine feste Höhe, erstreckt sich jedoch horizontal. Schließlich setzen wir bestimmte feste Radien in Punkten, sodass kein zusätzliches Streckrechteck der Grundfarbe aufgeklebt werden muss, wie dies bei einem linearen Farbverlauf der Fall ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am schwierigsten anzuwenden ist ein Winkelgradient. Sie ergibt sich aus dem Start- und Endwinkel sowie der Richtung. Wie Sie der Codeliste entnehmen können, ist das Arbeiten mit Ecken nicht sehr praktisch. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie müssen sich an den Schulkurs der Trigonometrie erinnern, um den erforderlichen Winkel zu berechnen, wenn Sie den Winkelgradienten an einem Punkt beginnen und an einem anderen beenden müssen.</font></font><br>
<br>
<pre><code class="swift hljs">       
<span class="hljs-type">Rectangle</span>()<font></font>
      .fill(<span class="hljs-type">AngularGradient</span>(<font></font>
            gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.angularGradientMiddleStop(blockWidth: geometry.size.width)),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
            center: .bottomLeading,<font></font>
            startAngle: <span class="hljs-keyword">self</span>.directionTo(gradientPart: <span class="hljs-keyword">self</span>.start, blockWidth: geometry.size.width),<font></font>
            endAngle: <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)))<font></font>
<font></font>
...<font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">directionTo</span><span class="hljs-params">(gradientPart: Color, blockWidth: CGFloat)</span></span> -&gt; <span class="hljs-type">Angle</span>{
        <span class="hljs-keyword">let</span> angleOf = gradientAngles(blockWidth: blockWidth)
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>.zero
        <span class="hljs-keyword">switch</span> gradientPart{
            <span class="hljs-keyword">case</span> start: angle = angleOf.start
            <span class="hljs-keyword">case</span> middle: angle = angleOf.middle
            <span class="hljs-keyword">case</span> end: angle = angleOf.end
            <span class="hljs-keyword">default</span>: <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"there is no gradient stop with that color: \(gradientPart)"</span>)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gradientAngles</span><span class="hljs-params">(blockWidth: CGFloat)</span></span> -&gt; (start: <span class="hljs-type">Angle</span>, middle: <span class="hljs-type">Angle</span>, end: <span class="hljs-type">Angle</span>){
        <span class="hljs-keyword">let</span> blockHeight = <span class="hljs-keyword">self</span>.bottomRadius
        <span class="hljs-keyword">let</span> center = <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: blockHeight)
        <span class="hljs-keyword">let</span> topRight = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength)
        <span class="hljs-keyword">let</span> topGradientStarts = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength * (<span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop))
        <span class="hljs-keyword">let</span> startAngle = center.radialDirection(to: topRight)
        <span class="hljs-keyword">let</span> middleAngle = center.radialDirection(to: topGradientStarts)
        <span class="hljs-keyword">let</span> endAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)
        <span class="hljs-keyword">return</span> (start: startAngle, middle: middleAngle, end: endAngle)<font></font>
    }<font></font>
<font></font>
...<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">CGPoint</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">radialDirection</span><span class="hljs-params">(to point: CGPoint)</span></span> -&gt; <span class="hljs-type">Angle</span>{
        <span class="hljs-keyword">let</span> deltaX =  point.x - <span class="hljs-keyword">self</span>.x
        <span class="hljs-keyword">let</span> deltaY =  point.y - <span class="hljs-keyword">self</span>.y
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)
        <span class="hljs-keyword">if</span> deltaX == <span class="hljs-number">0</span>{
            <span class="hljs-keyword">if</span> deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaY == <span class="hljs-number">0</span>{
            <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaX / -deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(-deltaX / deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Winkelgradient, der das Ende der Welle darstellt, ist ebenfalls aus Gummi, aber bereits breit - er nimmt die Hälfte der verbleibenden Größe ein. Deshalb gibt es so viel Trigonometrie. Ich kenne die Position bestimmter Punkte am Bildschirmrand, an denen eine bestimmte Farbe sein sollte (da ich einen kreisförmigen Farbverlauf mit einem eckigen klebe). Darüber hinaus hängen die Werte der Winkel nicht nur von den Radien des unteren Gradienten ab, sondern auch von der Breite des Blocks selbst mit dem Gradienten. Zum ersten Mal seit der Schule nahm ich einen Bleistift und erinnerte mich an die Algebra :)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle drei Optionen verwenden eine einzige Beschreibung der Farben innerhalb des Verlaufs. </font><font style="vertical-align: inherit;">Dies ist eine einfache Auflistung von Farben in einem Array. </font><font style="vertical-align: inherit;">Ihre Verteilung wird über ein bestimmtes Segment gleichmäßig sein. </font><font style="vertical-align: inherit;">Sie können die Verteilung mithilfe eines Arrays von Stop-Elementen verfeinern. </font><font style="vertical-align: inherit;">Tatsächlich ist dies die gleiche Aufzählung von Farben, nur für jede von ihnen wird auch die Koordinate auf einem einzelnen Segment angezeigt, in dem sie sich befinden wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So habe ich eine Welle mit ungefähr der gleichen Form wie im ursprünglichen Konzept erzeugt. </font><font style="vertical-align: inherit;">Der Übergang von einer Farbe zur anderen ist jetzt jedoch nicht scharf, sondern geglättet, was die Animation möglicherweise glatter machen sollte.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbe ist nicht das, was es scheint</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt einen Punkt in Bezug auf Farbe. </font><font style="vertical-align: inherit;">Um den Effekt einer rollenden Welle zu erzeugen, habe ich beschlossen, den Übergang zwischen Farben nicht ganz linear zu gestalten. </font><font style="vertical-align: inherit;">Wenn Sie genau hinschauen, werden Sie feststellen, dass der Farbverlauf am Rand selbst schärfer ist und je weiter er vom Rand entfernt ist, desto glatter fließt er in die Hauptfarbe. </font></font><br>
<img src="https://habrastorage.org/webt/hb/k-/f-/hbk-f-u1tcrri8furxdgeg8tx50.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies habe ich erreicht, indem ich die Zwischenfarbe berechnet und mit dieser Verteilung einen Farbverlauf erstellt habe:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anfangsfarbe - 0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zwischenfarbe - 0,3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Endfarbe - 1</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem trat bei der Berechnung des Durchschnitts zweier Farben auf. SwiftUI bedeutet, das Color-Objekt für Farbverläufe zu verwenden, und ich wurde verführt. Wenn Sie wie bei RGB-Objekten mit Farben arbeiten möchten, verwenden Sie zunächst UIColor in Ihrem Modell, da Color keinen direkten Zugriff auf Farben hat. Sie können es auch nicht einfach wieder in UIColor konvertieren. Die einzige </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(nicht)</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adäquate Lösung, die ich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gefunden </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">habe,</font></a><font style="vertical-align: inherit;"> besteht darin, die Spiegelreflexion mit einer Analyse der Zeichenfolgendarstellung zu erhalten. Solch ein Boilerplate, aber es gibt noch keine anderen Optionen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und das ist kein Fehler, keine Unterlassung. </font><font style="vertical-align: inherit;">Der Punkt ist, dass die SwiftUI im Color-Objekt die Funktionalität von UIColor nicht dupliziert. </font><font style="vertical-align: inherit;">Wenn Sie mit RGB-Kanälen arbeiten müssen, verwenden Sie diese. </font><font style="vertical-align: inherit;">Farbe in SwiftUI ist eine Ansicht mit einer Grundfarbe, deren spezifischer Wert je nach Position der Sterne am Himmel geringfügig variieren kann. Eine bestimmte RGB-Farbe wird nur zum Zeitpunkt des Zeichnens auf dem Bildschirm festgelegt. </font><font style="vertical-align: inherit;">Die Dokumentation sagt</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SwiftUI löst es nur in einen konkreten Wert auf, bevor es in einer bestimmten Umgebung verwendet wird.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber was ist mit Umgebung gemeint: Die Farbe der Wand hinter dem Rücken des Benutzers oder das iOS-Designthema ist nicht klar. </font><font style="vertical-align: inherit;">Wenn dies nicht zu Ihnen passt, verwenden Sie UIColor nativ.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endlose Animation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Animation wird durch den Modifikator .animation () angegeben und beginnt, nachdem View im Modifikator </font></font><code>.onAppear()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durch Ändern der </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variablen </font><font style="vertical-align: inherit;">initialisiert wurde </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Infolgedessen </font></font><code>.rotationEffect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abonniert </font><font style="vertical-align: inherit;">der Modifikator </font><font style="vertical-align: inherit;">den Empfang von animatableData im Intervall von "war" bis "wurde", was mit dem System-Timer übereinstimmt. </font><font style="vertical-align: inherit;">Wir haben im letzten Teil darüber gesprochen.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
       <span class="hljs-keyword">return</span> <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>))
            <span class="hljs-type">Spacer</span>()<font></font>
       }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/fl/dw/_0/fldw_0xguydvz5fe_-2tpcp3qkm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie endlose Animationen auf diese Weise ausführen, sollten Sie verstehen, dass jede spätere Änderung an animierten Modifikatoren diese "kaputt macht". </font><font style="vertical-align: inherit;">Wenn Sie beispielsweise nach dem Start aus irgendeinem Grund den Winkelwert auf 0 ändern, erhalten Sie folgenden Effekt:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ad/vi/iv/adviivgxhwuw0rwwv1itknh2kie.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum? Die Antwort liegt im Animationsmechanismus des Übergangs von einer Animation zur anderen. In unserem Beispiel haben wir beim ersten Erscheinen der Ansicht auf dem Bildschirm einen animierten Übergang von 0 nach 90 gestartet. In der Ansicht wird nur der Endwert 90 gespeichert, und der ursprüngliche Wert 0 wird nirgendwo gespeichert. Die Animations-Engine kennt die aktuelle Zeitposition der Animation und den aktuellen Wert von AnimatableData. Zum Zeitpunkt 0,5 ist es 45. Was passiert, wenn der Benutzer zu diesem Zeitpunkt den Wert auf 0 ändert? Antwort: Die Animation zum Ändern des Werts von 45 auf 0 beginnt. Alles ist noch in einer Schleife. Aber nur optisch ist der Kreislauf nicht geschlossen, sondern gebrochen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus gibt es Fälle, in denen die Animation auch "unterbrochen" wird, wenn Ihre Ansicht @ObservedObject oder andere Parameter verwendet, die dazu führen, dass die Ansicht erneut gerendert wird. Um dieses Problem zu lösen, verfügt der Modifikator .animation über den Parameter .animation (: value :). Wenn Sie den Wert dort übergeben, geben wir dem Renderer an, dass der Neustart der Animation nur erforderlich ist, wenn sich dieser Wert ändert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns jedoch herausfinden, wie Sie die Animation stoppen können, wenn wir sie nicht mehr benötigen. Dazu müssen Sie zwei Dinge angeben. Natürlich müssen wir SwiftUI mitteilen, dass die endlose Animation nicht mehr benötigt wird, und sie durch die übliche endgültige ersetzen. Das reicht aber nicht. Der Modifikator .animation () ist eine Anweisung, welche Timings verwendet werden sollen. Die Rotation selbst wird jedoch im Modifikator .rotationEffect () beschrieben und ist bereits abonniert, um neue Werte des Rotationswinkels per Timer zu erhalten. Um die Rotation zu stoppen, müssen wir auch ihren Wert ändern.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animation)<font></font>
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.angle == <span class="hljs-number">90</span>{
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">self</span>.animation = .<span class="hljs-keyword">default</span>
                }<span class="hljs-keyword">else</span>{
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span>
                    <span class="hljs-keyword">self</span>.animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/-o/-d/ui/-o-dui_0ep12qm5zwovo2iedvjm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach wie vor führte das Ändern des Winkelwerts zum Start einer neuen Animation (die fehlerhaft aussah). Diese Änderung wird ebenfalls animiert, jetzt jedoch mit den Timings der normalen Animation. Deshalb hört unser Quadrat nicht sofort auf, sich zu drehen, sondern wie mit einer Verlangsamung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dasselbe kann etwas prägnanter geschrieben werden, wenn Sie alle Funktionen für eine </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variable vom Typ Ein / Aus </font><font style="vertical-align: inherit;">aussetzen </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isStarted = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bis zu diesem Punkt war alles relativ einfach. Beachten Sie jedoch, dass alle Ereignisse hier in der Ansicht generiert werden. </font></font><code>.onAppear{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird vom System und </font></font><code>onTapGesture{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">natürlich vom Benutzer </font><font style="vertical-align: inherit;">aufgerufen </font><font style="vertical-align: inherit;">. Was ist jedoch, wenn Sie die gesamte Animation in einer Ansicht zusammenfassen und nur ein- und ausschalten möchten? SwiftUI impliziert nicht die Möglichkeit übergeordneter Methoden aus der übergeordneten Ansicht. Theoretisch können Sie die untergeordnete Ansicht als Struktur speichern und ihre Mutationsmethoden aufrufen, aber </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variablen der untergeordneten Ansicht können auf diese Weise nicht geändert werden. Ich habe es versucht - es funktioniert nicht. Die einzige Möglichkeit, so etwas zu tun, besteht darin, das PassthroughSubject des Kombinats zu verwenden, wie Sie es im Artikel getan haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Tat ist alles viel einfacher. Wenn klar in den Regalen im Kopf gelegt, das</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist der interne Status der Ansicht. Wenn Sie nicht versuchen, sie von außen zu manipulieren, ist die richtige Lösung sehr einfach:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButtonFromOutside</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> isStarted: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectParentView</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isOn = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">AnimatedRectStopButtonFromOutside</span>(isStarted: isOn)
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">self</span>.isOn.toggle()<font></font>
            }<font></font>
        }.onAppear(){<font></font>
            <span class="hljs-keyword">self</span>.isOn = <span class="hljs-literal">true</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall benötigen wir kein </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abonnement, um die Ansicht in der untergeordneten Ansicht zu aktualisieren. Sie wird bereits als Ganzes aktualisiert, wenn sich der externe Parameter ändert. </font><font style="vertical-align: inherit;">Manchmal ist es nicht bequem. </font><font style="vertical-align: inherit;">Manchmal möchten wir die untergeordnete Ansicht nicht erneut initialisieren - zum Beispiel, um die Animation nicht zu unterbrechen, oder in init () treten einige komplexe und ressourcenintensive Berechnungen (z. B. Abfragen) auf. </font><font style="vertical-align: inherit;">In diesen Fällen ist es besser, Objektentitäten zu verwenden, deren Änderungen mit dem Modifikator onReceive überwacht werden können.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status während der Ansichtsaktualisierung ändern</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt noch eine Sache, die es wert ist, behandelt zu werden. Wir haben nur mit zwei Werten von 0 und 90 Grad gearbeitet. Durch Ausschalten der Animation wird der Winkel auf 0 zurückgesetzt. Ist es jedoch möglich, die Animation in dem Moment anzuhalten, in dem wir auf die Schaltfläche geklickt haben, und sie an derselben Stelle erneut fortzusetzen, wenn Sie fortfahren? Schauen wir uns den Code an, der dies ermöglicht:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRect</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalStarted: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">let</span> externalStarted = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">init</span>(started externalStarted: <span class="hljs-type">Bool</span>){
        <span class="hljs-keyword">self</span>.externalStarted = externalStarted
        <span class="hljs-keyword">self</span>._internalStarted = <span class="hljs-type">State</span>(initialValue: !externalStarted)<span class="hljs-comment">//forse to start animation</span><font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-comment">//thats wrong. It just hiding a problem from SwiftUI not solving it</span>
        <span class="hljs-type">DispatchQueue</span>.main.async {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted == <span class="hljs-literal">false</span>{
                <span class="hljs-comment">// print("stop animation")</span>
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">false</span>
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted {
             <span class="hljs-comment">//    print("start animation")</span>
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">true</span>
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
       }<font></font>
         <font></font>
       <span class="hljs-keyword">return</span>  <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.red)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(internalStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/e9/ci/ge/e9cigegcoxid1l9skuw2qxle238.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hauptidee besteht darin, die Zeit zu Beginn der Animation zu verfolgen. Nach einiger Zeit, wenn es an uns liegt, die Animation zu stoppen, können wir überprüfen, wie viele vollständige Animationszyklen vergangen sind, und erraten, welchen Drehwinkel des Quadrats wir gerade sehen. Danach können wir </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Drehwinkelvariablen genau diesen Wert </font><font style="vertical-align: inherit;">zuweisen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit dieser Ansatz funktioniert, müssen wir den Anfang und das Ende der Animation verfolgen. Init () funktioniert nicht. Wir können nicht auf vorhandene </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter </font><font style="vertical-align: inherit;">zugreifen </font><font style="vertical-align: inherit;">, um die vorherige Startzeit der Animation abzurufen. Dies ist ein Token von </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variablen. In init können Sie nur den Anfangszustand dieser Variablen festlegen. Wenn jedoch am Ende der Initialisierung View bereits vor init () vorhanden war, wird der Wert der </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variablen wiederhergestellt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher wird hier der Parameter let externalStarted implementiert (den wir von außen steuern) und der interne Parameter </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var internalStarted, mit dem wir die Animation direkt steuern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es fehlte nur einer - ein Modifikator, der die Konformität überprüft und bei Bedarf aktualisiert, wie z. B. .onRecieve (), um nur mit jedem Rendering zu arbeiten. </font><font style="vertical-align: inherit;">Und dann dachte ich - schließlich wird der Körper für jede Zeichnung aufgerufen. Warum also nicht direkt darin einchecken? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellte sich heraus, dass SwiftUI sehr schwört, wenn die Ansicht während des Rendervorgangs den Wert der </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variablen </font><font style="vertical-align: inherit;">ändert, die sie </font><font style="vertical-align: inherit;">angibt</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie den Status während der Ansichtsaktualisierung ändern, führt dies zu undefiniertem Verhalten.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und blockiert eine solche Änderung. Dann machte ich einen schmutzigen Hack und benutzte DispatchQueue.main.async. Aber mal sehen, warum dies ein schmutziger Hack ist und warum dies niemals getan werden sollte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist eigentlich das Problem. Wenn wir in den Körper schreiben, ist eine offensichtliche Dummheit wie i + = 1, wo ich eine Art von ist</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel, dann erhalten wir eine Endlosschleife. Zum Zeitpunkt des Renderns machen wir die Ansicht im Speicher nicht relevant, da wir die Anfangsdaten für das Rendern geändert haben. Dies bedeutet, dass unsere Ansicht unmittelbar nach Abschluss des Renderns zum erneuten Rendern in die Warteschlange gestellt wird, aber selbst dann wird sie sofort wieder irrelevant. Wir schaffen mit unseren eigenen Händen einen endlosen Kreislauf. Ein asynchroner Aufruf ändert in diesem Fall nichts. Der Beginn der nächsten Runde wird nur geringfügig auf den Moment „unmittelbar nach dem Rendern“ verschoben. Ein asynchroner Aufruf löst das Problem also nicht, sondern verschleiert es nur und verhindert, dass SwiftUI uns mit der Nase stößt. Es ist wie in einem Auto, wenn die Glühbirne "Motor prüfen" abgerissen ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einerseits, was ist daran falsch? In jeder Programmiersprache gibt es unzählige Möglichkeiten, sich in den Fuß zu schießen, wenn Sie nicht verstehen, was Sie tun. Andererseits ist dieser Ansatz überhaupt nicht so, wie SwiftUI funktionieren sollte. Die Arbeit mit View zur Laufzeit ist schlecht. Ja, Sie können Ihre Fersen in die Brust schlagen und sicherstellen, dass Sie immer den richtigen Code schreiben, der niemals in einer Endlosschleife endet ... Aber es ist wie beim unsicheren Abrufen einer Option - dies ist nur eine schlechte Praxis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie gesagt, in solchen Fällen sollten Sie Combine verwenden und mit PassthroughSubject einen neuen Wert übergeben. Sie können jedoch mit dem üblichen ObservableObject auskommen, indem Sie das willChange-Ereignis abonnieren.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandlerTest</span>
    <span class="hljs-keyword">let</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandlerTest</span>){
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)<font></font>
       }.onReceive(animationHandler.objectWillChange){<font></font>
            <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted
            <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span>
                withAnimation(.<span class="hljs-keyword">none</span>){<span class="hljs-comment">//not working:(((</span>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
                }<font></font>
            }<span class="hljs-keyword">else</span> {
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
        }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span>
            <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der umstrittene Punkt hierbei ist die Verwendung der Werte des Objekts selbst im Abonnement der Benachrichtigung, dass das Objekt nur geändert wird. </font><font style="vertical-align: inherit;">Bisher habe ich in meinen Beispielen ein bereits modifiziertes Objekt. </font><font style="vertical-align: inherit;">Anscheinend kommen Benachrichtigungen mit einer gewissen Verzögerung. </font><font style="vertical-align: inherit;">Ich kann jedoch nicht garantieren, dass dies immer der Fall ist. Daher empfehle ich, entweder die selbst erstellten didChange-Benachrichtigungen oder PassthroughSubject zu verwenden und den neuen Wert zu übergeben.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wj/ou/nd/wjoundfihtxhnar7iucx7rrkvnm.gif"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animation Animationsänderungen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie auf dem GIF sehen können, stoppt die Animation nicht sofort. </font><font style="vertical-align: inherit;">Sie braucht etwas Zeit. </font><font style="vertical-align: inherit;">Dies liegt daran, dass wir beim Zuweisen eines Zwischenwerts zum Winkel auch eine bestimmte Animation verwenden - die Standardanimation.</font></font><br>
<br>
<pre><code class="swift hljs">.animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies führt zu ungewöhnlichem Verhalten. </font><font style="vertical-align: inherit;">Trotz der relativen Einfachheit von allem, was ich beschreibe, bleiben eine Reihe von Interaktionsnuancen unter der Haube, so dass das Bild immer glatt aussieht, auch wenn der nachlässige Programmierer nichts anzeigte. </font><font style="vertical-align: inherit;">Daher ist die Standardanimation Frühling. </font><font style="vertical-align: inherit;">Es eignet sich am besten zur Simulation der Gesetze der Physik. </font><font style="vertical-align: inherit;">Darüber hinaus ist dies eine ziemlich kurze Animation, etwa 0,2 Sekunden. </font><font style="vertical-align: inherit;">Wenn die Animation des Übergangs in einen neuen Zustand (der von uns berechnete und angegebene Winkel) keine Zeit hat, sich perfekt in die Standard-0,2 Sekunden einzufügen, um von der aktuellen Animationsgeschwindigkeit mit einer schönen Verlangsamung zu einem vollständigen Stopp zu wechseln, fügt SwiftUI selbst eine weitere Schleife endloser Animationen hinzu, die in der beschleunigten Version abgespielt werden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z0/b0/so/z0b0soljlzjqudxhek_irdxgyoy.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dies zu vermeiden, reicht es aus, die Standardanimation nicht zu verwenden. </font><font style="vertical-align: inherit;">Für das untere Quadrat habe ich die Rotationsstopp-Animation folgendermaßen deaktiviert:</font></font><br>
<br>
<pre><code class="swift hljs">                
.animation(animationHandler.isStarted ? animation : <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oder Sie können den erforderlichen Wert des Parameters zum Zeitpunkt des Stopps genauer berechnen. Dazu müssen Sie jedoch den aktuellen Moment der Animation nicht nur annähernd annehmen, sondern ihn auch genau kennen. </font><font style="vertical-align: inherit;">Ich werde unten zeigen, wie das geht.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bewegung mehrerer Wellen in einer Animation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zurück zur Regenbogenanimation. </font><font style="vertical-align: inherit;">Also, wir haben die Wellen selbst, lasst uns ihnen beibringen, sich zu bewegen. </font><font style="vertical-align: inherit;">Das erste, was ich tun möchte, ist eine endlose Animation auszuführen. </font><font style="vertical-align: inherit;">Ich habe mich dazu entschlossen: Ich werde eine </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variable haben, die für die aktuelle Position der Animation verantwortlich ist. </font><font style="vertical-align: inherit;">Im Zustand 0 befindet sich die erste Welle ganz am Anfang und die letzte ganz am Ende. </font><font style="vertical-align: inherit;">Die Wellen selbst überlappen sich. </font><font style="vertical-align: inherit;">Somit hängt die Länge des sichtbaren Teils jeder Welle von der Anzahl der Wellen ab. </font><font style="vertical-align: inherit;">Ich habe dies mit ZStack implementiert, in dem alle Wellen aufgelistet sind, und mit meinem eigenen Modifikator .wavePosition, in dem ich die aktuelle Position jeder Welle zum Zeitpunkt der Animation und die Reihenfolge ihrer Überlappung berechne.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">viel Code</font></font></b>
                        <div class="spoiler_text"><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpWavePosition</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">let</span> wave: <span class="hljs-type">WaveDescription</span>
    <span class="hljs-keyword">let</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    <span class="hljs-keyword">var</span> time: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> currentPosition: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> { time}
        <span class="hljs-keyword">set</span> {
                <span class="hljs-keyword">self</span>.time = newValue
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">init</span>(wave: <span class="hljs-type">WaveDescription</span>, time: <span class="hljs-type">CGFloat</span>, animationHandler: <span class="hljs-type">AnimationHandler</span>){
        <span class="hljs-keyword">self</span>.wave = wave
        <span class="hljs-keyword">self</span>.time = time
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-number">0</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(forWave: Int, ofWaves: Int, overTime: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{<font></font>
<font></font>
        <span class="hljs-keyword">let</span> time = overTime - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(overTime))
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(ofWaves)
        <span class="hljs-keyword">let</span> initialPosition = oneWaveWidth * <span class="hljs-type">CGFloat</span>(forWave)
        <span class="hljs-keyword">let</span> currentPosition = initialPosition + time
        <span class="hljs-keyword">let</span> fullRounds = <span class="hljs-type">Int</span>(currentPosition)
        <span class="hljs-keyword">var</span> result = currentPosition - <span class="hljs-type">CGFloat</span>(fullRounds)
        <span class="hljs-keyword">if</span> fullRounds &gt; <span class="hljs-number">0</span> &amp;&amp; result == <span class="hljs-number">0</span>{
            <span class="hljs-comment">// at the end of the round it should be 1, not 0</span>
            result = <span class="hljs-number">1</span><font></font>
        }<font></font>
 <span class="hljs-comment">//       print("wave \(forWave) in time \(overTime) was at position \(result)")</span>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(wave.totalWavesCount)
        <span class="hljs-keyword">var</span> thisIsFirstWave = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> currentPosition &lt; oneWaveWidth{<font></font>
            thisIsFirstWave = <span class="hljs-literal">true</span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span>
            <span class="hljs-type">Group</span>{<font></font>
                content<font></font>
                            .offset(x: -wave.width + currentPosition * (wave.width +  wave.gradientLength),<font></font>
                            <span class="hljs-comment">//to watch how waves move uncoment this</span>
                           <span class="hljs-comment">// y: CGFloat(self.waveInd * 20))</span>
                        y:<span class="hljs-number">0</span>)<font></font>
                    .zIndex(-<span class="hljs-type">Double</span>(currentPosition))<font></font>
                    .transition(.identity)<font></font>
                    .animation(<span class="hljs-literal">nil</span>)<font></font>
<font></font>
                <span class="hljs-keyword">if</span> thisIsFirstWave{<font></font>
                    content<font></font>
                        .offset(x: wave.gradientLength, y: <span class="hljs-number">0</span>)<font></font>
                        .zIndex(-<span class="hljs-number">2</span>)<font></font>
                        .transition(.identity)<font></font>
                        .animation(<span class="hljs-literal">nil</span>)<font></font>
                }<font></font>
            }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">positionOfSharp</span><span class="hljs-params">(wave: WaveDescription, inTime: CGFloat, animationHandler: AnimationHandler)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">SharpWavePosition</span>(wave: wave, time: inTime, animationHandler: animationHandler))<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpRainbowView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">let</span> waves: [<span class="hljs-type">SharpGradientBorder</span>]
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-comment">//@ObservedObject</span>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> rainbowPosition: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandler</span>,<font></font>
        backgroundColor: <span class="hljs-type">Color</span> = .clear<font></font>
    ){<font></font>
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">let</span> bottomRadius = animationHandler.waveGeometry.bottomRadius
        <span class="hljs-keyword">let</span> topRadius = animationHandler.waveGeometry.topRadius
        <span class="hljs-keyword">let</span> gradientLength = animationHandler.waveGeometry.gradientLength
        <span class="hljs-keyword">let</span> rainbowColors = animationHandler.rainbowColors
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">var</span> lastColor = rainbowColors.last <span class="hljs-keyword">else</span> {<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"no colors to display in rainbow"</span>)}
        <span class="hljs-keyword">var</span> allWaves = [<span class="hljs-type">SharpGradientBorder</span>]()
        <span class="hljs-keyword">for</span> color <span class="hljs-keyword">in</span> rainbowColors{
            <span class="hljs-keyword">let</span> view = <span class="hljs-type">SharpGradientBorder</span>(start: color,<font></font>
                                      end: lastColor,<font></font>
                                      bottomRadius: bottomRadius,<font></font>
                                      topRadius: topRadius,<font></font>
                                      gradientLength: gradientLength)<font></font>
            allWaves.append(view)<font></font>
            lastColor = color<font></font>
        }<font></font>
        <span class="hljs-keyword">self</span>.waves = allWaves<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span>
            <span class="hljs-type">VStack</span>{
                <span class="hljs-type">ZStack</span>{
                    <span class="hljs-type">ForEach</span>(<span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){ind <span class="hljs-keyword">in</span>
                        <span class="hljs-keyword">self</span>.waves[ind]<font></font>
                            .positionOfSharp(wave: <span class="hljs-type">WaveDescription</span>(ind: ind,<font></font>
                                                    totalWavesCount: <span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">count</span>,<font></font>
                                                    width: geometry.size.width,<font></font>
                                                    baseColor: <span class="hljs-keyword">self</span>.waves[ind].end,<font></font>
                                                    gradientLength: <span class="hljs-keyword">self</span>.waves[ind].bottomRadius + <span class="hljs-keyword">self</span>.waves[ind].topRadius),<font></font>
                                             inTime: <span class="hljs-keyword">self</span>.rainbowPosition,<font></font>
                                             animationHandler: <span class="hljs-keyword">self</span>.animationHandler)<font></font>
                            .animation(<span class="hljs-keyword">self</span>.animationHandler.isStarted ? <span class="hljs-keyword">self</span>.animation : .linear(duration: <span class="hljs-number">0</span>))<font></font>
                    }<font></font>
                }<font></font>
     <span class="hljs-comment">//           .clipped()</span><font></font>
            }<font></font>
<font></font>
        }<font></font>
        .onAppear(){<font></font>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.animationHandler.isStarted{
                <span class="hljs-keyword">self</span>.rainbowPosition = <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
        .onReceive(animationHandler.objectWillChange){<font></font>
             <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted
             <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{
                <span class="hljs-keyword">let</span> newPosition = <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"animated from \(self.rainbowPosition - 1) to \(self.rainbowPosition) stopped at \(newPosition)"</span>)
                    <span class="hljs-keyword">self</span>.rainbowPosition = newPosition<font></font>
             }<span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">self</span>.rainbowPosition += <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
 </code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Ansicht zum ersten Mal auf dem Bildschirm angezeigt wird, ändern wir den Status von 0 auf 1, wodurch die Wellen unter Berücksichtigung der deklarierten linearen Animation endlos über den Bildschirm laufen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/vr/ym/bgvrymyoubpekjmpgnsrtxxgco8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Rand der Welle den rechten Rand erreicht, befindet sich ihre nächste Position ganz am Anfang, jenseits des Bildschirmrandes. Es sieht so aus, als würde es einfach vom Ende der Welle verschwinden und das Hintergrundsubstrat freilegen, was wir vermeiden möchten. Zu diesem Zweck wurde der if {...} -Block im Modifikator in der body () -Funktion angezeigt, in der eine Kopie der ersten auf dem Bildschirm fehlenden Welle gezeichnet wird.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/si/6m/vt/si6mvtiimlv73kxy4c4imperxc4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass ich die geometrischen Eigenschaften jeder Welle in Form von Modifikatorparametern übertragen musste. </font><font style="vertical-align: inherit;">Das Problem war, dass ich den Z-Index jeder Welle basierend auf der aktuellen Animationsphase neu definieren musste. </font><font style="vertical-align: inherit;">Ich konnte die Breite des sichtbaren Bereichs mithilfe des GeometryReader {} -Modifikators im Inneren extrahieren. Ich war jedoch mit der Tatsache konfrontiert, dass er die Änderung der Reihenfolge der Überlagerung von Wellen blockiert. </font><font style="vertical-align: inherit;">Der Modifikator .zIndex () funktioniert nur im Kontext des ersten ZStack {} -Containers in der Ansichtshierarchie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GeometryReader unterbricht diese Verbindung und zIndex () funktioniert nicht mehr. </font><font style="vertical-align: inherit;">Wenn Sie bis zu diesem Zeitpunkt dachten, dass GeometryReader eine harmlose Möglichkeit ist, Daten über die Größe der aktuellen Ansicht abzurufen, ist dies nicht ganz richtig.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flow-Animation</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer wichtiger Punkt ist das Verständnis der Animation der integrierten Modifikatoren in Ihren eigenen Modifikatoren. Irgendwann nähert sich jede Welle dem Bildschirmrand, um den maximalen horizontalen Versatz zu erhalten, und geht dann zur Startposition, um den minimalen Versatz zu erhalten. Dies ist die gleiche Änderung wie jede andere und wird auch innerhalb der Animation animiert. Schließlich ist Animation nur eine sehr häufige Übertragung von Werten an den Modifikator, und sie wird auch mit der Animation ausgeführt, egal wie seltsam sie klingt. Es stellt sich heraus, dass wir innerhalb der Animation, wenn wir innerhalb dieses Modifikators einen neuen Wert übergeben, nur den Endpunkt der aktuellen Bewegungsanimation ändern. Es stellt sich heraus, dass sich jede Welle, die den Rand des Bildschirms erreicht, umdreht und zurückschwebt. Aber es erreicht auch nicht den Start, sondern holt früher oder später die erforderliche Position ein.und bewegt sich dann wieder von links nach rechts.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/aj/xp/ky/ajxpkyp6nxn-e6ixzzrv7y-g-c4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können dieses Problem lösen, indem Sie den Modifikator .animation (nil) einfügen. Daher deaktiviere ich die Animation aller oben im Text angewendeten Modifikatoren. Dies ist die allgemeine Logik der Arbeit eines Modifikators: Sie ändert, was sich auf seiner Eingabe befindet, und auf der Eingabe haben wir das Ergebnis aller vorherigen Modifikatoren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Generell funktioniert hier eine ganze Hierarchie verschiedener Animationen. Die Standardeinstellung wird verwendet, um Änderungen an allen Modifikatoren anzuzeigen, sofern Sie für Ihre Ansicht nichts anderes angeben. Wir haben einen Ausführungsthread (sagen wir, dies ist der Hauptstrang), in dem der Körper aufgerufen wird. Wir gehen davon aus, dass es den Parameter .animation hat, der jedes Mal überprüft wird, wenn ein Modifikator einen neuen Wert erhält. Wenn der Modifikator Animation unterstützt (entspricht dem AnimatableModifier-Protokoll) und die Animation für den Stream aktiviert ist (eine bestimmte Animation wird verwendet, nicht .none oder nil), wird die Änderung animiert. Dies ist, was wir tun, indem wir einen Code zum Ändern von </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parametern in den withAnimation {} -Block einschließen - wir schreiben eine bestimmte Animation im aktuellen Thread vor und nehmen dann eine Art Änderung vor</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variable. In diesem Fall ist dies mit Animation {} eine Art Transaktionsäquivalent, und alle an dieser Transaktion vorgenommenen Änderungen werden animiert. Infolgedessen beginnt innerhalb desselben Streams ein Zyklus der Übersetzung dieser Änderungen in alle abhängigen Ansichten. Die Modifikatoren dieser Ansicht erhalten einen neuen Wert und abonnieren, um Zwischenwerte von AnimatableData zu erhalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus gibt es Elemente in der Animation, auf die Sie keinen Einfluss haben. Zum Beispiel wird die Position des Schiebereglers durch interne Mechanismen von selbst animiert, und es ist nichts dagegen zu tun.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit WithAnimation () können Sie daher die Standardanimation für die ausgeführte Aktion starten. Für bestimmte Ansichten können Sie jedoch mithilfe des Modifikators .animation () explizit Ihre eigene Animation angeben. In diesem Fall erhalten die Modifikatoren und Formulare, aus denen der an .animation () übergebene Inhalt besteht (alles, was im Code aufgeführt ist, bevor .animation () angewendet wird), das von Ihnen beschriebene Timing und ignorieren die Stream-Animation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In meinem WavePosition-Modifikator verwende ich .animation (nil), um die integrierte Offset-Animation zu entfernen, und weise mich an, die aktuelle Stream-Animation zu ignorieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die gleiche Geschichte mit der Endkappe. Ich möchte Sie an die Schlussfolgerungen aus dem letzten Artikel erinnern. Tatsächlich haben wir N WavePosition-Modifikatorstrukturen in unserem Speicher, eine für jede Welle. Und alle erhalten einen neuen Positionswert vom System-Timer, der die Position jeder Welle zu einem bestimmten Zeitpunkt berechnet. Dies bedeutet, dass wir auch N Endkappen für jede Welle haben. Es ist nur so, dass dank des if {} -Blocks immer nur einer von ihnen angezeigt wird. Der gleiche Block legt uns jedoch ein Schwein. Das Verschwinden und Erscheinen der Ansicht wird auch mit der Animation des Streams ausgeführt. Dies bedeutet, dass der Modifikator .transition verwendet wird, um das Erscheinen und Verschwinden der Ansicht nach dem Ändern der Bedingung zu animieren. Normalerweise wird standardmäßig .opacity verwendet, aus irgendeinem Grund wurde jedoch stattdessen .slide für mich verwendet. Keiner passt zu mir, also habe ich diese Animation gerade abgesagt.mit .transition (.identity).</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">upd. </font><font style="vertical-align: inherit;">Während ich den Artikel vorbereitete, kam Xcode 11.4 heraus, in dem anscheinend der Übergang standardmäßig überarbeitet wurde. </font><font style="vertical-align: inherit;">Zumindest habe ich jetzt .transition (.identity) ohne Probleme auskommentiert und das Problem, das mich veranlasst hat, es hinzuzufügen, nicht erhalten.</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animationszeiten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt kommen wir endlich zu der interessantesten Frage: Wie können sich die Wellen beschleunigen? </font><font style="vertical-align: inherit;">Wie immer komme ich von weit her.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich ist Animation eine Beschreibung der Geschwindigkeit einer bestimmten Animation. Wir können die Route von Punkt A nach Punkt B innerhalb des Modifikators selbst bestimmen, aber SwiftUI entscheidet, wann und welche Art von AnimatableData-Wert an ihn übergeben werden soll. Er macht das mit einer Zeitkurve. Angenommen, wir nehmen Punkt A als Ursprung und markieren Punkt B als Punkt mit Koordinaten (1; 1). Horizontal markieren wir die verstrichene Zeit (die Bewegung von Punkt A nach Punkt B dauert genau 1 Zeiteinheit). Vertikal - Die zurückgelegte Strecke in Bruchteilen einer Einheit. Bei Verwendung der linearen Animation erhalten wir direkt. Wenn wir die Bewegung ein wenig ähnlich wie in der Gegenwart machen wollen, müssen wir zuerst ein wenig Zeit für das Beschleunigen und am Ende für das Bremsen aufwenden. Genau </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können mit verschiedenen Optionen herumspielen, indem Sie Ihre eigene Kurve zeichnen und ihre Bewegungsanimation mit den Standardanimationen vergleichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In SwiftUI werden Bezier-Kurven für verschiedene Arten von Animationen verwendet. </font><font style="vertical-align: inherit;">In jedem Fall sollte es bei (0; 0) beginnen und bei (1; 1) enden. </font><font style="vertical-align: inherit;">Die Krümmung der Linie wird durch die Kontrollpunkte bestimmt.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschachtelte Zeitkurve in linearer endloser Animation</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was müssen wir also tun, um die beschleunigte Bewegung jeder Welle (easyIn) innerhalb einer linearen Schleifenanimation zu erreichen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die aufgeschlüsseltste Option, die ich finden konnte, war, meine eigene Zeitkurve zu implementieren und den linearen Zeitfluss damit in eine Art .easeIn umzuwandeln. </font><font style="vertical-align: inherit;">Mit diesem Beispiel können Sie sehr gut verstehen, wie dies funktioniert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee ist einfach. Wir werden unsere eigene Klasse basierend auf dem Pfad erstellen - der Bezier-Kurve, mit der wir den Abstand von Punkt A zu Punkt B bestimmen, der zu jedem bestimmten Zeitpunkt angezeigt werden muss. Genau so funktioniert Animation in SwiftUI und in jedem anderen Framework mit ähnlichen Funktionen. Mithilfe einer Zeitkurve werden echte Sekunden und Millisekunden (die jedoch meistens linear fließen) in Bruchteile der Entfernung umgewandelt (genauer gesagt Bruchteile des animierten Segments - der AnimatableData-Vektor, der die vorgenommene Änderung darstellt). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist meine erste Implementierung:</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getActualPosition</span><span class="hljs-params">(of position: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-keyword">let</span> correctPosition = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">min</span>(position, <span class="hljs-number">1</span>), <span class="hljs-number">0</span>) / duration
        <span class="hljs-keyword">let</span> trimmingCurve = <span class="hljs-type">TimingCurve</span>.superEaseInPath
        <span class="hljs-keyword">if</span> correctPosition &lt; <span class="hljs-number">0.0000001</span>{
            <span class="hljs-keyword">let</span> reversedCurve = <span class="hljs-type">Path</span>(<span class="hljs-type">UIBezierPath</span>(cgPath: trimmingCurve.cgPath).reversing().cgPath)
            <span class="hljs-comment">//trim to start point is impossible, so reverce the curve and get last point</span>
            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = reversedCurve.currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve start point"</span>)}
            <span class="hljs-keyword">return</span> point.y<font></font>
        }<font></font>
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = trimmingCurve.trimmedPath(from: <span class="hljs-number">0</span>, to: correctPosition).currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve point at \(position)"</span>)}
        <span class="hljs-keyword">return</span> point.y * <span class="hljs-keyword">self</span>.duration<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anscheinend war ich ein bisschen dumm. Per Definition muss ich einen Punkt auf der Kurve finden, der dem angegebenen Wert von X entspricht, und ihn an Y zurückgeben. Ich konnte keine integrierte Standardmethode zur Lösung dieses Problems oder ein beliebtes Muster finden, daher habe ich beschlossen, die vorhandene Trimmmethode für diese Zwecke anzupassen ( ) Ich entschied, dass ich den Ansatz sehr gut überdenken und den gewünschten Punkt erhalten könnte, indem ich den Teil des Pfades erhalte, der dem Bruchteil der zurückgelegten Strecke entspricht. Für Null gibt diese Methode 0 zurück, für 1 gibt sie 1 zurück. In der Mitte ist wahrscheinlich auch alles ungefähr korrekt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mir war bewusst, dass ein solcher Ansatz kein sehr genaues Ergebnis liefern würde. Die Schwere des Problems trat jedoch später auf, als ich versuchte, genau dieselbe Animation auf standardmäßige Weise zu reproduzieren. Ich war überrascht, wie unterschiedlich es ist, und entschied mich, in der Grafik zu überprüfen, wie weit die auf diese Weise erhaltenen Punkte von der ursprünglichen Kurve entfernt sind. Das Ergebnis hat mir nicht gefallen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fl/ed/s-/fleds-cdj4f8ellnui32gn-kiyk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Punkte sind nicht nur weit von der gewünschten Kurve entfernt, sondern die Art der Kurve ist auch verzerrt. Es gibt einen zusätzlichen Knick, den ich überhaupt nicht brauche. Infolgedessen musste ich immer noch einen relativ genauen Weg finden, um einen Punkt auf einer Bezier-Kurve zu finden, wobei ich nur eine Koordinate kannte:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich musste viele Segmente im Speicher speichern, deren Enden auf einer bestimmten Kurve liegen. Eine Suche nach Y durch ein gegebenes X mit diesem Ansatz ist eine Suche nach dem entsprechenden Segment, dessen Aufteilung gegebenenfalls in zwei Hälften, bis eine der Grenzen eines solchen Segments ausreichend nahe am gewünschten Punkt liegt. In diesem Fall finden wir den Punkt mit der erforderlichen X-Koordinate auf diesem Segment und geben ihn Y zurück. Wenn Sie einfachere Methoden kennen, um einen Punkt auf einer beliebigen Bezier-Kurve mit einer bestimmten Koordinate zu finden, schreiben Sie in die Kommentare. Ich denke, es kann für viele nützlich sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen liegen die Punkte ziemlich nahe am Diagramm:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/bk/qi/wxbkqitda0fmf516tl1vjarqgoq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe ein Singlton-Objekt erstellt, um eine Zeitkurve für Kontrollpunkte zu erstellen und das Array von Segmenten zwischenzuspeichern, mit denen Y gesucht wird. Um einen bestimmten Punkt auf der Kurve zu finden, muss ich nur das Segment finden, in dem dieser Punkt liegt, und es in zwei Hälften teilen bis eines der Enden des Segments nahe genug an diesem Punkt liegt, um in den gegebenen Fehler zu fallen, und dann den Wert von Y entlang des gegebenen X linear interpolieren und einen Teil der Kurve durch dieses Segment ersetzen. Ich behaupte nicht, dass dies der beste Weg ist und dass es in allen Fällen funktionieren wird. Schreiben Sie erneut in die Kommentare, wenn Sie bessere Möglichkeiten kennen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Hilfe eines solchen Werkzeugs wird die Umwandlung von linearen Animationen in nichtlineare einfach. </font><font style="vertical-align: inherit;">Alles, was benötigt wird, ist, die Kurve durch zwei Kontrollpunkte zu beschreiben und die Position auf dem Segment gemäß dieser Kurve neu zu berechnen. </font><font style="vertical-align: inherit;">Wenn eine Animation unterschiedlicher Dauer erforderlich ist, verwenden wir weiterhin eine Einheitskurve mit dem entsprechenden Koeffizienten für die X-Koordinate.</font></font><br>
<br>
<pre><code class="swift hljs">        
<span class="hljs-keyword">self</span>.timing = <span class="hljs-type">TimingCurve</span>.superEaseIn(duration: <span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> animatedPosition = timing.getY(onX: currentPosition)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht die Animation zusammen mit unserer Timing-Kurve aus: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vf/f0/fe/vff0fe07bgvlvqhhuok5vy_w8ga.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Den vollständigen Code finden Sie im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der TimingCurveView-Datei. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie dieses Beispiel verstanden haben, werden Sie zu 100% verstehen, wie die Animationszeiten angeordnet sind. </font><font style="vertical-align: inherit;">Übrigens können Sie dieses Wissen nutzen, da Sie mit SwiftUI mithilfe der Funktion timingCurve () eine eigene Timing-Kurve für Kontrollpunkte erstellen und wie jede andere Animation verwenden können.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überleitung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt haben wir eine erträgliche endlose Animation. Es bleibt nur herauszufinden, wie es ein- und ausgeschaltet werden soll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee, das Erscheinungsbild zu animieren, besteht darin, den Animationsblock nur an der bereits eingeschalteten Stelle erscheinen zu lassen, aber der Vorhang wird wie ein Vorhang im Theater zurückgezogen. Wenn wir die Geschwindigkeit des Vorhangs mit der Geschwindigkeit der Wellen innerhalb der Animation synchronisieren und im Vorhang selbst einen Farbverlauf von der Hintergrundfarbe zur Farbe der aktuell einfallenden Welle erzeugen, erhalten wir einen visuellen Effekt, als wäre dieser Vorhang die erste rollende Welle. Um die Bewegungsgeschwindigkeit zu synchronisieren, verwenden wir einfach dieselbe TimingCurve wie zum Animieren der Bewegung der Welle. Zum Glück wissen wir jetzt, wie das geht.</font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.timingCurve(<span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.x),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.y),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.x),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.y),<font></font>
                                duration: <span class="hljs-number">1</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Animation.timingCurve (x: y :) können Sie Ihr eigenes Animations-Timing basierend auf den Kontrollpunkten von Bezier-Kurven festlegen. </font><font style="vertical-align: inherit;">Am Ausgang erhalten wir ein vollwertiges Animationsobjekt wie das bekannte .linear (Dauer: 1), das ohne Einschränkungen verwendet werden kann. </font><font style="vertical-align: inherit;">Und wenn ich bedenke, dass ich genau die gleichen Kontrollpunkte für die Wellenanimation verwende, ist die Animation synchron.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es wäre bequemer, den Code zu organisieren ...</font></font></b>
                        <div class="spoiler_text">   .<br>
<br>
 ,           ,    ,          …     ,     ,     .  -  ,        —    .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Deaktivieren der Animation kann auf die gleiche Weise erfolgen. Es sollte nur der Vorhang auf den Animationsblock kriechen und ihn allmählich schließen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste Problem trat in dem Moment auf, als ich den aktuellen Status der Animation abrufen musste, um die Farbe des Vorhangs zu wählen. </font><font style="vertical-align: inherit;">Zu diesem Zweck habe ich ein ObservableObject erstellt, das ich im Modifikator übergebe und das ich im AnimatableData-Setter ändere. </font><font style="vertical-align: inherit;">Es ist wichtig zu verstehen, dass das 60-malige Ändern der @Published-Eigenschaft pro Sekunde überhaupt nicht das ist, was Sie benötigen. </font><font style="vertical-align: inherit;">So ändern Sie </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variablen innerhalb eines Bodyblocks. </font><font style="vertical-align: inherit;">Wir müssen nichts initiieren, wenn sich der Status der Animation ändert. </font><font style="vertical-align: inherit;">Wenn nötig, können wir den Status der Animation jederzeit herausfinden.</font></font><br>
<br>
<pre><code class="swift hljs">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> { time}
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">if</span> animationHandler.isStarted{
                <span class="hljs-keyword">self</span>.time = newValue
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.time != <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition{
                    <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition = <span class="hljs-keyword">self</span>.time<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)
            <span class="hljs-keyword">if</span> currentPosition &lt; <span class="hljs-number">0.01</span>{<font></font>
                animationHandler.currentWaveBaseColor = wave.baseColor<font></font>
            }<font></font>
        }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus diesem Grund habe ich SharpRainbowView nicht angemeldet, um Änderungen an AnimationHendler zu verfolgen: </font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-comment">//@ObservedObject</span>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Funktionsweise dieser Vorhänge zu veranschaulichen, schalte ich die Anzeige der Vorgänge außerhalb der Ansicht ein, indem ich .clipped () auskommentiere. Außerdem werde ich den Vorhang aus Gründen der Übersichtlichkeit leicht über die Animation bewegen. Jetzt ist es klarer, nicht wahr? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/uf/0k/6suf0klfghhgxj95qfnrxd29zpe.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Vorhänge mussten kurz sein, damit der von jeder Welle und jedem Vorhang zurückgelegte Weg zusammenfiel (andernfalls würde sich eine asynchrone Animation ergeben), aber gleichzeitig gelang es ihr, vollständig vom Bildschirm zu verschwinden. Gleichzeitig ist der Vorhang als Farbverlauf in drei Farben angeordnet. Dies ist am schließenden Vorhang deutlich sichtbar. Das liegt an den langen Schwänzen, die mir am Anfang so gut gefallen haben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Sache ist, dass die erste Welle der Gradient der letzten und ersten Farbe des übertragenen Arrays ist. Keiner von ihnen darf mit der Hintergrundfarbe übereinstimmen. Daher bestand im Allgemeinen ein Bedarf an Vorhängen. Um den Vorhang zweifarbig zu machen, von der Hintergrundfarbe bis zur Grundfarbe der ersten Welle, hat mich die Länge des Vorhangs daran gehindert. Es überlappt einfach nicht den langen Schwanz der ersten Welle, und es wird ein Rand einer Farbe und der Schwanz einer anderen erhalten. Deshalb musste ich den Vorhang dreifarbig machen - zuerst vom Hintergrund bis zur Farbe der letzten Welle und dann von der Farbe der letzten Welle bis zur ersten. Dann passt der Schwanz der ersten Welle gut zum Rand des Vorhangs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus ungefähr den gleichen Gründen machten sie den schließenden Vorhang auch dreifarbig. Ansonsten sah die Grenze unnatürlich aus. Infolgedessen stellte sich heraus, dass die erste „Welle“ (und jetzt wissen wir, dass dies tatsächlich der in Transition.truncate beschriebene Vorhang ist) kurz war. Und obwohl es sich vollständig synchron mit der ersten Welle bewegt, d.h. beschleunigt und nicht linear ändert sich seine Breite nicht mit der Zeit, obwohl die Breite nachfolgender Wellen visuell zunimmt. Dies kann durch dynamisches Ändern der Breite des Vorhangs besiegt werden, aber ich war ehrlich gesagt faul. Betrachten wir dies als Hausaufgabe für diejenigen, die in diese Mechanismen eintauchen und einen Code rauchen möchten (ich entschuldige mich im Voraus bei solchen Leuten, es gibt viele Spuren meiner Experimente, die Sie verwirren können).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt ein Problem. </font><font style="vertical-align: inherit;">Wenn Sie die Taste zu einem erfolglosen Zeitpunkt drücken, deckt der schließende Vorhang die nächste Welle kaum ab. </font><font style="vertical-align: inherit;">Es sieht nicht sehr gut aus. </font><font style="vertical-align: inherit;">Sie können das Problem lösen, indem Sie das Ausblenden der Ansicht mit Animation geringfügig verzögern. </font><font style="vertical-align: inherit;">Wir haben eine Möglichkeit, die aktuelle Position der Animation herauszufinden. Wir müssen nur den Beginn des Übergangs ein wenig verschieben, und die letzte Welle wird immer vollständig angezeigt.</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle animation"</span>).onTapGesture {<font></font>
                withAnimation(){<font></font>
                    <span class="hljs-keyword">var</span> delay: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.isShown{
                        <span class="hljs-keyword">let</span> waveChangeTime: <span class="hljs-type">Double</span> = <span class="hljs-type">Double</span>(<span class="hljs-number">1</span>) /  <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.rainbowColors.<span class="hljs-built_in">count</span>)
                        <span class="hljs-keyword">let</span> currentTime = <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition)
                        <span class="hljs-keyword">let</span> wavesPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(currentTime / waveChangeTime))<font></font>
                        delay =  (wavesPassed + <span class="hljs-number">1</span>) * waveChangeTime - currentTime<font></font>
                        delay = <span class="hljs-built_in">max</span>(delay - <span class="hljs-number">0.05</span>, <span class="hljs-number">0</span>)
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">"currentTime: \(currentTime); delay \(delay)"</span>)<font></font>
                    }<font></font>
                    <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + delay) {
                        <span class="hljs-keyword">self</span>.isShown.toggle()<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich können Sie den Vorhang auch auf eine variable Breite einstellen, um die Illusion unterschiedlicher Geschwindigkeiten der Grenze zwischen Hintergrund und Vorhang sowie zwischen Vorhang und erster Welle zu erzeugen, aber jetzt sieht die erste Welle etwas unnatürlich aus, aber ich bin bereits zu faul, um mich darum zu kümmern.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transition liebt es, ein Schwein zu füttern</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen sind Animationen von Erscheinung und Verschwinden für mich ein sehr cooles Werkzeug. Es scheint jedoch, dass dieses Konzept neu ist und nicht alle Tools normalerweise damit umgehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Modifikator .rotation3DEffect () invertiert die Ansicht mit einigen komplexen Animationen recht erfolgreich, weiß jedoch nicht, wie .transition invertiert werden soll. Es war so enttäuschend, einen präzisen Code zu schreiben, zu sehen, wie sich Ihre Wellen von der Mitte des Bildschirms wegstreuen, und dann zu sehen, dass auf der linken Seite die Vorhänge von links nach rechts verlaufen. Ich musste ein paar Boilerplates schreiben, damit der Übergangsmodifikator in beide Richtungen funktionieren konnte.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pn/3c/fg/pn3cfg8f6zsersnfgdv5_ixrqu8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Modifikator drowingGroup (), mit dem Sie Metal verbinden können, um ein ZStack-Rendering mit einer großen Anzahl verschachtelter Ansichten, insbesondere Ansichten mit Verläufen, an die GPU zu übertragen, weiß nicht, wie ein Übergang erfolgen soll. </font><font style="vertical-align: inherit;">Er versteht die von Ihnen beschriebene Animation von Erscheinung und Verschwinden nicht und ersetzt sie durch einige seiner eigenen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber wie verstecken wir die Statusleiste?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sehr einfach. SwiftUI hat den Modifikator .statisBar (versteckt :). Hier ist nur die API zum Steuern des Übergangs für die Statusleiste, die SwiftUI nicht bereitstellt. Dazu müssen wir die Funktionen von UIKit nutzen. Die SceneDelegate-Datei verwendet den UIHostingController, um die SwiftUI-Ansicht in einen UIKit ViewController zu verwandeln. In diesem Stadium ist es am bequemsten, einige globale UIKit-Funktionen zu verwenden, z. B. das Arbeiten mit der Statusleiste oder das Deaktivieren von Systemgesten, die dem Bildschirmrand zugeordnet sind (PreferredScreenEdgesDeferringSystemGestures). Sie können von UIHostingController erben, die Werte einiger Systemeigenschaften überschreiben und diesen Nachkommen verwenden, um Ihre Ansicht an rootViewController zu übergeben. Leider kann nur eine begrenzte Anzahl von Übergängen eine Statusleiste akzeptieren: .fade, .slide und .none. Der Standardwert ist Fade,und es passt hier am besten, also lassen wir es so wie es ist. Hoffen wir, dass diese Funktionalität noch erweitert wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das Ausblenden und das Erscheinungsbild der Statusleiste mit der Bewegung der Welle zu synchronisieren, habe ich eine separate Ansicht erstellt, in der ich den Wert dieses Parameters mit einer Pause ändere:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarHider</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> isShown: <span class="hljs-type">Bool</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalIsShown = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">true</span>{
            <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="hljs-number">0.7</span>){
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">false</span>{
            <span class="hljs-type">DispatchQueue</span>.main.async(){
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-type">Spacer</span>()<font></font>
            .statusBar(hidden: internalIsShown)<font></font>
            .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0.3</span>))<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich wird hier ein einfacher Spacer () gebildet, den ich bereits benötigt habe, aber der StatusBar-Modifikator ist darauf gewickelt. Im Allgemeinen war es für Apple natürlich unlogisch, diese Funktionalität an Modifikatoren auszugeben, wie z Dies gilt nicht für die spezifische Ansicht, die Sie ändern, hat aber anscheinend nicht herausgefunden, wie Sie es besser machen können. Viel interessanter ist eine andere. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es verwendet denselben schmutzigen Hack, den wir zuvor in Betracht gezogen haben: Innerhalb des Körpers führe ich zur Laufzeit einige Aktionen aus, während ich den Wert der </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variablen ändere. Die Logik ist insgesamt dieselbe, es gibt einen Strukturparameter, der von außen übertragen wird, und eine </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variable, die nach einiger Zeit geändert wird, wodurch die Statusleiste verschwindet oder angezeigt wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall brauchte ich diesen Hack, da die Steuerung der Statusleistenanimation eine UIKit-Funktionalität ist, die in SwiftUI noch ziemlich schlecht entwickelt ist. </font><font style="vertical-align: inherit;">Theoretisch würde ich die Animation für den verzögerten Start mit dem Modifikator .statusBar (versteckt :) verschrauben, aber das funktioniert nicht. </font><font style="vertical-align: inherit;">Die Animation des Ausblendens und das Erscheinungsbild der Statusleiste sind korrigiert und können von SwiftUI nicht geändert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich hinderte mich nichts daran, dieselbe Änderung asynchron mit der gewünschten Verzögerung vorzunehmen, nicht in dieser Ansicht, sondern in der übergeordneten Ansicht, selbst wenn der Benutzer auf die Schaltfläche klickte. Lassen Sie uns dies jedoch als Denkmal für meine Versuche belassen, herauszufinden, was was ist (und ein weiterer Grund, dies zu sagen) dass dies nicht getan werden sollte).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wie wurde die Größe und Position der Statusleiste in @Environment eingefügt?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
@Environment (nicht zu verwechseln mit @EnvironmentObject) ist ein Wrapper, der Zugriff auf eine feste Liste von Variablen bietet, die die Umgebung unserer Anwendung widerspiegeln. Zum Beispiel Bildschirmausrichtung oder Betriebssystemfarbthema. Mit demselben Wrapper kann Ihre Ansicht abonniert werden, um diese Parameter zu ändern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Liste kann erweitert werden. Ich dachte mir, dass es richtig wäre, wenn @Environment Zugriff auf die Größe und Position der Statusleiste hätte. So habe ich es gemacht:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarFrame</span>: <span class="hljs-title">EnvironmentKey</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> defaultValue: <span class="hljs-type">CGRect</span> {
        <span class="hljs-type">CGRect</span>()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">EnvironmentValues</span> </span>{
    <span class="hljs-keyword">var</span> statusBarFrame: <span class="hljs-type">CGRect</span>{
        <span class="hljs-keyword">get</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>]<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>] = newValue<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe eine Struktur mit einem statischen Standardwert erstellt. </font><font style="vertical-align: inherit;">Anschließend habe ich die SystemValues-Systemstruktur erweitert, indem ich meine eigene berechnete Eigenschaft hinzugefügt habe, deren Getter und Setter sich auf den von mir erstellten Typ beziehen. </font><font style="vertical-align: inherit;">Der Typ wird hier verwendet, da EnvironmentValues ​​einen Index implementiert, in den Sie den Typ übergeben und den diesem Typ entsprechenden gespeicherten Wert abrufen. </font><font style="vertical-align: inherit;">Nicht der Wert dieses Typs, sondern der im bedingten Wörterbuch gespeicherte Wert, wobei der Typ selbst der Schlüssel ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf den Wert in @Environment wird mit keyPath \ .statusBarFrame zugegriffen. </font><font style="vertical-align: inherit;">So übergeben Sie beispielsweise den Umgebungswert an alle Ansichten in der Hierarchie:</font></font><br>
<br>
<pre><code class="swift hljs">.environment(\.statusBarFrame, statusBarFrame) 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und in der Ansicht selbst, um den Wert aus dem Geschäft abzurufen:</font></font><br>
<br>
<pre><code class="swift hljs">@<span class="hljs-type">Environment</span>(\.statusBarFrame) <span class="hljs-keyword">var</span> statusBarframe: <span class="hljs-type">CGRect</span> 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für die Arbeit mit der Statusleiste im UIWindowScene-Objekt in IOS 13 wurde übrigens das Attribut statusBarManager angezeigt. </font><font style="vertical-align: inherit;">Daraus können einige Parameter abgeleitet werden. </font><font style="vertical-align: inherit;">Aber jetzt können Sie sie nicht verwalten. </font><font style="vertical-align: inherit;">Soweit ich weiß, war es früher möglich, auf die ViewController-Statusleiste zuzugreifen und ihr eine Unteransicht hinzuzufügen. </font><font style="vertical-align: inherit;">Anscheinend war der Laden abgedeckt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen würde ich die Funktionalität des Modifikators .statusBar (versteckt :) genau hier übertragen, hier wäre es für mich angemessener. </font><font style="vertical-align: inherit;">Ich denke, früher oder später werden die Entwickler an diesen Punkt gelangen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, ich denke an diesem faszinierenden Beispiel kann ein Ausflug in die Animation mit SwiftUI-Tools als vollständig angesehen werden. Anhand einfacher Beispiele sprach ich über die wichtigsten Animationswerkzeuge und erklärte, wie genau sie unter der Haube funktionieren, wie sie verwendet werden sollten und warum genau. Anhand komplexerer Beispiele habe ich typische Schwierigkeiten aufgezeigt, auf die Sie stoßen können, und Möglichkeiten, diese zu überwinden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
War mein Code im Vergleich zum Beispiel aus dem obigen Artikel sauberer, klarer, kürzer oder ist er möglicherweise einfacher zu warten? Vielleicht nicht. Verbraucht es weniger Ressourcen? Ach nein. Vielleicht ist mein Ansatz universeller, aber das ist nicht richtig. Es gibt jedoch eine Aufgabe, die er definitiv besser erledigt. Es zeigt viel tiefer die Funktionsweise von SwiftUI unter der Haube. Mit ihm können Sie die Animation in die Regale in Ihrem Kopf stellen und sie frei in Ihren Anwendungen anwenden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftUI wird aktiv gesägt. </font><font style="vertical-align: inherit;">Selbst jetzt, zwei Wochen nach dem Schreiben des Codes für den ersten Artikel, sehe ich beim Überprüfen des Codes in der aktuellen Version von Xcode, wie einige Fehler, die ich umgehen musste, bereits behoben wurden. </font><font style="vertical-align: inherit;">Deshalb bin ich ein bisschen bei dem Artikel geblieben. </font><font style="vertical-align: inherit;">Etwas musste wegen Irrelevanz und alles andere geschnitten werden - um es noch einmal zu überprüfen. </font><font style="vertical-align: inherit;">Und es gefällt. </font><font style="vertical-align: inherit;">SwiftUI ist definitiv die Zukunft der nativen iOS-Entwicklung, und es ist sehr informativ, an seinen Ursprüngen zu stehen und zu beobachten, wie es sich entwickelt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachwort</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Vorbereitung der Materialien für diesen Artikel habe ich auch viele Dinge in meinen Kopf gesteckt. </font><font style="vertical-align: inherit;">Ich fand viele Nuancen heraus, von denen ich keine Ahnung hatte, als ich gerade anfing, sie zu schreiben. </font><font style="vertical-align: inherit;">Daher fordere ich alle auf, die bereits Erfahrung in der SwiftUI-Entwicklung haben - seien Sie nicht schüchtern, teilen Sie Ihre Erfahrungen und Ihr Wissen. </font><font style="vertical-align: inherit;">Dies ist sowohl für die Community als auch für die Vollständigkeit Ihres eigenen Wissens sehr nützlich. </font><font style="vertical-align: inherit;">Dies ist cooler als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Entleinmethode</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und es besteht auch die Notwendigkeit, die Antwort zu formulieren. </font><font style="vertical-align: inherit;">Die Hauptsache ist, nicht faul zu sein, nach einer solchen Antwort zu suchen, damit es den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jungen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht peinlich ist, sie </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">zu zeigen</font></a><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de506648/index.html">Laravel Digest (8.-14. Juni 2020)</a></li>
<li><a href="../de506658/index.html">GitLab 13.0 mit Gitaly-Clustern, epischer Hierarchie auf Roadmaps und automatischer Bereitstellung für ECS</a></li>
<li><a href="../de506662/index.html">Adaptive Aufteilung von Bezier-Kurven 2. und 3. Ordnung</a></li>
<li><a href="../de506664/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 419 (8.-14. Juni 2020)</a></li>
<li><a href="../de506666/index.html">ORM-Texturen, aber lohnt es sich?</a></li>
<li><a href="../de506676/index.html">Katar: Weltzentrum für Transplantationen und Nachtstadt</a></li>
<li><a href="../de506680/index.html">.NET Core vs Node.js. Argumente und Fakten</a></li>
<li><a href="../de506684/index.html">Wie ich dedic.ru auf Github-Seiten übertragen habe und zufrieden war</a></li>
<li><a href="../de506686/index.html">Digitale Veranstaltungen in Moskau vom 15. bis 21. Juni</a></li>
<li><a href="../de506688/index.html">Digitale Veranstaltungen in St. Petersburg vom 15. bis 21. Juni</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>