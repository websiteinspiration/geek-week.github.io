<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👾 📕 🕴🏽 OpenID Connect: otorisasi aplikasi internal dari generik ke standar 🕺🏼 🔌 🚓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa bulan yang lalu, saya mengimplementasikan server OpenID Connect untuk mengontrol akses ke ratusan aplikasi internal kami. Dari perkembangan k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>OpenID Connect: otorisasi aplikasi internal dari generik ke standar</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/uchi_ru/blog/492488/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beberapa bulan yang lalu, saya mengimplementasikan server OpenID Connect untuk mengontrol akses ke ratusan aplikasi internal kami. </font><font style="vertical-align: inherit;">Dari perkembangan kami sendiri, nyaman dalam skala yang lebih kecil, kami beralih ke standar yang berlaku umum. </font><font style="vertical-align: inherit;">Akses melalui layanan pusat sangat menyederhanakan operasi monoton, mengurangi biaya penerapan otorisasi, memungkinkan Anda menemukan banyak solusi yang siap pakai dan tidak mematahkan otak Anda ketika mengembangkan yang baru. </font><font style="vertical-align: inherit;">Dalam artikel ini saya akan berbicara tentang transisi ini dan benjolan yang berhasil kami isi.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lf/rf/lc/lfrflcyqjujtcdbfqn71iok4i1o.png" alt="intro"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekali waktu ... Bagaimana semuanya dimulai</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beberapa tahun yang lalu, ketika ada terlalu banyak aplikasi internal untuk kontrol manual, kami menulis aplikasi untuk kontrol akses di dalam perusahaan. Itu adalah aplikasi Rails sederhana yang terhubung ke database dengan informasi tentang karyawan, di mana akses ke berbagai fungsi dikonfigurasi. Kemudian kami mengangkat SSO pertama, yang didasarkan pada verifikasi token dari klien dan server otorisasi, token ditransmisikan dalam bentuk terenkripsi dengan beberapa parameter dan diperiksa pada server otorisasi. Ini bukan pilihan yang paling nyaman, karena pada setiap aplikasi internal perlu untuk menggambarkan lapisan logika yang cukup, dan basis karyawan sepenuhnya disinkronkan dengan server otorisasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah beberapa waktu, kami memutuskan untuk menyederhanakan tugas otorisasi terpusat. SSO ditransfer ke penyeimbang. Dengan menggunakan OpenResty di Lua, mereka menambahkan templat yang memeriksa token, tahu aplikasi mana yang memasukkan permintaan, dan dapat memeriksa apakah ada akses di sana. Pendekatan ini sangat menyederhanakan tugas mengendalikan akses aplikasi internal - dalam kode setiap aplikasi, tidak perlu lagi untuk menggambarkan logika tambahan. Akibatnya, kami menutup lalu lintas secara eksternal, dan aplikasi itu sendiri tidak tahu apa-apa tentang otorisasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, salah satu masalah tetap belum terselesaikan. </font><font style="vertical-align: inherit;">Bagaimana dengan aplikasi yang membutuhkan informasi tentang karyawan? </font><font style="vertical-align: inherit;">Anda dapat menulis API untuk layanan otorisasi, tetapi kemudian Anda harus menambahkan logika tambahan untuk setiap aplikasi tersebut. </font><font style="vertical-align: inherit;">Selain itu, kami ingin menghilangkan ketergantungan pada salah satu aplikasi yang kami tulis sendiri, yang lebih berorientasi pada terjemahan ke dalam OpenSource, pada server otorisasi internal kami. </font><font style="vertical-align: inherit;">Kami akan membicarakannya lain kali. </font><font style="vertical-align: inherit;">Solusi untuk kedua masalah itu adalah OAuth.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk standar yang diterima secara umum</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OAuth adalah standar otorisasi yang dapat dipahami dan diterima secara umum, tetapi karena fungsinya tidak cukup, OpenID Connect (OIDC) segera mulai dipertimbangkan. </font><font style="vertical-align: inherit;">OIDC sendiri adalah implementasi ketiga dari standar otentikasi terbuka yang telah menyebar ke add-in melalui protokol OAuth 2.0 (protokol otorisasi terbuka). </font><font style="vertical-align: inherit;">Solusi ini menutup masalah kurangnya data tentang pengguna akhir, dan juga memungkinkan untuk mengubah penyedia otorisasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, kami tidak memilih penyedia tertentu dan memutuskan untuk menambahkan integrasi dengan OIDC untuk server otorisasi kami yang ada. </font><font style="vertical-align: inherit;">Dalam mendukung solusi seperti itu, OIDC sangat fleksibel dalam hal mengotorisasi pengguna akhir. </font><font style="vertical-align: inherit;">Dengan demikian, dimungkinkan untuk menerapkan dukungan OIDC pada server otorisasi Anda saat ini.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/j3/df/7x/j3df7xjz3ehktpwzwpf8redrmmc.png" alt="gambar"><br>
 <br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara kami untuk mengimplementasikan server OIDC kami sendiri</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) Mereka membawa data ke formulir yang diinginkan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengintegrasikan OIDC, Anda perlu membawa data pengguna saat ini dengan cara yang dapat dimengerti oleh standar. </font><font style="vertical-align: inherit;">Dalam OIDC, ini disebut Klaim. </font><font style="vertical-align: inherit;">Merek pada dasarnya adalah bidang akhir dalam basis data pengguna (nama, email, telepon, dll.). </font><font style="vertical-align: inherit;">Ada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">daftar merek standar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan segala sesuatu yang tidak termasuk dalam daftar ini dianggap kebiasaan. </font><font style="vertical-align: inherit;">Oleh karena itu, poin pertama yang perlu Anda perhatikan jika Anda ingin memilih penyedia OIDC yang ada adalah kemampuan untuk menyesuaikan merek baru dengan mudah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelompok merek digabungkan ke dalam subset berikutnya - Lingkup. </font><font style="vertical-align: inherit;">Selama otorisasi, akses diminta untuk tidak ke merek tertentu, yaitu ke cakupan, bahkan jika beberapa ciri dari ruang lingkup tidak diperlukan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) Menerapkan hibah yang diperlukan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagian selanjutnya dari integrasi OIDC adalah pemilihan dan implementasi jenis otorisasi, yang disebut hibah. Skenario selanjutnya dari interaksi aplikasi yang dipilih dengan server otorisasi akan tergantung pada hibah yang dipilih. Skema perkiraan untuk memilih hibah yang tepat disajikan pada gambar di bawah ini.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fm/c1/8b/fmc18b4jfprq3mjz-knzjo_4yso.png" alt="gambar"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk aplikasi pertama kami, kami menggunakan hibah yang paling umum - Kode Otorisasi. Perbedaannya dari yang lain adalah bahwa itu adalah tiga langkah, yaitu melewati verifikasi tambahan. Pertama, pengguna membuat permintaan izin otorisasi, menerima Token - Kode Otorisasi, kemudian dengan token ini, seolah-olah dengan tiket untuk perjalanan, meminta token akses. Semua interaksi utama skenario otorisasi ini didasarkan pada pengalihan antara aplikasi dan server otorisasi. Baca lebih lanjut tentang hibah ini di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OAuth menganut konsep bahwa token akses yang diterima setelah otorisasi harus bersifat sementara dan berubah rata-rata setiap 10 menit. Pemberian Kode Otorisasi adalah pemeriksaan tiga langkah melalui pengalihan, setiap 10 menit, memutar langkah seperti itu, terus terang, bukan pengalaman yang menyenangkan bagi mata. Untuk mengatasi masalah ini, ada hibah lain - Segarkan Token, yang juga kami libatkan. Semuanya lebih sederhana di sini. Selama pengujian, dari hibah lain, selain token akses utama, satu lagi dikeluarkan - Segarkan Token, yang dapat digunakan hanya sekali dan masa pakainya, sebagai suatu peraturan, secara signifikan lebih lama. Dengan Refresh Token ini, ketika TTL (Time to Live) dari token akses utama berakhir, permintaan untuk token akses baru akan sampai ke titik akhir dari hibah lain. Refresh Token yang digunakan segera direset.Pemeriksaan semacam itu adalah dua langkah dan dapat dilakukan di latar belakang, tanpa terlihat oleh pengguna.</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) Format output data pengguna yang disesuaikan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah hibah terpilih diimplementasikan, otorisasi berfungsi, perlu disebutkan penerimaan data tentang pengguna akhir. </font><font style="vertical-align: inherit;">OIDC memiliki titik akhir yang terpisah untuk ini, di mana Anda dapat meminta data pengguna dengan token akses Anda saat ini dan ketika relevan. </font><font style="vertical-align: inherit;">Dan jika data pengguna tidak terlalu sering berubah, dan Anda harus mengikuti arus berkali-kali, Anda dapat mengambil keputusan seperti token JWT. </font><font style="vertical-align: inherit;">Token ini juga didukung oleh standar. </font><font style="vertical-align: inherit;">Token JWT itu sendiri terdiri dari tiga bagian: header (informasi tentang token), payload (semua data yang diperlukan) dan tanda tangan (tanda tangan, token ditandatangani oleh server dan Anda dapat memeriksa sumber tanda tangannya di masa mendatang).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam implementasi OIDC, token JWT disebut id_token. </font><font style="vertical-align: inherit;">Itu dapat diminta bersama dengan token akses reguler, dan yang tersisa adalah memverifikasi tanda tangan. </font><font style="vertical-align: inherit;">Server otorisasi memiliki titik akhir yang terpisah untuk ini dengan sekelompok kunci publik dalam format </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JWK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dan berbicara tentang ini, perlu disebutkan bahwa ada titik akhir lain yang, berdasarkan standar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC5785,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mencerminkan konfigurasi server OIDC saat ini. </font><font style="vertical-align: inherit;">Ini berisi semua alamat titik akhir (termasuk alamat gantungan kunci publik yang digunakan untuk penandatanganan), merek dan cakupan yang didukung, algoritma enkripsi yang digunakan, hibah yang didukung, dll.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalnya di Google:</font></font></b>
                        <div class="spoiler_text"><pre><code class="json hljs">{
 <span class="hljs-attr">"issuer"</span>: <span class="hljs-string">"https://accounts.google.com"</span>,
 <span class="hljs-attr">"authorization_endpoint"</span>: <span class="hljs-string">"https://accounts.google.com/o/oauth2/v2/auth"</span>,
 <span class="hljs-attr">"device_authorization_endpoint"</span>: <span class="hljs-string">"https://oauth2.googleapis.com/device/code"</span>,
 <span class="hljs-attr">"token_endpoint"</span>: <span class="hljs-string">"https://oauth2.googleapis.com/token"</span>,
 <span class="hljs-attr">"userinfo_endpoint"</span>: <span class="hljs-string">"https://openidconnect.googleapis.com/v1/userinfo"</span>,
 <span class="hljs-attr">"revocation_endpoint"</span>: <span class="hljs-string">"https://oauth2.googleapis.com/revoke"</span>,
 <span class="hljs-attr">"jwks_uri"</span>: <span class="hljs-string">"https://www.googleapis.com/oauth2/v3/certs"</span>,
 <span class="hljs-attr">"response_types_supported"</span>: [
  <span class="hljs-string">"code"</span>,
  <span class="hljs-string">"token"</span>,
  <span class="hljs-string">"id_token"</span>,
  <span class="hljs-string">"code token"</span>,
  <span class="hljs-string">"code id_token"</span>,
  <span class="hljs-string">"token id_token"</span>,
  <span class="hljs-string">"code token id_token"</span>,
  <span class="hljs-string">"none"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"subject_types_supported"</span>: [
  <span class="hljs-string">"public"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"id_token_signing_alg_values_supported"</span>: [
  <span class="hljs-string">"RS256"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"scopes_supported"</span>: [
  <span class="hljs-string">"openid"</span>,
  <span class="hljs-string">"email"</span>,
  <span class="hljs-string">"profile"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"token_endpoint_auth_methods_supported"</span>: [
  <span class="hljs-string">"client_secret_post"</span>,
  <span class="hljs-string">"client_secret_basic"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"claims_supported"</span>: [
  <span class="hljs-string">"aud"</span>,
  <span class="hljs-string">"email"</span>,
  <span class="hljs-string">"email_verified"</span>,
  <span class="hljs-string">"exp"</span>,
  <span class="hljs-string">"family_name"</span>,
  <span class="hljs-string">"given_name"</span>,
  <span class="hljs-string">"iat"</span>,
  <span class="hljs-string">"iss"</span>,
  <span class="hljs-string">"locale"</span>,
  <span class="hljs-string">"name"</span>,
  <span class="hljs-string">"picture"</span>,
  <span class="hljs-string">"sub"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"code_challenge_methods_supported"</span>: [
  <span class="hljs-string">"plain"</span>,
  <span class="hljs-string">"S256"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"grant_types_supported"</span>: [
  <span class="hljs-string">"authorization_code"</span>,
  <span class="hljs-string">"refresh_token"</span>,
  <span class="hljs-string">"urn:ietf:params:oauth:grant-type:device_code"</span>,
  <span class="hljs-string">"urn:ietf:params:oauth:grant-type:jwt-bearer"</span><font></font>
 ]<font></font>
}</code></pre> <br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, menggunakan id_token, Anda dapat mentransfer semua tanda yang diperlukan ke payload token dan tidak menghubungi server otorisasi setiap kali untuk meminta data tentang pengguna. </font><font style="vertical-align: inherit;">Kerugian dari pendekatan ini adalah bahwa mengubah data pengguna dari server tidak datang segera, tetapi dengan token akses baru.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasil implementasi</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, setelah mengimplementasikan server OIDC kami sendiri dan mengatur koneksi ke sisi aplikasi, kami memecahkan masalah pengiriman informasi pengguna. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena OIDC adalah standar terbuka, kami memiliki kesempatan untuk memilih penyedia atau implementasi server yang ada. </font><font style="vertical-align: inherit;">Kami mencoba Keycloak, yang ternyata sangat mudah dikonfigurasikan, setelah mengatur dan mengubah konfigurasi koneksi di sisi aplikasi, siap untuk bekerja. </font><font style="vertical-align: inherit;">Di sisi aplikasi, hanya mengubah konfigurasi koneksi.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berbicara tentang solusi yang ada</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai bagian dari organisasi kami, sebagai server OIDC pertama, kami mengumpulkan implementasi kami, yang ditambahkan sesuai kebutuhan. Setelah meninjau secara terperinci solusi siap pakai lainnya, kita dapat mengatakan bahwa ini adalah poin yang dapat diperdebatkan. Kekhawatiran pihak penyedia tentang kurangnya fungsionalitas yang diperlukan berfungsi sebagai solusi untuk implementasi server mereka, serta keberadaan sistem lama di mana terdapat berbagai otorisasi khusus untuk beberapa layanan dan cukup banyak data disimpan tentang karyawan. Namun, dalam implementasi yang sudah jadi, ada kemudahan untuk integrasi. Misalnya, Keycloak memiliki sistem manajemen penggunanya sendiri dan data disimpan langsung di dalamnya, dan tidak akan sulit untuk menyalip penggunanya di sana. Untuk ini, Keycloak memiliki API yang akan memungkinkan Anda untuk sepenuhnya menerapkan semua langkah yang diperlukan untuk transfer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh lain dari sertifikasi, menarik, menurut saya, implementasi adalah Ory Hydra. </font><font style="vertical-align: inherit;">Sangat menarik karena terdiri dari berbagai komponen. </font><font style="vertical-align: inherit;">Untuk integrasi, Anda perlu menautkan layanan manajemen pengguna Anda dengan layanan otorisasi mereka dan memperluas seperlunya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keycloak dan Ory Hydra bukan satu-satunya solusi turnkey. </font><font style="vertical-align: inherit;">Yang terbaik adalah memilih implementasi OpenID Foundation yang bersertifikat. </font><font style="vertical-align: inherit;">Biasanya, solusi semacam itu memiliki lencana Sertifikasi OpenID.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/8g/nl/ob/8gnlob5hxgfi2038fymlqsm5tjy.png" alt="Sertifikasi terbuka"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juga, jangan lupa tentang penyedia berbayar yang ada jika Anda tidak ingin menyimpan server OIDC Anda. </font><font style="vertical-align: inherit;">Ada banyak opsi bagus hingga saat ini.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa berikutnya</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam waktu dekat, kami akan menutup lalu lintas ke layanan internal dengan cara lain. </font><font style="vertical-align: inherit;">Kami berencana untuk mentransfer SSO kami saat ini pada penyeimbang menggunakan OpenResty ke proksi berdasarkan OAuth. </font><font style="vertical-align: inherit;">Ada juga banyak solusi siap pakai di sini, misalnya: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/bitly/oauth2_proxy </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/ory/oathkeeper </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/keycloak/keycloak-gatekeeper</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahan tambahan</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jwt.io</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - layanan yang bagus untuk memeriksa </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">openid.net/developers/certified</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> JWT token </font><font style="vertical-align: inherit;">- daftar implementasi OIDC bersertifikat</font></font><br>
<cut></cut></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id492478/index.html">Tanpa manajemen pengetahuan itu menyakitkan: 5 konsekuensi utama dari kurangnya sistem</a></li>
<li><a href="../id492480/index.html">Bagaimana kami berjuang dengan epidemi sebelumnya dan apa yang kami lakukan terhadap coronavirus</a></li>
<li><a href="../id492482/index.html">Acara digital di Moskow dari 16 hingga 22 Maret</a></li>
<li><a href="../id492484/index.html">Acara digital di St. Petersburg dari 16 Maret hingga 22 Maret</a></li>
<li><a href="../id492486/index.html">Nuxt + Django + GraphQL misalnya</a></li>
<li><a href="../id492492/index.html">NikiRobot - sebuah evolusi dalam robotika pendidikan</a></li>
<li><a href="../id492496/index.html">Contoh SPA Simple Notes di Mithril.js</a></li>
<li><a href="../id492500/index.html">Garasi Sains dalam bahasa Rusia. Pengalaman menerjemahkan pertunjukan Amerika</a></li>
<li><a href="../id492502/index.html">MIP * = RE: bukti pembuatan zaman dari bidang ilmu komputer yang menyebabkan efek domino dalam fisika dan matematika</a></li>
<li><a href="../id492504/index.html">Apa yang terjadi ketika modul JS diimpor dua kali?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>