<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🚀 🤴🏽 🦆 Redux vs MobX sem confusão 🚶🏽 📌 🍈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nos últimos anos, tenho usado frequentemente o Redux , mas recentemente tenho usado o MobX como uma alternativa ao gerenciamento de estado. As alterna...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Redux vs MobX sem confusão</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489854/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/dt/7e/na/dt7enamgfkxspaajcdst26auxj8.jpeg" alt="imagem"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos últimos anos, tenho usado frequentemente o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas recentemente tenho usado o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MobX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como uma alternativa ao gerenciamento de estado. As alternativas Redux parecem se transformar naturalmente em uma confusão. As pessoas não têm certeza de qual solução escolher. O problema não é necessariamente Redux vs MobX. Sempre que existe uma alternativa, as pessoas ficam curiosas sobre a melhor forma de resolver seu problema. Estou escrevendo estas linhas para eliminar a confusão em torno das soluções de gerenciamento de estado Redux e MobX.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobre o que será este artigo? </font><font style="vertical-align: inherit;">Primeiro, quero voltar brevemente ao problema que a biblioteca de gerenciamento de estado resolve. </font><font style="vertical-align: inherit;">No final, tudo ficará bem se você apenas usar this.setState () e this.state no React ou sua variação em outra biblioteca no nível da apresentação ou em um ambiente SPA. </font><font style="vertical-align: inherit;">Em segundo lugar, continuarei a fornecer uma visão geral das duas soluções, mostrando consistência e diferenças. </font><font style="vertical-align: inherit;">Por último, mas não menos importante, se você já possui um aplicativo que funcione com o MobX ou o Redux, quero falar sobre a refatoração de uma biblioteca de estado para outra.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conteúdo:</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que problema resolvemos?</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qual é a diferença entre REDUX e MOBX?</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curva de aprendizado do estado de reação</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pensamentos recentes sobre o tema</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais recursos</font></font></a></li>
</ol><br>
<a name="WhatProblem"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que problema resolvemos?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo mundo quer ter gerenciamento de estado no aplicativo. </font><font style="vertical-align: inherit;">Mas que problema isso resolve para nós? </font><font style="vertical-align: inherit;">A maioria das pessoas começa com um aplicativo pequeno e já implementa uma biblioteca de gerenciamento de estado. </font><font style="vertical-align: inherit;">Todo mundo está falando sobre isso, certo? </font><font style="vertical-align: inherit;">Restaurado! </font><font style="vertical-align: inherit;">MobX! </font><font style="vertical-align: inherit;">Mas a maioria dos aplicativos não precisa de gerenciamento de estado ambicioso desde o início. </font><font style="vertical-align: inherit;">Isso é ainda mais perigoso, porque a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maioria das pessoas nunca será confrontada com problemas como bibliotecas como Redux ou MobX</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atualmente, o status quo está construindo um aplicativo front-end com componentes. </font><font style="vertical-align: inherit;">Os componentes têm um estado interno. </font><font style="vertical-align: inherit;">Em um aplicativo crescente, o gerenciamento de estado pode se tornar caótico com um estado local, porque:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um componente deve compartilhar o estado com outro componente</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um componente deve modificar o estado de outro componente</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em algum momento, fica cada vez mais difícil falar sobre o estado do aplicativo. Isso se torna uma rede suja de objetos de estado e mutações de estado na hierarquia de componentes. Na maioria dos casos, objetos de estado e mutações de estado não estão necessariamente associados a um componente. Eles estão vinculados à sua árvore de componentes e você deve aumentar e diminuir o estado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A solução, portanto, é apresentar uma biblioteca de gerenciamento de estado, como MobX ou Redux. Ele fornece ferramentas para salvar seu estado, alterar estado e receber atualizações de estado. Você tem um local para pesquisar, um local para alterar e um local para receber atualizações de status. Ele segue o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">princípio de uma única fonte de verdade.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso facilita o raciocínio sobre alterações no seu estado e condições, porque elas se separam dos seus componentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bibliotecas de gerenciamento de estado como Redux e MobX geralmente têm complementos para utilitários, por exemplo, para Angular eles têm angular-redux e mobx-angular para dar acesso aos componentes aos seus estados. </font><font style="vertical-align: inherit;">Geralmente, esses componentes são chamados de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">componentes em contêineres</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou, para ser mais preciso, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">componentes relacionados</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">De qualquer lugar da hierarquia de componentes, você pode acessar o estado e alterá-lo, atualizando seu componente para um relacionado.</font></font><br>
<br>
<a name="whats-the-difference-between-redux-and-mobx"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qual é a diferença entre REDUX e MOBX?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de mergulharmos na diferença, quero falar sobre as semelhanças entre o MobX e o Redux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ambas as bibliotecas são usadas para controlar o estado em aplicativos JavaScript. Eles não estão necessariamente associados a uma biblioteca como Angular. Eles também são usados ​​em outras bibliotecas, como ReactJs e VueJs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você escolher uma das soluções de gerenciamento de estado, não encontrará um bloqueio de fornecedor. Você pode mudar para outra solução de gerenciamento de estado a qualquer momento. Você pode atualizar do MobX para o Redux ou do Redux para o MobX. Mais tarde vou mostrar como isso acontece. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redux projetado por </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan Abramov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andrew Clark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é um derivado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">da arquitetura Flux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ao contrário do Flux, ele usa um repositório em vários para manter o estado. Além disso, em vez de um expedidor, ele usa funções puras para alterar o estado. Se você não está familiarizado com o fluxo e é novo no gerenciamento de estado, não se preocupe com o último parágrafo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redux é influenciado pelos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">princípios de programação funcional</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (FP). O FP pode ser feito em JavaScript, mas muitas pessoas têm um background orientado a objetos, como Java, e têm dificuldade em aceitar os princípios da programação funcional em primeiro lugar. Isso depois explica por que o MobX pode ser mais fácil de aprender como iniciante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como o Redux inclui programação funcional, ele usa </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funções puras</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma função pura é uma função que recebe entrada, retorna saída e não possui outras dependências além das mesmas funções. </font><font style="vertical-align: inherit;">Essa função sempre produz a mesma saída com a mesma entrada e não tem efeitos colaterais. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais detalhes</font></font></a></blockquote><br>
<pre><code class="javascript hljs">(state, action) =&gt; newState</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seu estado Redux </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é inalterado</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Em vez de mudar, você sempre retorna um novo estado. </font><font style="vertical-align: inherit;">Você não executa mutações de estado e não depende de referências a objetos.</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-comment">//     Redux,     </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAuthor</span>(<span class="hljs-params">state, action</span>) </span>{
  <span class="hljs-keyword">return</span> state.authors.push(action.author);<font></font>
}<font></font>
<span class="hljs-comment">//       </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAuthor</span>(<span class="hljs-params">state, action</span>) </span>{
  <span class="hljs-keyword">return</span> [ ...state.authors, action.author ];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E por último, mas não menos importante, no Redux idiomático, seu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estado é normalizado</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , como em um banco de dados. As entidades se </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">referem uma à outra apenas por ID</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Essa é a melhor prática. Embora nem todos o façam, você pode usar uma biblioteca como o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normalizr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para atingir um estado normalizado. O estado normalizado permite manter um estado e entidades </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simples</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como uma </font><b><font style="vertical-align: inherit;">única fonte de verdade</font></b><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="json hljs">{<font></font>
  post: {<font></font>
    id: 'a',<font></font>
    authorId: 'b',<font></font>
    ...<font></font>
  },<font></font>
  author: {<font></font>
    id: 'b',<font></font>
    postIds: ['a', ...],<font></font>
    ...<font></font>
  }<font></font>
}</code></pre><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em comparação, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o MobX de Michel Weststratt é</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> influenciado não apenas pela programação orientada a objetos, mas também pela programação reativa. </font><font style="vertical-align: inherit;">Envolve seu estado em objetos observáveis. </font><font style="vertical-align: inherit;">Assim, você tem todos os recursos do " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " em seu estado. </font><font style="vertical-align: inherit;">Os dados podem ter setters e getters simples, mas observáveis ​​permitem que você receba atualizações após alterações nos dados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No Mobx, seu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">status é volátil</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dessa forma, você altera o estado diretamente:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAuthor</span>(<span class="hljs-params">author</span>) </span>{
  <span class="hljs-keyword">this</span>.authors.push(author);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, as organizações permanecem em uma estrutura de dados aninhada (profundamente) uma em relação à outra. </font><font style="vertical-align: inherit;">Você não normaliza sua condição. </font><font style="vertical-align: inherit;">A condição </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permanece </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desnormalizada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e incorporada.</font></font></b><br>
<br>
<pre><code class="json hljs">{<font></font>
  post: {<font></font>
    id: 'a',<font></font>
    ...<font></font>
    author: {<font></font>
      id: 'b',<font></font>
      ...<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um repositório versus vários</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No Redux, você armazena todo o seu estado em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um repositório global</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um estado global</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Um único objeto de estado é sua única fonte de verdade. Por outro lado, numerosas caixas de velocidades permitem alterar um estado imutável. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em comparação, o MobX usa vários repositórios. Como os redutores Redux, você pode aplicar a separação e a conquista por nível técnico, domínio etc. Você pode armazenar seus objetos de domínio em repositórios separados, mas também pode controlar o status de exibição em seus repositórios. No final, você coloca o estado mais apropriado para seu aplicativo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tecnicamente, você também pode ter vários repositórios no Redux. </font><font style="vertical-align: inherit;">Ninguém obriga a usar apenas um. </font><font style="vertical-align: inherit;">Mas este não é um caso de uso anunciado do Redux. </font><font style="vertical-align: inherit;">O uso de vários repositórios é contrário às práticas recomendadas. </font><font style="vertical-align: inherit;">No Redux, você deseja ter um repositório que responde através de seus redutores a eventos globais.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como é a implementação?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No Redux, adicionar a configuração de um aplicativo a um estado global requer as seguintes linhas de código. </font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> initialState = {
  <span class="hljs-attr">users</span>: [<font></font>
    {<font></font>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Alex'</span><font></font>
    },<font></font>
    {<font></font>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Nik'</span><font></font>
    }<font></font>
  ]<font></font>
};<font></font>
<span class="hljs-comment">// reducer</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">users</span>(<span class="hljs-params">state = initialState, action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
  <span class="hljs-keyword">case</span> <span class="hljs-string">'USER_ADD'</span>:
    <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">users</span>: [ ...state.users, action.user ] };
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">return</span> state;<font></font>
  }<font></font>
}<font></font>
<span class="hljs-comment">// action</span>
{ <span class="hljs-attr">type</span>: <span class="hljs-string">'USER_ADD'</span>, <span class="hljs-attr">user</span>: user };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No MobX, o armazenamento gerencia apenas o subestado (como o redutor no Redux controla o subestado), mas você pode alterar diretamente o estado. </font><font style="vertical-align: inherit;">A anotação @observable permite observar alterações de estado.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">userStore</span></span>{<font></font>
@observable users = [<font></font>
    {<font></font>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Nikita'</span><font></font>
    }<font></font>
  ];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora você pode chamar userStore.users.push (user); </font><font style="vertical-align: inherit;">na cópia da loja. </font><font style="vertical-align: inherit;">No entanto, recomenda-se que as mutações de estado sejam mais explícitas por meio da ação.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">userStore</span></span>{<font></font>
@observable users = [<font></font>
    {<font></font>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Nikita'</span><font></font>
    }<font></font>
  ];<font></font>
}<font></font>
@action addUser = <span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> {
    <span class="hljs-keyword">this</span>.users.push(user);<font></font>
  }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode aplicá-lo estritamente configurando o MobX com o configure ({empceActions: true}) ;. </font><font style="vertical-align: inherit;">Agora você pode alterar seu estado chamando userStore.addUser (user); </font><font style="vertical-align: inherit;">na cópia da loja. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você viu como atualizar o estado no Redux e no MobX. </font><font style="vertical-align: inherit;">No Redux, seu estado é </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">somente leitura</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Você só pode alterar o estado com </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ações explícitas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Por outro lado, no MobX, o estado inclui leitura e escrita. </font><font style="vertical-align: inherit;">Você pode alterar o estado diretamente sem usar ações, mas pode selecionar ações explícitas usando a configuração enforceActions.</font></font><br>
<br>
<a name="the-learning-curve-in-react-state-management"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curva de aprendizado do estado de reação</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Redux e o MobX são usados ​​principalmente em aplicativos React. Mas essas são bibliotecas de gerenciamento de estado independentes que podem ser usadas em qualquer lugar sem o React. Suas bibliotecas de interação facilitam combiná-las com componentes angulares. Estes são </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">react </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React + Redux</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mobx-react</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React + MobX</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mais tarde, explicarei como usar os dois na árvore de componentes Angular.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em discussões recentes, aconteceu que as pessoas discutiram sobre a curva de aprendizado no Redux. Isso geralmente acontecia no contexto do React: as pessoas começaram a aprender o React e já queriam usar o gerenciamento de estado com o Redux. A maioria das pessoas afirma que o React e o Redux possuem uma boa curva de aprendizado, mas ambos podem ser esmagadores. Portanto, o MobX será uma alternativa, porque é mais adequado para iniciantes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, eu sugeriria uma abordagem diferente para os novos usuários do React aprenderem sobre gerenciamento de estado no ecossistema do React. </font><font style="vertical-align: inherit;">Comece a aprender Reaja com seus próprios recursos locais de gerenciamento de estado nos componentes. </font><font style="vertical-align: inherit;">Em um aplicativo React, você primeiro aprende sobre os métodos do ciclo de vida do React e entende como gerenciar estados locais com setState () e this.state. </font><font style="vertical-align: inherit;">Eu recomendo esse caminho de aprendizado. </font><font style="vertical-align: inherit;">Caso contrário, você será rapidamente dominado pelo ecossistema React. </font><font style="vertical-align: inherit;">No final, ao longo do caminho, você perceberá que gerenciar o estado (interno) dos componentes se torna complicado.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux ou MobX para iniciantes?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Familiarizando-se com os componentes Angular e o gerenciamento interno de estado, você pode escolher uma biblioteca de gerenciamento de estado para resolver seu problema. Depois de usar as duas bibliotecas, eu diria que o MobX pode ser muito conveniente para iniciantes. Já vimos que o MobX precisa de menos código, embora use algumas notas mágicas que ainda não precisamos conhecer. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com o MobX, você não precisa estar familiarizado com a programação funcional. Termos como imutabilidade ainda podem ser estrangeiros.</font></font><blockquote>  —   ,       JavaScript.     ,          ,   - , ,     MobX.</blockquote><br>
<br>
<h3>  Redux</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À medida que seu aplicativo cresce, e vários desenvolvedores trabalham nele, considere usar o Redux. Por natureza, ele se compromete a usar ações explícitas para mudar de estado. A ação tem um tipo e carga útil que a caixa de velocidades pode usar para alterar o estado. É muito fácil para a equipe de desenvolvimento falar sobre mudanças de estado dessa maneira. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Redux fornece uma arquitetura inteira para gerenciamento de estado com limitações claras. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">História de sucesso do Redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra vantagem do Redux é seu uso no servidor. Como estamos lidando com JavaScript simples, você pode enviar o estado pela rede. A serialização e desserialização de um objeto de estado funcionam imediatamente. No entanto, isso também é possível com o MobX.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O MobX é menos autoconfiante, mas com o configure ({empceActions: true}) você pode aplicar restrições mais precisas, como no Redux. É por isso que eu não diria que você não pode usar o MobX para dimensionar aplicativos, mas o Redux tem uma maneira clara de fazer alguma coisa. A documentação do MobX até diz: " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[MobX] não diz como estruturar seu código, onde armazenar estado ou como manipular eventos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". A equipe de desenvolvimento precisaria primeiro criar uma arquitetura de gerenciamento de estado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afinal, a curva de aprendizado da gestão estadual não é tão íngreme. Quando repetimos as recomendações, um novato em React </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primeiro aprenderá como usar setState () e this.state corretamente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Depois de um tempo, você entenderá os </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">problemas de usar apenas setState ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para manter o estado no aplicativo React. </font><font style="vertical-align: inherit;">Ao procurar uma solução, você encontra bibliotecas de gerenciamento de estado, como MobX ou Redux. </font><font style="vertical-align: inherit;">Mas qual escolher? </font><font style="vertical-align: inherit;">Como o MobX é menos autoconfiante, possui um modelo menor e pode ser usado da mesma forma que o setState (), eu recomendaria dar ao MobX uma chance em pequenos projetos. </font><font style="vertical-align: inherit;">Assim que o aplicativo aumentar de tamanho e aumentar o número de participantes, considere aplicar restrições adicionais no MobX ou dê uma chance ao Redux. </font><font style="vertical-align: inherit;">Eu gostei de usar as duas bibliotecas. </font><font style="vertical-align: inherit;">Mesmo se você não usar um deles no final, faz sentido ver uma maneira alternativa de gerenciar o estado.</font></font><br>
<br>
<a name="last-thoughts"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Últimos pensamentos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sempre que leio os comentários na discussão entre Redux e MobX, há sempre um comentário: “O </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux tem muito padrão, você deve usar o MobX. Consegui excluir XXX linhas de código</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". O comentário pode ser verdade, mas ninguém considera um compromisso. O Redux vem com muitos modelos, como o MobX, porque foi adicionado para restrições de design específicas. Isso permite que você raciocine sobre o estado do seu aplicativo, mesmo que ele esteja em uma escala maior. Toda a cerimônia associada ao tratamento do estado não é justa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A biblioteca Redux é bem pequena. Na maioria das vezes, você </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lida apenas com objetos e matrizes JavaScript simples.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Isso está mais próximo do JavaScript básico do que do MobX. No MobX, objetos e matrizes são agrupados em objetos observáveis ​​que ocultam a maior parte do modelo padrão. Ele é construído sobre abstrações ocultas nas quais a mágica ocorre, mas é mais difícil entender os mecanismos básicos. O Redux facilita falar sobre isso com JavaScript simples. Isso facilita o teste e a depuração do aplicativo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, você precisa pensar novamente sobre de onde viemos no SPA. Muitas estruturas de uma página e bibliotecas de aplicativos tiveram os mesmos problemas de gerenciamento de estado que foram resolvidos usando um modelo de fluxo abrangente. Redux é o sucessor dessa abordagem.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No MobX, ele está novamente se movendo na direção oposta. Novamente, começamos a modificar o estado diretamente, sem tirar proveito da programação funcional. Para algumas pessoas, isso se aproxima novamente da ligação de dados bidirecional. Depois de algum tempo, as pessoas podem encontrar novamente os mesmos problemas antes que uma biblioteca de gerenciamento de estado, como o Redux, apareça. O gerenciamento de estado está espalhado pelos componentes e termina em desordem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enquanto no Redux você tem uma cerimônia estabelecida para preparar as coisas, o MobX é menos autoconfiante. Mas seria sensato aceitar a melhor experiência MobX. As pessoas precisam saber como organizar a gestão do estado para melhorar seus argumentos sobre isso. Caso contrário, as pessoas tendem a mudar de estado diretamente nos componentes.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambas as bibliotecas são ótimas. </font><font style="vertical-align: inherit;">Embora o Redux já esteja bem estabelecido, o MobX está se tornando uma alternativa viável ao gerenciamento de estado.</font></font></blockquote><br>
<a name="more-resurces"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais recursos</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparação de Michel Weststratt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - criador do </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MobX</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt489840/index.html">Anatomia da unidade: discos rígidos</a></li>
<li><a href="../pt489844/index.html">Análise comparativa de alguns descompiladores Java</a></li>
<li><a href="../pt489848/index.html">Por que meus colegas / funcionários se comportam como @% §?</a></li>
<li><a href="../pt489850/index.html">Semana de segurança 09: quem é responsável pela segurança do Android?</a></li>
<li><a href="../pt489852/index.html">Autenticação transparente no ASP.Net Core no Linux</a></li>
<li><a href="../pt489856/index.html">Paradoxo reverso de Banach-Tarski ou como reduzir o volume de dados armazenados em cinco vezes</a></li>
<li><a href="../pt489858/index.html">Internacionalização: Tornando a Web Acessível a Todos</a></li>
<li><a href="../pt489860/index.html">A história da Telefunken: a fênix da eletrônica alemã, de Wilhelm II e Goebbels aos Beatles e hoje</a></li>
<li><a href="../pt489862/index.html">Planejando no Go: Parte II - O Agendador Go</a></li>
<li><a href="../pt489868/index.html">Congelando o Mozilla WebThings</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>