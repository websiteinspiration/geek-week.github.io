<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍿 🧛🏼 👨🏻‍🏫 ステロイドの仕様 👮 ⛹🏿 🕰️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="抽象化とあらゆる種類の素敵なパターンのテーマは、ホリバールと永遠の紛争の発展の良い土台です。一方で、私たちは主流であるあらゆる種類の流行の言葉とクリーンなコードに従います。一方で、私たちは常に自分のルールを指示する実践と現実を持っています。
 
 抽象化が「リーク」し始めた場合の対処方法、言語チップ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ステロイドの仕様</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/singularis/blog/485328/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象化とあらゆる種類の素敵なパターンのテーマは、ホリバールと永遠の紛争の発展の良い土台です。一方で、私たちは主流であるあらゆる種類の流行の言葉とクリーンなコードに従います。一方で、私たちは常に自分のルールを指示する実践と現実を持っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
抽象化が「リーク」し始めた場合の対処方法、言語チップの使用方法、および「仕様」パターンから絞り出せるもの-猫の下を参照してください。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、ビジネスに取り掛かりましょう。この記事には次のセクションが含まれます。最初に、「仕様」パターンとは何か、純粋なデータベースサンプルへの適用が困難を引き起こす理由を調べます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、非常に強力なツールである式ツリーに目を向け、それらがどのように役立つかを確認します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、ステロイドの「仕様」の私の実装を示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本的なことから始めましょう。誰もが「仕様」パターンについて聞いたことがあると思いますが、聞いたことがない人のために、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィキペディア</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からの彼の定義は</font><font style="vertical-align: inherit;">次のとおりです。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラミングの「仕様」は、ビジネスロジックルールの表現をブール論理演算によって接続されたオブジェクトのチェーンに変換できる設計パターンです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このテンプレートは、ビジネスロジック内の、他との「結合」に適した仕様（ルール）を強調しています。</font><font style="vertical-align: inherit;">ビジネスロジックオブジェクトは、機能を抽象集約クラスCompositeSpecificationから継承します。このクラスには、ブール値を返すIsSatisfiedByメソッドが1つだけ含まれています。</font><font style="vertical-align: inherit;">インスタンス化後、オブジェクトは他のオブジェクトと一緒にチェーンされます。</font><font style="vertical-align: inherit;">その結果、ビジネスロジックを構成する柔軟性を失うことなく、新しいルールを簡単に追加できます。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、仕様は次のインターフェース（チェーンを構築するためのメソッドを破棄する）を実装するオブジェクトです。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ISpecification</span><font></font>
{<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsSatisfiedBy</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> candidate</span>)</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここではすべてがシンプルで明確です。しかし、ここで、ドメインに加えて、冷酷な人物でもあるインフラストラクチャが存在する実世界の例を見てみましょう。ORM、DBMS、およびデータベース内のデータをフィルタリングするための仕様を使用する場合を見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根拠のない、指を指さないようにするために、次のサブジェクト領域を例として取り上げます。MMORPGを開発していて、ユーザーがいて、各ユーザーに1つ以上の文字があり、各文字にアイテムのセットがあるとします（アイテムはユーザーごとに固有であると想定しているため、各アイテムに改善のルーンを適用できます。全体として、図の形で（ネストされたクエリについて説明するときに、少し後でReadCharacterクラスを検討します）：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/k5/bx/iw/k5bxiwkvgl5vghoog71-9w6vqdo.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このモデルは現実世界と疎結合しており、使用されているORMとの関連を反映するフィールドも含まれていますが、これで作業を実証するには十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
指定した日付以降に作成されたすべての文字をフィルターで除外するとします。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、次の形式の仕様を記述します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CreatedAfter</span>: <span class="hljs-title">ISpecification</span><font></font>
{<font></font>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> DateTime _target;<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CreatedAfter</span>(<span class="hljs-params">DateTime target</span>)</span><font></font>
  {<font></font>
    _target = target;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsSatisfiedBy</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> candidate</span>)</span><font></font>
  {<font></font>
    <span class="hljs-keyword">var</span> character = candidate <span class="hljs-keyword">as</span> Character;
    <span class="hljs-keyword">if</span>(character == <span class="hljs-literal">null</span>)
  	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
<font></font>
    <span class="hljs-keyword">return</span> character.CreatedAt &gt; target;<font></font>
  }<font></font>
}<font></font>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、この仕様を適用するために、以下を実行します（以下、NHibernateベースのコードを検討します）。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> characters = <span class="hljs-keyword">await</span> session.Query&lt;Character&gt;().ToListAsync();
<span class="hljs-keyword">var</span> filter = <span class="hljs-keyword">new</span> CreatedAfter(<span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2020</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>));
<span class="hljs-keyword">var</span> newCharacters = characters.Where(x =&gt; filter.IsSatisfiedBy(x)).ToArray();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの拠点が小さい限り、すべてが美しく迅速に機能しますが、ゲームが多かれ少なかれ人気を博し、数万人のユーザーを獲得した場合、このすべての魅力がメモリ、時間、お金を消費し、すぐにこの獣を撃つことをお勧めしますなぜなら </font><font style="vertical-align: inherit;">彼はテナントではありません。</font><font style="vertical-align: inherit;">この悲しいことに、私たちは仕様を延期し、私の練習に少し向けます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
むかしむかし、非常に遠く離れたプロジェクトで、データベースからデータを取得するためのロジックを含むクラスがコードにありました。</font><font style="vertical-align: inherit;">彼らはこのように見えました：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ICharacterDal</span><font></font>
{<font></font>
  <span class="hljs-function">IEnumerable&lt;Character&gt; <span class="hljs-title">GetCharactersCreatedAfter</span>(<span class="hljs-params">DateTime date</span>)</span>;
  <span class="hljs-function">IEnumerable&lt;Character&gt; <span class="hljs-title">GetCharactersCreatedBefore</span>(<span class="hljs-params">DateTime date</span>)</span>;
  <span class="hljs-function">IEnumerable&lt;Character&gt; <span class="hljs-title">GetCharactersCreatedBetween</span>(<span class="hljs-params">DateTime <span class="hljs-keyword">from</span>, DateTime to</span>)</span>;<font></font>
  ...<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてそれらの使用：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> dal = <span class="hljs-keyword">new</span> CharacterDal();
<span class="hljs-keyword">var</span> createdCharacters = dal.GetCharactersCreatedAfter(<span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2020</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスの内部には、DBMSを操作するためのロジックがありました（当時はADO.NETでした）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが良いように見えましたが、プロジェクトの拡大に​​伴い、これらのクラスも成長し、保守が困難なオブジェクトになりました。</font><font style="vertical-align: inherit;">さらに、不快な後味がありました。これはビジネスルールのようですが、特定の実装に関連付けられているため、インフラストラクチャレベルで保存されていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは</font><font style="vertical-align: inherit;">、すべてのルールをドメインレイヤーに直接適用できる</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IQueryable &lt;T&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リポジトリに置き換えられました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IRepository</span>&lt;T&gt;<font></font>
{<font></font>
  <span class="hljs-function">T <span class="hljs-title">Get</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> id</span>)</span>;
  <span class="hljs-function">IQueryable&lt;T&gt; <span class="hljs-title">List</span>(<span class="hljs-params"></span>)</span>;
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span>(<span class="hljs-params">T obj</span>)</span>;
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Save</span>(<span class="hljs-params">T obj</span>)</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは次のように使用されました：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> repository = <span class="hljs-keyword">new</span> Repository();
<span class="hljs-keyword">var</span> targetDate = <span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2020</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">var</span> createdUsers = <span class="hljs-keyword">await</span> repository.List().Where(x =&gt; x.CreatedAd &gt; targetDate).ToListAsync();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう少し良いですが、問題は、ルールがコードに沿って移動し、同じチェックが何百もの場所で発生する可能性があることです。また、要件が変更されたときに何が発生するのかを簡単に想像できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは別の問題を隠します-クエリを具体化しない場合、つまり、1つではなく複数のデータベースクエリを実行する可能性があり、これはもちろんシステムパフォーマンスに悪影響を及ぼします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、このプロジェクトの1つで、1人の同僚が</font><font style="vertical-align: inherit;">、式ツリーに基づく「仕様」パターンの実装を提案</font><font style="vertical-align: inherit;">する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用することを提案しました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、このライブラリに基づいて、エンティティのフィルターを作成し、単純なルールの連結に基づいてより複雑なフィルターを構築できる仕様を撮影しました。たとえば、新年の後に作成された文字の仕様があり、特定のアイテムを持つ文字を選択するための仕様があります。これらのルールを組み合わせることにより、新年の後に作成され、指定されたアイテムを持つ文字のリストのリクエストを作成できます。また、将来、新しい文字を決定するためのルールを変更する場合（たとえば、中国の新年の日付を使用する場合）は、仕様自体でのみ修正するため、このロジックのすべての使用をコードで探す必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロジェクトは成功裏に完了し、このアプローチを使用した経験は非常に成功しています。</font><font style="vertical-align: inherit;">しかし、私はじっと立ちたくないので、次のような実装に問題がありました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレーターORを接着できませんでした。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユニオンはWhereなどのフィルターを含むクエリでのみ機能しますが、より豊富なルール（クエリのネスト、スキップ/テイク、プロジェクション）が必要でした。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕様コードは選択したORMに依存していました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ORM機能を使用することはできませんでした。</font><font style="vertical-align: inherit;">これにより、依存関係がビジネスロジックのレイヤーに含まれるようになりました（たとえば、フェッチを実行できませんでした）。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの問題を解決した結果が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Singularis.Secification</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ミニフレームワーク</font><font style="vertical-align: inherit;">であり、いくつかのアセンブリで構成されています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Singularis.Specification.Definition-仕様オブジェクトを定義し、ルールの形成に使用されるIQueryインターフェイスも含まれます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Singularis.Specification.Executor。*-特定のORMの仕様を実行するためのリポジトリとオブジェクトを実装します（現在、ef.coreとNHibernateでサポートされています。実験の一環として、mongodbの実装も行いましたが、このコードは本番環境にはありませんでした）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装を詳しく見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仕様インターフェイスは、仕様ルールに含まれるパブリックプロパティを定義します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ISpecification</span><font></font>
{<font></font>
  IQuery Query { <span class="hljs-keyword">get</span>; }<font></font>
  Type ResultType { <span class="hljs-keyword">get</span>; }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ISpefication</span>&lt;T&gt;: <span class="hljs-title">ISpecification</span><font></font>
{<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、インターフェースには</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ResultType</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティが含まれ</font><font style="vertical-align: inherit;">、クエリの結果として取得されたエンティティのタイプを返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その実装は</font><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">ResultType</font></i><font style="vertical-align: inherit;">プロパティを実装</font><font style="vertical-align: inherit;">する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕様&lt;T&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">に含まれ、</font><font style="vertical-align: inherit;">Queryに格納されているルールに基づいて計算されるほか、</font><i><font style="vertical-align: inherit;">Source（）</font></i><font style="vertical-align: inherit;">と</font><i><font style="vertical-align: inherit;">Source &lt;TSource&gt;（）の</font></i><font style="vertical-align: inherit;"> 2つのメソッドに基づいて計算され</font><font style="vertical-align: inherit;">ます。これらのメソッドは、ルールのソースを形成するのに役立ちます。</font><i><font style="vertical-align: inherit;">Source（）</font></i><font style="vertical-align: inherit;">は、仕様クラスの引数と一致するタイプのルールを作成します</font><i><font style="vertical-align: inherit;">。Source&lt;TSource&gt;（）を</font></i><font style="vertical-align: inherit;">使用すると、（ネストされたクエリを生成するときに使用される）任意のクラスのルールを作成できます。</font><font style="vertical-align: inherit;">
さらに、別のクラスがあります</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SpecificationExtensionには</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、リクエストをチェーンするための拡張メソッドが含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのタイプの結合がサポートされています。連結（「AND」条件による結合と見なすことができます）と「OR」条件による結合です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例に戻り、2つのルールを実装してみましょう。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CreatedAfter</span>: <span class="hljs-title">Specification</span>&lt;Character&gt;<font></font>
{<font></font>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CreatedAfter</span>(<span class="hljs-params">DateTime target</span>)</span><font></font>
  {<font></font>
       Query = Source().Where(x =&gt; x.CreatedAt &gt; target);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CreatedBefore</span>: <span class="hljs-title">Specification</span>&lt;Character&gt;<font></font>
{<font></font>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CreatedBefore</span>(<span class="hljs-params">DateTime target</span>)</span><font></font>
  {<font></font>
    Query = Source().Where(x =&gt; x.CreatedAt &lt; target);<font></font>
<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
両方のルールを満たすすべてのユーザーを見つけます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> specification = <span class="hljs-keyword">new</span> CreatedAfter(<span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2019</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>).Combine(<span class="hljs-keyword">new</span> CreatedBefore(<span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2020</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>));
<span class="hljs-keyword">var</span> users = repository.List(specification);
</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combine</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
メソッドと組み合わせると、</font><font style="vertical-align: inherit;">任意のルールがサポートされます。主なことは、結果の左側の型が右側の入力型と一致することです。したがって、プロジェクションを含むルールを作成し、ページネーションのスキップ/テイク、ソートルール、フェッチなどを行うことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Orルールはより制限されています-Whereフィルタリング条件を含むチェーンのみをサポートします。例の使用を検討してください。2000年以前または2020年以降に作成されたすべての文字が見つかります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> specification = <span class="hljs-keyword">new</span> CreatedAfter(<span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2020</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>).Or(<span class="hljs-keyword">new</span> CreatedBefore(<span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>));
<span class="hljs-keyword">var</span> users = repository.List(specification );
</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IQuery</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
インターフェイスは</font><font style="vertical-align: inherit;">主に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IQueryable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェイスを繰り返します</font><font style="vertical-align: inherit;">。そのため、特別な質問はありません。特定の方法のみを説明します</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。Fetch/ ThenFetch-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適化のために、生成されたクエリに関連データを含めることができます。もちろん、ビジネスルールに影響を与えるインフラストラクチャの実装の機能がある場合、これは少し曲がっていますが、先ほど述べたように、現実は厳格で純粋な抽象化です。これはかなり理論的なものです。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IQUERYは、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この方法の2つのオーバーロードを宣言し、一つの形式でフィルタリングするためだけラムダ式をとる</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のFunc &lt;T、BOOL &gt;&gt; &lt;式</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、及び第二にも追加のパラメータを取り</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IQueryContext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネストされたサブクエリを実行できます。</font><font style="vertical-align: inherit;">例を考えてみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルにReadCharacterクラスがあります。モデルが非正規化データを含み、迅速なフィードバックに役立つ読み取り部分として提示され、リンク、正規化データなどを含む書き込み部分として提示されると仮定します。</font><font style="vertical-align: inherit;">ユーザーが特定のドメインにメールを持っているすべての文字を表示したい。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CharactersForUserWithEmailDomain</span>: <span class="hljs-title">Specification</span>&lt;ReadCharacter&gt;<font></font>
{<font></font>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CharactersForUserWithEmailDomain</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> domain</span>)</span><font></font>
  {<font></font>
    <span class="hljs-keyword">var</span> usersQuery = Source&lt;User&gt;(x =&gt; x.Email.Contains(domain)).Projection(x =&gt; x.Id);<font></font>
    Query = Source().Where((x, ctx) =&gt; ctx.GetQueryResult&lt;<span class="hljs-keyword">int</span>&gt;(usersQuery).Contains(x.Id));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行の結果、次のSQLクエリが生成されます。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">select</span>
    readcharac0_.id <span class="hljs-keyword">as</span> id1_3_,<font></font>
    readcharac0_.UserId <span class="hljs-keyword">as</span> userid2_3_,<font></font>
    readcharac0_.Name <span class="hljs-keyword">as</span> name3_3_
<span class="hljs-keyword">from</span><font></font>
    ReadCharacters readcharac0_<font></font>
<span class="hljs-keyword">where</span>
    readcharac0_.UserId <span class="hljs-keyword">in</span> (
        <span class="hljs-keyword">select</span><font></font>
            user1_.Id<font></font>
        <span class="hljs-keyword">from</span>
            <span class="hljs-keyword">Users</span> user1_
        <span class="hljs-keyword">where</span>
            user1_.Email <span class="hljs-keyword">like</span> (<span class="hljs-string">'%'</span>+@p0+<span class="hljs-string">'%'</span>)<font></font>
    );<font></font>
@p0 = '@inmagna.ca' [Type: String (4000:0:0)]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべての素晴らしいルールを満たすために、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IRepository</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェイスが</font><i><font style="vertical-align: inherit;">定義されて</font></i><font style="vertical-align: inherit;">います。これにより、識別子でアイテムを受け取り、仕様に従ってオブジェクトのリスト（最初の適切なもの）またはオブジェクトのリストを受け取り、リポジトリからアイテムを保存および削除できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クエリの定義によって、私たちはそれを理解しましたが、今ではORMにこれを理解するように教える必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うために、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Singularis.Infrastructure.NHibernate</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のアセンブリを分析し</font><font style="vertical-align: inherit;">ます（ef.coreの場合、すべてが同じように見えますが、ef.coreの仕様のみが異なります）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データアクセスポイントは、</font><i><font style="vertical-align: inherit;">IRepository</font></i><font style="vertical-align: inherit;">インターフェイスを実装するRepositoryオブジェクト</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。識別子でオブジェクトを受け取る場合、およびストレージを変更する（保存/削除する）場合、このクラスはセッションを終了し、特定の実装をビジネスレイヤーから隠します。仕様を使用する場合</font><font style="vertical-align: inherit;">は、クエリを</font><i><font style="vertical-align: inherit;">IQuery</font></i><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">反映</font><font style="vertical-align: inherit;">する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IQueryable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクト</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">形成し、それを</font><font style="vertical-align: inherit;">セッションオブジェクトで実行します。</font><font style="vertical-align: inherit;">
主な魔法と最も醜いコードは、</font><i><font style="vertical-align: inherit;">IQuery</font></i><font style="vertical-align: inherit;">を</font><i><font style="vertical-align: inherit;">IQueryable</font></i><font style="vertical-align: inherit;"> -SpecificationExecutorに</font><font style="vertical-align: inherit;">変換するクラスにあります</font><font style="vertical-align: inherit;">。このクラスには、特定のORM（NHiberanteのEagerFetchingExtensionsMethods）のQueryableメソッドまたは拡張メソッドを呼び出す多くのリフレクションが含まれています。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このライブラリは私たちのプロジェクトで積極的に使用されています（正直に言うと、すでに更新されたライブラリがプロジェクトで使用されていますが、これらのすべての変更は徐々に公開されます）常に変更が加えられています。</font><font style="vertical-align: inherit;">ほんの数週間前に次のバージョンがリリースされ、非同期メソッドに切り替わり、バグはexecutor'eのef.coreで修正され、テストとサンプルが追加されました。</font><font style="vertical-align: inherit;">ライブラリにはエラーと最適化のための100か所が含まれている可能性があります。これは、メインプロジェクトの作業の枠組みの中でサイドプロジェクトとして生まれたので、改善のための提案を喜んで提案します。</font><font style="vertical-align: inherit;">さらに、急いでそれを使用するべきではありません-あなたの特定のケースでは、これは不要であるか、または適用されないでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
説明されているソリューションを使用する価値があるのはいつですか？</font><font style="vertical-align: inherit;">「いつすべきでないか」という質問から始める方がおそらく簡単です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highload-高いパフォーマンスが必要な場合、ORM自体を使用すると問題が発生します。</font><font style="vertical-align: inherit;">もちろん、クエリをSQLに変換して実行するエグゼキュータを実装することを禁じている人はいませんが...</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常に小さなプロジェクト-これは非常に主観的ですが、ORMと付随する動物園全体を「todoリスト」プロジェクトに引き込むのは、大砲からスズメを撃つように見えることを認めなければなりません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いずれにせよ、最後まで読書をマスターした人-あなたの時間をありがとう。</font><font style="vertical-align: inherit;">今後の開発のためのフィードバックを期待しています！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はほとんど忘れていました-プロジェクトコードはGitHub'eで入手できます-https </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">://github.com/SingularisLab/singularis.specification</font></font></a><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブリはnugetからダウンロードできます</font></font></b><div class="spoiler_text"> <ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">https://www.nuget.org/packages/Singularis.Specification.Definition/</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">https://www.nuget.org/packages/Singularis.Specification.Executor.EntityFramework/</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">https://www.nuget.org/packages/Singularis.Specification.Executor.Common/</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">https://www.nuget.org/packages/Singularis.Specification.Executor.Nhibernate/ </a></li>
</ul></div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja485316/index.html">すべてのGoogle SERPが広告のように見える</a></li>
<li><a href="../ja485318/index.html">Jupyter Notebookに美しさとインタラクティブ機能を追加する</a></li>
<li><a href="../ja485322/index.html">PostgreSQLについて話します。Zinc ProdポッドキャストでのAlexei Lesovskyへのインタビュー。パート1</a></li>
<li><a href="../ja485324/index.html">Qtウィジェットのマルチスレッド</a></li>
<li><a href="../ja485326/index.html">Angular要素を使用したマイクロフロントエンドの作成：初心者向けガイド</a></li>
<li><a href="../ja485330/index.html">ローグライクゲームで魂のないランダムを倒す方法</a></li>
<li><a href="../ja485334/index.html">セッション投票</a></li>
<li><a href="../ja485336/index.html">ITMOユニバーシティの内容：講義、マスタークラス、コンテスト、エンターテイメントイベント</a></li>
<li><a href="../ja485338/index.html">恐怖を克服してAzure Machine Learningを使い始める方法</a></li>
<li><a href="../ja485342/index.html">数学とコンピューターサイエンスの分野で2019年はいかがでしたか？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>