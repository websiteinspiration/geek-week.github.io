<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✌🏾 🤪 🐎 古典的なA / Bテストとブートストラップ法に基づく共食いの計算 🖖🏼 🈴 🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事では、クラシックA / Bテストに基づいてモバイルアプリケーションの共食いを計算する方法について説明します。この場合、ターゲットアクションは、広告が無効にされたグループのターゲットアクションと比較して、広告ソース（Direct、Criteo、AdWords UACなど）からの再帰属プロセスの...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>古典的なA / Bテストとブートストラップ法に基づく共食いの計算</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451488/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事では、クラシックA / Bテストに基づいてモバイルアプリケーションの共食いを計算する方法について説明します。この場合、ターゲットアクションは、広告が無効にされたグループのターゲットアクションと比較して、広告ソース（Direct、Criteo、AdWords UACなど）からの再帰属プロセスの一部として考慮および評価されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、独立したサンプルを簡単な理論的根拠と比較するための古典的な方法の概要と、使用するライブラリーについて説明します。ブートストラップメソッドの本質とFaceBook Bootstrappedライブラリでのその実装、およびこれらの手法を適用するときに実際に発生する問題とその解決方法について簡単に説明します。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
証拠は、機密保持契約を維持するために難読化されているか、提供されていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将来的には、新しい事実が現れたときにこの記事を補足して少し変更する予定です。そのため、このバージョンは最初のリリースと見なすことができます。</font><font style="vertical-align: inherit;">コメントとレビューに感謝します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h3> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
共食いとは、あるチャネルから別のチャネルにトラフィックを完全かつターゲットを絞って流すプロセスです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マーケティング担当者は通常、この指標をCPAの計算における追加のK係数として使用します。計算されたCPAには1 + Kが乗算されます。この場合、CPAは、トラフィックを引き付けるための総コスト/直接収益化された、つまり、ターゲットコールなどの実際の利益をもたらした、および/または間接的に収益化されたターゲットアクションの数を意味します-たとえば、広告データベースのボリュームの増加、オーディエンスの増加など。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
無料チャンネル（たとえば、オーガニックSERPからの訪問、無料で使用できるサイト上のリンクのクリック）が有料で共食いしている場合（直接、オーガニックの代わりにAdWords、広告をクリックするのではなくソーシャルネットワークのフィードに広告を掲載すると無料）グループに配置されるなど）、これには金銭的損失のリスクが伴うため、共食い率を知ることが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの場合、タスクは、Criteo広告ネットワークからの遷移による、アプリケーションへの「有機」遷移の共食いを計算することでした。</font><font style="vertical-align: inherit;">監視は、デバイスまたはユーザーuid（GAID / ADVIDおよびIDFA）です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実験準備</font></font></h3> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AdJust分析システムのユーザーをグループに分け、特定の広告ネットワーク（コントロールサンプル）から広告を表示するユーザーと、GAIDまたはADVIDとIDFAを使用して広告を表示しないユーザーをそれぞれ分離することで、実験用のオーディエンスを準備できます。 （AdJustはAudience Builder APIを提供します）。次に、コントロールサンプルで、実験で調査した広告ネットワークに広告キャンペーンを含めることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は、直感的に見えるように、この場合、次の実験の方がより有能であることを私は覚えています：4つのグループを選択すること-すべてのチャネル（1）からリターゲティングを無効にしたグループ、実験グループ、およびCriteo（2）で有効になっているリターゲットのみ。 Criteoでリターゲティングのみを無効にした人（3）、すべてのリターゲティング（4）をオンにした人。次に、（1）/（2）、アプリケーションへの「オーガニック」な移行のCriteoネットワーク広告キャンペーンによる共食いの実際の値を受け取り、（3）/（4）「自然な」環境でのCriteoの共食いを受け取った（結局、Criteo、明らかに）他の有料チャンネルも共食いできます）。他の広告ネットワークについても、それぞれの影響を調べるために同じ実験を繰り返す必要があります。理想的な世界では、総トラフィックで最大のシェアを占めるすべての主要な有料ソース間の人食いを調査するのは良いことですが、それは非常に時間がかかります（開発の観点からの実験の準備と結果の評価の両方）。不合理な細かさに対する批判。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、私たちの実験は（3）と（4）の条件で行われ、サンプルは10％から90％の比率で分割され、実験は2週間行われました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データの準備と検証</font></font></h3> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
調査を始める前に、重要なステップは有能な事前トレーニングとデータのクリーニングです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、実験中のアクティブなデバイスの数は、完全なソースサンプルのデバイスよりも2倍少ない（それぞれ、コントロールグループと実験グループの42.5％と50％）であり、これはデータの性質によって説明されます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まず（これが主な理由です）、Adjustからの再ターゲットの選択には、これまでにアプリケーションをインストールしたすべてのデバイス、つまり、使用されなくなったデバイスと、アプリケーションがすでに使用されていたデバイスの識別子が含まれます削除された</font></font></li>
<li>-, ,           . </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、完全なサンプルのデータに基づいて共食いを計算しました。私個人としては、そのような計算の正しさは依然として問題点のようです-一般的に、私の意見では、アプリケーションをアンインストールして対応するタグでインストールしなかったすべての人と、1年以上アプリケーションにログインしていない人を一掃するほうが正しいでしょう-この期間、ユーザーはデバイスを変更できます。マイナス-このようにして、実験では、アプリケーションに切り替えなかったが実行できたユーザーは、Criteoネットワークに広告を表示していれば、選択から削除できます。良い世界では、これらの強制された怠慢と仮定はすべて個別に調査して検証する必要がありますが、私たちはそれを速くて毛皮のような世界に住んでいます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、次の点を確認することが重要です。</font></font><br>
<br>
<ol>
<li>       —   .         ,            .          ,   ,       .     &gt; 1%,         ,   .</li>
<li>,        —        retargeting (   Criteo,     —   ),       DeviceID    retargeting'  Criteo.    DeviceID        retargeting,     1%,   . </li>
</ol><br>
<h3>  </h3> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
絶対-呼び出しの数、および相対-コントロール（Criteoネットワークで広告を見た）グループおよび実験的（広告が無効にされた）グループのユーザーあたりの呼び出し数の変更を考慮します。</font><font style="vertical-align: inherit;">以下のコードでは、変数dataは、実験または制御サンプルの結果から形成されるpandas.DataFrame構造を参照しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関連のないサンプルの値の差の統計的有意性を評価するためのパラメトリックおよびノンパラメトリックな方法があります。</font><font style="vertical-align: inherit;">パラメトリック評価基準は精度が高くなりますが、アプリケーションに制限があります。特に、主な条件の1つは、サンプルの観測値の測定値が正規分布であることです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.正規性のサンプルにおける値の分布の研究</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のステップは、標準テスト-sklearn.statsライブラリーに実装されたKolmogorov-SmirnovおよびShapiro-Wilks基準とBartlett基準を使用して、値の分布とサンプルの分散の等価性について既存のサンプルを調べることです（p値= 0.05）：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#    :</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">norm_test</span>(<span class="hljs-params">df, pvalue = <span class="hljs-number">0.05</span>, test_name = <span class="hljs-string">'kstest'</span></span>):</span>
	<span class="hljs-keyword">if</span> test_name == <span class="hljs-string">'kstest'</span>:<font></font>
st = stats.kstest(df, <span class="hljs-string">'norm'</span>) 
	<span class="hljs-keyword">if</span> test_name == <span class="hljs-string">'shapiro'</span>:<font></font>
		st = stats.shapiro(df)<font></font>
	sys.stdout.write(<span class="hljs-string">'According to {} {} is {}normal\n'</span>.format(test_name, df.name, {<span class="hljs-literal">True</span>:<span class="hljs-string">'NOT '</span>, <span class="hljs-literal">False</span>:<span class="hljs-string">''</span>}[st[<span class="hljs-number">1</span>] &lt; pvalue])) <font></font>
<font></font>
<span class="hljs-comment">#    :</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">barlett_test</span>(<span class="hljs-params">df1, df2, pvalue = <span class="hljs-number">0.05</span></span>):</span><font></font>
    st = stats.bartlett(df1, df2)<font></font>
    sys.stdout.write(<span class="hljs-string">'Variances of {} and {} is {}equals\n'</span>.format(df1.name, df2.name, {<span class="hljs-literal">True</span>:<span class="hljs-string">'NOT '</span>, <span class="hljs-literal">False</span>:<span class="hljs-string">''</span>}[st[<span class="hljs-number">1</span>] &lt; pvalue]))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、結果を視覚的に評価するために、ヒストグラム構築関数を使用できます。</font></font><br>
<br>
<pre><code class="python hljs">data_agg = data.groupby([<span class="hljs-string">'bucket'</span>]).aggregate({<span class="hljs-string">'device_id'</span>: <span class="hljs-string">'nunique'</span>, <span class="hljs-string">'calls'</span>: <span class="hljs-string">'sum'</span>}).fillna(<span class="hljs-number">0</span>)<font></font>
data_conv = data_agg[<span class="hljs-string">'calls_auto'</span>]/data_agg[<span class="hljs-string">'device_id'</span>]<font></font>
data_conv.hist(bins=<span class="hljs-number">20</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/8m/zc/u4/8mzcu4-emautrimdpvczuttfkf8.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のようにヒストグラムを読み取ることができます。サンプルで10回、0.08、1-0.14の変換が行われました。</font><font style="vertical-align: inherit;">これは、変換インジケーターの観測値としてのデバイスの数については何も言いません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの場合、サンプルのパラメータ値の絶対値と相対値（デバイスへの呼び出し数）の両方の分布は正常ではありません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、標準のsklearn.statsライブラリに実装されているノンパラメトリックウィルコクソン検定を使用するか、サンプルの値の分布を正規形にして、パラメトリック基準の1つ（スチューデントの別名t検定またはShapiro-Wilks検定）を適用してみます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.サンプルの値の分布を正規形に減らす方法</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1。サブバケット</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
分布を正規化するアプローチの1つはサブバケット方式です。その本質は単純であり、次の数学的論文は理論的基礎です：古典的な中心極限定理によれば、平均の分布は正規になる傾向があります-n個の独立して同一に分布する確率変数の合計は正規に近い分布を持ち、同等に、最初のn個の独立して同一に分布するランダムのサンプル平均の分布数量は通常の傾向にあります。したがって、既存のバケットをサブバケットに分割できるため、バケットごとのサブバケットの平均値を取ると、通常に近い分布を得ることができます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#   subbucket'</span>
data[<span class="hljs-string">'subbucket'</span>] = data[<span class="hljs-string">'device_id'</span>].apply(<span class="hljs-keyword">lambda</span> x: randint(<span class="hljs-number">0</span>,<span class="hljs-number">1000</span>)) <span class="hljs-comment"># Variant 1</span>
data[<span class="hljs-string">'subbucket'</span>] = data[<span class="hljs-string">'device_id'</span>].apply(<span class="hljs-keyword">lambda</span> x: hash(x)%<span class="hljs-number">1000</span>) <span class="hljs-comment"># Variant 2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分割には多くのオプションがあり、すべては開発者の想像力と道徳的原則に依存します。正直なランダムを取るか、元のバケットからハッシュを使用して、スキームでそれを発行するメカニズムを考慮することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、実際には、数十回のコードの起動から、正規分布は1回しか受け取られませんでした。つまり、この方法は保証も安定もされていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、サブバケット内のアクションとユーザーの総数に対するターゲットアクションとユーザーの比率は、最初のバケットと一致しない場合があるため、比率が維持されていることを最初に確認する必要があります。</font></font><br>
<br>
<pre><code class="python hljs">data[data[<span class="hljs-string">'calls'</span>] &gt; <span class="hljs-number">0</span>].device_id.nunique()/data.device_id.nunique() <span class="hljs-comment"># Total</span><font></font>
<font></font>
buckets = data.groupby([<span class="hljs-string">'bucket'</span>]).aggregate({<span class="hljs-string">'device_id'</span>: <span class="hljs-string">'nunique'</span>, <span class="hljs-string">'calls'</span>: <span class="hljs-string">'sum'</span>})<font></font>
buckets[buckets[<span class="hljs-string">'calls'</span>] &gt; <span class="hljs-number">0</span>].device_id.nunique()/buckets.device_id.nunique() <span class="hljs-comment"># Buckets</span><font></font>
<font></font>
subbuckets = data.groupby([<span class="hljs-string">'subbucket'</span>]).aggregate({<span class="hljs-string">'device_id'</span>: <span class="hljs-string">'nunique'</span>, <span class="hljs-string">'calls'</span>: <span class="hljs-string">'sum'</span>}) subbuckets[subbuckets[<span class="hljs-string">'calls'</span>] &gt; <span class="hljs-number">0</span>].device_id.nunique()/subbuckets.device_id.nunique() <span class="hljs-comment"># Subbuckets</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような検証の過程で、元の選択に対するサブバケットの変換比率が保持されないことがわかりました。さらに、出力サンプルとソースサンプルの呼び出しの比率の一貫性を保証する必要があるため、クラスバランシングを使用して重み付けを追加し、データがサブグループによって個別に選択されるようにします。ターゲットアクションのある観測とは別に、ターゲットアクションのない観測とは適切な割合で別々に選択します。さらに、私たちの場合、サンプルは不均一に分布していました。直感的には、平均は変化してはならないようですが、サンプルの不均一性が分散にどのように影響するかは、分散式からは明らかではありません。サンプルサイズの違いが結果に影響を与えるかどうかを明確にするために、Xi二乗基準が使用されます-統計的に有意な違いが検出された場合、次に、小さいデータフレームのサイズの大きいデータフレームのサンプルが生成されます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">class_arrays_balancer</span>(<span class="hljs-params">df1, df2, target = <span class="hljs-string">'calls'</span>, pvalue=<span class="hljs-number">0.05</span></span>):</span>
    df1_target_size = len(df1[df1[target] &gt; <span class="hljs-number">0</span>])<font></font>
    print(df1.columns.to_list())<font></font>
    df2_target_size = len(df2[df2[target] &gt; <span class="hljs-number">0</span>])<font></font>
    total_target_size = df1_target_size + df2_target_size<font></font>
    chi2_target, pvalue_target, dof_target, expected_target = chi2_contingency([[df1_target_size, total_target_size], [df2_target_size, total_target_size]])<font></font>
    <font></font>
    df1_other_size = len(df1[df1[target] == <span class="hljs-number">0</span>])<font></font>
    df2_other_size = len(df1[df1[target] == <span class="hljs-number">0</span>])<font></font>
    total_other_size = df1_other_size + df2_other_size<font></font>
    chi2_other, pvalue_other, dof_other, expected_other = chi2_contingency([[df1_other_size, total_other_size], [df2_other_size, total_other_size]])<font></font>
    <font></font>
    df1_target, df2_target, df1_other, df2_other = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><font></font>
<font></font>
   <span class="hljs-keyword">if</span> pvalue_target &lt; pvalue:<font></font>
        sample_size = min([df1_target_size, df2_target_size])<font></font>
        df1_rnd_indx = np.random.choice(df1_target_size, size=sample_size, replace=<span class="hljs-literal">False</span>)<font></font>
        df2_rnd_indx = np.random.choice(df2_target_size, size=sample_size, replace=<span class="hljs-literal">False</span>)<font></font>
        df1_target = pd.DataFrame((np.asarray(df1[df1[target] == <span class="hljs-number">1</span>])[df1_rnd_indx]).tolist(), columns = df1.columns.tolist())<font></font>
        df2_target = pd.DataFrame((np.asarray(df2[df2[target] == <span class="hljs-number">1</span>])[df2_rnd_indx]).tolist(), columns = df2.columns.tolist())<font></font>
    <font></font>
    <span class="hljs-keyword">if</span> p_value_other &lt; pvalue:<font></font>
        sample_size = min([df1_other_size, df2_other_size])<font></font>
        df1_rnd_indx = np.random.choice(df1_other_size, size=sample_size, replace=<span class="hljs-literal">False</span>)<font></font>
        df2_rnd_indx = np.random.choice(df2_other_size, size=sample_size, replace=<span class="hljs-literal">False</span>)<font></font>
        df1_other = pd.DataFrame((np.asarray(df1[df1[target] == <span class="hljs-number">0</span>])[df1_rnd_indx]).tolist(), columns = df1.columns.tolist())<font></font>
        df2_other = pd.DataFrame((np.asarray(df2[df2[target] == <span class="hljs-number">0</span>])[df2_rnd_indx]).tolist(), columns = df2.columns.tolist())<font></font>
        <font></font>
    df1 = pd.concat([df1_target, df1_other])<font></font>
    df2 = pd.concat([df2_target, df2_other])<font></font>
        <font></font>
    <span class="hljs-keyword">return</span> df1, df2<font></font>
<font></font>
exp_classes, control_classes = class_arrays_balancer(data_exp, data_control)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出力では、サイズがバランスが取れており、初期の変換率と一致するデータが得られます。調査されたメトリック（サブバケットの平均値について計算されたもの）は、すでに正常に分布しており、視覚的にも、既知のテスト基準を適用した結果としても表示されます。正規性（p値&gt; = 0.05）。</font><font style="vertical-align: inherit;">たとえば、相対インジケーターの場合：</font></font><br>
<br>
<pre><code class="python hljs">data_conv = (data[data[<span class="hljs-string">'calls'</span>] &gt; <span class="hljs-number">0</span>].groupby([<span class="hljs-string">'subbucket'</span>]).calls.sum()*<span class="hljs-number">1.0</span>/data.groupby([<span class="hljs-string">'subbucket'</span>]).device_id.nunique())<font></font>
data_conv.hist(bins = <span class="hljs-number">50</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、t検定をサブバケットの平均に適用できます（したがって、それはdevice_idではなく、デバイスではなく、観測値として機能するサブバケットです）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変化が統計的に有意であることを確認した後、私たちは明確な良心を持って、私たちが始めたすべてのことを行うことができます-共食いの計算：</font></font><br>
<br>
<pre><code class="python hljs">(data_exp.groupby([<span class="hljs-string">'subbucket'</span>]).calls.avg() - data_cntrl.groupby([<span class="hljs-string">'subbucket'</span>]).calls.avg() )/ data_exp.groupby([<span class="hljs-string">'subbucket'</span>]).calls.avg()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分母は広告なしのトラフィック、つまり実験的なものでなければなりません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.ブートストラップ方式</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブートストラップ方式はサブバケット方式の拡張であり、より高度で改良されたバージョンを表します。このメソッドのPythonでのソフトウェア実装は、Facebookのブートストラップライブラリにあります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単に言うと、ブートストラップの概念は次のように説明できます。メソッドは、ランダムにサブバケットメソッドと同様の方法で生成されたサンプルのコンストラクターにすぎませんが、繰り返しが可能です。一般集団からの配置（元のサンプルを呼び出すことができる場合）は、リターンと言えます。出力では、生成された各サブサンプルの平均から平均（または中央値、量など）が形成されます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FaceBook Bootstrapライブラリの主なメソッド</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<pre><code class="python hljs">bootstrap()</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-サブサンプルの形成メカニズムを実装します。デフォルトでは、下限（5パーセンタイル）と上限（95パーセンタイル）を返します。この範囲の離散分布を返すには、パラメーター</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">return_distribution = True</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を設定する必要があります</font><font style="vertical-align: inherit;">（補助関数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generate_distributions（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって生成されます</font><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは使用して反復回数を指定することができます</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">num_iterationsの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータを</font><font style="vertical-align: inherit;">サブサンプルが生成される中で、および多数の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iteration_batch_size</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブサンプルを</font><font style="vertical-align: inherit;">反復ごと。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generate_distributions（）の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出力で</font><font style="vertical-align: inherit;">、サンプルは反復数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">num_iterations</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">等しいサイズで生成され</font><font style="vertical-align: inherit;">、その要素はサンプルの値の平均になります</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各</font><i><font style="vertical-align: inherit;">反復で</font></i><font style="vertical-align: inherit;">計算されるiteration_batch_size。サンプルサイズが大きいと、データがメモリに収まらなくなる可能性があるため、そのような場合は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iteration_batch_size</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の値を減らすことをお勧めし</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：元のサンプルを2,000,000にします。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">num_iterations</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 10,000、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iteration_batch_size</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> =300。次に、10,000回の反復ごとに、2,000,000項目の300リストがメモリに保存されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">num_threads</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメーターを使用して必要な数を設定し、複数のプロセッサーコア、複数のスレッドでの並列計算も可能にします</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs">bootstrap_ab()</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能全て同じアクション</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブートストラップ（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数は、上述した</font><font style="vertical-align: inherit;">、しかし、加えて、に規定する方法により、平均値の集合</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stat_funcを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も</font><i><font style="vertical-align: inherit;">行っ</font></i><font style="vertical-align: inherit;"> -の値から</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">num_iterations</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次に、compare_funcパラメーターで指定されたメトリックが計算され、統計的有意性が推定されます。</font></font><br>
<br>
<pre><code class="python hljs">compare_functions</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-評価のためのメトリックの形成のためのツールを提供する関数のクラス： </font></font><br>
<pre><code class="python hljs">compare_functions.difference()<font></font>
compare_functions.percent_change()<font></font>
compare_functions.ratio()<font></font>
compare_functions.percent_difference()<font></font>
<font></font>
<span class="hljs-comment"># difference = (test_stat - ctrl_stat)</span>
<span class="hljs-comment"># percent_change = (test_stat - ctrl_stat) * 100.0 / ctrl_stat</span>
<span class="hljs-comment"># ratio = test_stat / ctrl_stat</span>
<span class="hljs-comment"># percent_difference = (test_stat - ctrl_stat) / ((test_stat + ctrl_stat) / 2.0) * 100.0</span></code></pre><br>
<pre><code class="python hljs">stats_functions</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -調査対象の指標の集計方法を選択する関数のクラス：</font></font><br>
<pre><code class="python hljs">stats_functions.mean<font></font>
stats_functions.sum <font></font>
stats_functions.median<font></font>
stats_functions.std</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stat_func</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
として</font><font style="vertical-align: inherit;">、カスタムのユーザー定義関数を使用することもできます。次に例を示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_func</span>(<span class="hljs-params">test_stat, ctrl_stat</span>):</span>
    <span class="hljs-keyword">return</span> (test_stat - ctrl_stat)/test_stat<font></font>
<font></font>
bs.bootstrap_ab(test.values, control.values, <font></font>
                                   stats_functions.mean, <font></font>
                                   test_func, num_iterations=<span class="hljs-number">5000</span>, alpha=<span class="hljs-number">0.05</span>, <font></font>
                                   iteration_batch_size=<span class="hljs-number">100</span>, scale_test_by=<span class="hljs-number">1</span>, num_threads=<span class="hljs-number">4</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（test_stat-ctrl_stat）/ test_stat</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、共食いを計算するための式です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、実際の実験の目的で、最初に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bootstrap（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して分布を取得</font><font style="vertical-align: inherit;">し、t検定を使用してターゲットメトリックの差の統計的有意性を確認してから、必要な操作をそれらに適用できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法を使用して「良い」正規分布を取得する方法の例：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pc/is/ws/pciswsulv_wuinbcqkn-hgmluwe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
詳細なドキュメントは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、リポジトリページにあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現時点では、これが私が話したかった（またはなんとか）話したすべてです。</font><font style="vertical-align: inherit;">使用した方法とその実装プロセスを簡潔かつ明確に説明しようとしました。</font><font style="vertical-align: inherit;">方法論が調整を必要とする可能性があるので、フィードバックとレビューに感謝します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、この作業の準備に協力してくれた同僚にも感謝します。</font><font style="vertical-align: inherit;">記事が主に肯定的なフィードバックを受け取った場合、私はそれらの名前またはニックネームを（事前の合意により）ここに示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
皆さん、よろしくお願いします！</font><font style="vertical-align: inherit;">:) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PS </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dear Championship Channel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、A / Bテストの結果を評価するタスクは、データサイエンスで最も重要なものの1つです。A/ Bなしでは、本番環境で新しいMLモデルのリリースが1回しか完了しないためです。</font><font style="vertical-align: inherit;">A / Bテストの結果を評価するためのシステムを開発するための競争を組織する時がきたのでしょうか？</font><font style="vertical-align: inherit;">:)</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja451468/index.html">先週のフロントエンドの世界からの新鮮な食材のダイジェストNo.364（2019年5月6日〜12日）</a></li>
<li><a href="../ja451476/index.html">Goに関するLLVM</a></li>
<li><a href="../ja451478/index.html">パンダプロファイリングライブラリを使用したデータ探索の高速化</a></li>
<li><a href="../ja451480/index.html">なぜ産業貿易省は外国の機器のデータの保存を禁止するのですか？</a></li>
<li><a href="../ja451482/index.html">別の角度からの現代のプログラマーの能力</a></li>
<li><a href="../ja451492/index.html">7つの予期しないBash変数</a></li>
<li><a href="../ja451496/index.html">Mitap Netologii「初心者のためのデータサイエンスのキャリア」</a></li>
<li><a href="../ja451498/index.html">フードデザインダイジェスト、2019年4月</a></li>
<li><a href="../ja451502/index.html">5月13日から19日までのモスクワでのデジタルイベント</a></li>
<li><a href="../ja451504/index.html">ウェブ上の写真2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>