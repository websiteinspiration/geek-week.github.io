<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥋 👨‍🚒 🕛 ¿Cómo se visualiza la pantalla del mensaje VK? 🤳🏼 🍌 💃🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¿Qué está haciendo VK para reducir los retrasos de representación? ¿Cómo mostrar un mensaje muy grande y no matar a UiThread? ¿Cómo reducir los retras...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>¿Cómo se visualiza la pantalla del mensaje VK?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/501988/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué está haciendo VK para reducir los retrasos de representación? </font><font style="vertical-align: inherit;">¿Cómo mostrar un mensaje muy grande y no matar a UiThread? </font><font style="vertical-align: inherit;">¿Cómo reducir los retrasos de desplazamiento en RecyclerView? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vs/2s/jg/vs2sjg1iyfq7cdkohrmgpuy5mla.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mi experiencia se basa en el trabajo de dibujar una pantalla de mensaje en la aplicación VK de Android, en la que es necesario mostrar una gran cantidad de información con un mínimo de frenos en la interfaz de usuario. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
He estado programando para Android durante casi diez años, anteriormente era freelance para PHP / Node.js. </font><font style="vertical-align: inherit;">Ahora, un desarrollador senior de Android VKontakte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bajo el corte: video y transcripción de mi informe de la conferencia Mobius 2019 Moscú.</font></font><a name="habracut"></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GZkTwgetUWI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El informe revela tres temas.</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las soluciones estándar son los principios básicos de cómo funciona la pantalla de mensajes VK. </font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las soluciones no estándar son soluciones poco conocidas u originales que permiten minimizar los retrasos de la interfaz de usuario.</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las alternativas son sobre varias bibliotecas e implementaciones, así como por qué los desarrolladores de VK no las usaron.</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mira a la pantalla:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/he/h2/xj/heh2xjq-ij5pnzsu49cf11uuabu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este mensaje está en algún lugar en cinco pantallas. </font><font style="vertical-align: inherit;">Y bien pueden estar con nosotros (en el caso de reenviar mensajes). </font><font style="vertical-align: inherit;">Las herramientas estándar ya no funcionarán. </font><font style="vertical-align: inherit;">Incluso en un dispositivo superior, todo puede retrasarse. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno, además de esto, la interfaz de usuario en sí es bastante diversa:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fechas de carga e indicadores,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mensajes de servicio</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">texto (emoji, enlace, correo electrónico, hashtags),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">teclado bot</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">~ 40 formas de mostrar archivos adjuntos,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Árbol de mensajes reenviados.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Surge la pregunta: ¿cómo hacer que el número de rezagos sea lo más pequeño posible? </font><font style="vertical-align: inherit;">Tanto en el caso de mensajes simples como en el caso de mensajes masivos (caso marginal del video anterior).</font></font><br>
<a name="ordinary"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soluciones estandar</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecyclerView y sus complementos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay varios complementos para RecyclerView.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setHasFixedSize ( </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mucha gente piensa que esta bandera es necesaria cuando los elementos de la lista son del mismo tamaño. </font><font style="vertical-align: inherit;">Pero, de hecho, a juzgar por la documentación, lo contrario es cierto. </font><font style="vertical-align: inherit;">Esto es cuando el tamaño de RecyclerView es constante e independiente de los elementos (aproximadamente, no wrap_content). </font><font style="vertical-align: inherit;">Establecer la bandera ayuda a aumentar ligeramente la velocidad de RecyclerView para evitar cálculos innecesarios.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setNestedScrollingEnabled ( </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Optimización menor que deshabilita la compatibilidad con NestedScroll. </font><font style="vertical-align: inherit;">No tenemos CollapsingToolbar u otras funciones que dependen de NestedScroll en esta pantalla, por lo que podemos configurar este indicador de forma segura en falso.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setItemViewCacheSize ( </font></font><code>cache_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Configuración de la memoria caché interna RecyclerView. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mucha gente piensa que la mecánica de RecyclerView es:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hay un ViewHolder en la pantalla;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hay un RecycledViewPool que almacena ViewHolder;</font></font></li>
<li> ViewHolder    —    RecycledViewPool.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la práctica, todo es un poco más complicado, porque hay una caché intermedia entre estas dos cosas. </font><font style="vertical-align: inherit;">Se llama ItemViewCache. </font><font style="vertical-align: inherit;">¿Cuál es su esencia? </font><font style="vertical-align: inherit;">Cuando ViewHolder abandona la pantalla, no se coloca en RecycledViewPool, sino en el caché intermedio (ItemViewCache). </font><font style="vertical-align: inherit;">Todos los cambios en el adaptador se aplican tanto a ViewHolder visible como a ViewHolder dentro de ItemViewCache. </font><font style="vertical-align: inherit;">Y para ViewHolder dentro de RecycledViewPool, los cambios no se aplican. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A través de setItemViewCacheSize podemos establecer el tamaño de este caché intermedio. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuanto más grande sea, más rápido será el desplazamiento en distancias cortas, pero las operaciones de actualización tomarán más tiempo (debido a ViewHolder.onBind, etc.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cómo se implementa RecyclerView y cómo se estructura su caché es un tema bastante amplio y complejo. </font><font style="vertical-align: inherit;">Puedes leer un gran </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">articulo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, donde hablan en detalle sobre todo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimización OnCreate / OnBind</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra solución clásica es optimizar onCreateViewHolder / onBindViewHolder:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diseño sencillo (intentamos usar FrameLayout o Custom ViewGroup tanto como sea posible),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">las operaciones pesadas (análisis de enlaces / emoji) se realizan de forma asíncrona en la etapa de carga de mensajes,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StringBuilder para formatear nombre, fecha, etc.,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y otras soluciones que reducen el tiempo de trabajo de estos métodos.</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adaptador de seguimiento.onFailedToRecyclerView ()</font></font></h3><br>
<img src="https://habrastorage.org/webt/8l/eo/1n/8leo1nki7gxrit4wg8mhhv0q3ua.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tiene una lista en la que algunos elementos (o parte de ellos) están animados con alfa. </font><font style="vertical-align: inherit;">En el momento en que View, estando en proceso de animación, abandona la pantalla, no se dirige a RecycledViewPool. </font><font style="vertical-align: inherit;">¿Por qué? </font><font style="vertical-align: inherit;">RecycledViewPool ve que la Vista ahora está animada por el indicador View.hasTransientState, y simplemente la ignora. </font><font style="vertical-align: inherit;">Por lo tanto, la próxima vez que se desplace hacia arriba y hacia abajo, la imagen no se tomará de RecycledViewPool, sino que se creará de nuevo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La decisión más correcta es cuando ViewHolder abandona la pantalla, debe cancelar todas las animaciones. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-7/1r/rh/-71rrhbw5idwburnf60gtfllcau.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si necesita una revisión tan pronto como sea posible o si es un desarrollador perezoso, en el método onFailedToRecycle simplemente puede devolver verdadero y todo funcionará, pero no recomendaría hacerlo.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/iu/se/ha/iusehamefbgzcvc6miixbtfmfoy.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seguimiento de sobregiro y perfilador</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La forma clásica de detectar problemas es el sobregiro y el seguimiento del generador de perfiles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobregiro: el número de redibujos del píxel: cuantas menos capas y menos redibujado el píxel, más rápido. Pero según mis observaciones, en las realidades modernas, esto no afecta tanto el rendimiento. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/0h/-d/fh/0h-dfhogberhs_hsy1eseaexkwa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Profiler: también conocido como Android Monitor, que se encuentra en Android Studio. En él, puede analizar todos los métodos llamados. Por ejemplo, abra los mensajes, desplácese hacia arriba y hacia abajo y vea qué métodos se llamaron y cuánto tardaron. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dz/la/wy/dzlawyqmpqtzxbnpcbezvfoq_ww.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo lo que está en la mitad izquierda son las llamadas al sistema Android que se necesitan para crear / renderizar una Vista / ViewHolder. No podemos influir en ellos o tendremos que dedicar mucho esfuerzo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La mitad derecha es nuestro código que se ejecuta en ViewHolder.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El bloque de llamadas en el número 1 es una llamada a expresiones regulares: en algún lugar pasaron por alto y olvidaron transferir la operación al subproceso de fondo, lo que ralentizó el desplazamiento en ~ 20%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Llame al bloque en el número 2 - Fresco, una biblioteca para mostrar imágenes. </font><font style="vertical-align: inherit;">No es óptimo en algunos lugares. Todavía no está claro qué hacer con este retraso, pero si podemos resolverlo, ahorraremos otro ~ 15%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es decir, al solucionar estos problemas, podemos obtener un aumento de ~ 35%, lo cual es bastante bueno.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferido</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muchos de ustedes usan DiffUtil en su forma estándar: hay dos listas: cambios llamados, comparados e impulsados. Hacer todo esto en el hilo principal es un poco costoso porque la lista puede ser muy grande. Por lo general, el cálculo de DiffUtil se ejecuta en un hilo de fondo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ListAdapter y AsyncListDiffer hacen esto por usted. El ListAdapter extiende el adaptador normal e inicia todo de forma asincrónica: solo haga un submitList y el cálculo completo de los cambios se traslada al hilo interno de fondo. ListAdapter puede tener en cuenta el caso de actualizaciones frecuentes: si lo llama tres veces seguidas, solo tomará el último resultado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DiffUtil se utiliza solo para algunos cambios estructurales: la apariencia del mensaje, su cambio y eliminación. </font><font style="vertical-align: inherit;">Para algunos datos de cambio rápido, no es adecuado. </font><font style="vertical-align: inherit;">Por ejemplo, cuando subimos una foto o reproducimos audio. </font><font style="vertical-align: inherit;">Tales eventos ocurren a menudo, varias veces por segundo, y si ejecuta DiffUtil cada vez, obtendrá mucho trabajo adicional.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animaciones</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Había una vez un marco de animación, bastante escaso, pero todavía algo. </font><font style="vertical-align: inherit;">Trabajamos con él así:</font></font><br>
<br>
<pre><code class="java hljs">view.startAnimation(TranslateAnimation(fromX = <span class="hljs-number">0</span>, toX = <span class="hljs-number">300</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema es que el parámetro getTranslationX () devolverá el mismo valor antes y después de la animación. </font><font style="vertical-align: inherit;">Esto se debe a que la animación cambió la representación visual, pero no cambió las propiedades físicas. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/f0/uu/tw/f0uutwhihhopkcfvps8itszyt_a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Android 3.0, apareció el marco Animator, que es más correcto porque cambió la propiedad física específica del objeto. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q2/ib/qy/q2ibqywrlcla5cxqpslznxbxxm0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Más tarde, ViewPropertyAnimator apareció y todos todavía no entienden su diferencia con Animator. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo explicaré. </font><font style="vertical-align: inherit;">Digamos que necesita hacer la traducción en diagonal: cambie la vista a lo largo de los ejes x, y. </font><font style="vertical-align: inherit;">Lo más probable es que escriba un código típico:</font></font><br>
<br>
<pre><code class="java hljs">val animX = ObjectAnimator.ofFloat(view, “translationX”, <span class="hljs-number">100f</span>)<font></font>
val animY = ObjectAnimator.ofFloat(view, “translationY”, <span class="hljs-number">200f</span>)<font></font>
AnimatorSet().apply {<font></font>
    playTogether(animX, animY)<font></font>
    start()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y puedes hacerlo más corto:</font></font><br>
<br>
<pre><code class="java hljs">view.animate().translationX(<span class="hljs-number">100f</span>).translationY(<span class="hljs-number">200f</span>) </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando ejecuta view.animate (), inicia implícitamente ViewPropertyAnimator. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Por qué es necesario?</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Más fácil de leer y mantener el código.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animación de operaciones por lotes.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestro último caso, cambiamos dos propiedades. Cuando hacemos esto a través de animadores, los ticks de animación se llamarán por separado para cada Animador. Es decir, setTranslationX y setTranslationY se llamarán por separado, y View realizará las operaciones de actualización por separado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el caso de ViewPropertyAnimator, el cambio se produce al mismo tiempo, por lo que hay un ahorro debido a menos operaciones y el cambio en las propiedades en sí está mejor optimizado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede lograr esto con Animator, pero tendrá que escribir más código. </font><font style="vertical-align: inherit;">Además, con ViewPropertyAnimator, puede estar seguro de que las animaciones se optimizarán tanto como sea posible. </font><font style="vertical-align: inherit;">¿Por qué? </font><font style="vertical-align: inherit;">Android tiene un RenderNode (DisplayList). </font><font style="vertical-align: inherit;">En términos generales, almacenan en caché el resultado de onDraw y lo usan al volver a dibujar. </font><font style="vertical-align: inherit;">ViewPropertyAnimator trabaja directamente con RenderNode y le aplica animaciones, evitando llamadas onDraw. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muchas propiedades de Vista también pueden afectar directamente el RenderNode, pero no todas. </font><font style="vertical-align: inherit;">Es decir, cuando usa ViewPropertyAnimator, tiene la garantía de usar la forma más eficiente. </font><font style="vertical-align: inherit;">Si de repente tienes algún tipo de animación que no se puede hacer con ViewPropertyAnimator, entonces quizás deberías pensarlo y cambiarlo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animaciones: TransitionManager</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo general, las personas asocian que este marco se usa para pasar de una Actividad a otra. De hecho, se puede usar de manera diferente y simplificar enormemente la implementación de la animación de los cambios estructurales. Supongamos que tenemos una pantalla en la que se reproduce un mensaje de voz. Lo cerramos con una cruz, y el dado sube. ¿Cómo hacerlo? La animación es bastante complicada: el jugador cierra con alfa, mientras se mueve no a través de la traducción, sino que cambia su altura. Al mismo tiempo, nuestra lista sube y también cambia la altura. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mv/ff/kh/mvffkhe5udzkypeumimmusvhiig.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si el jugador fuera parte de la lista, entonces la animación sería bastante simple. Pero con nosotros, el jugador no es un elemento de la lista, sino una Vista completamente independiente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quizás comenzaríamos a escribir algún tipo de Animator, luego encontraríamos problemas, fallas, comenzaríamos a cortar muletas y duplicaríamos el código. </font><font style="vertical-align: inherit;">Y obtendría algo como la pantalla de abajo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wd/0d/k-/wd0dk-urz2lfr6xugvvpmp16rdk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con TransitionManager, puede simplificar todo:</font></font><br>
<br>
<pre><code class="java hljs">TransitionManager.beginDelayedTransition(<font></font>
        viewGroup = &lt;LinearLayoutManager&gt;,<font></font>
        transition = AutoTransition())<font></font>
playerView.visibility = View.GONE</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toda la animación ocurre automáticamente debajo del capó. </font><font style="vertical-align: inherit;">Parece mágico, pero si profundiza y ve cómo funciona, resulta que TransitionManager simplemente se suscribe a todas las vistas, captura los cambios en sus propiedades, calcula diff, crea los animadores necesarios o ViewPropertyAnimator cuando es necesario, y hace todo lo más eficientemente posible. </font><font style="vertical-align: inherit;">TransitionManager nos permite hacer animaciones en la sección de mensajes de forma rápida y fácil de implementar.</font></font><a name="extrodinary"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soluciones personalizadas</font></font></h2><br>
<img src="https://habrastorage.org/webt/u2/rx/ji/u2rxjicmid-zkuhvqsxc4kxbeem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto es lo más fundamental en el que se basan el rendimiento y los problemas que siguen. ¿Qué hacer cuando su mensaje está en 10 pantallas? Si presta atención, todos nuestros elementos se encuentran exactamente uno debajo del otro. Si aceptamos que ViewHolder no es un solo mensaje, sino docenas de ViewHolders diferentes, entonces todo se vuelve mucho más simple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No es un problema para nosotros que el mensaje se haya convertido en 10 pantallas, porque ahora solo mostramos seis ViewHolders en un ejemplo concreto. Tenemos un diseño fácil, el código es más fácil de mantener y no hay problemas especiales, excepto uno: ¿cómo hacer esto?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ho/gh/ui/hoghuifbuntyzu3uszyjr6vij_0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay ViewHolders simples: estos son separadores de fechas clásicos, cargar más, etc. </font><font style="vertical-align: inherit;">Y BaseViewHolder: ViewHolder condicionalmente básico para el mensaje. </font><font style="vertical-align: inherit;">Tiene una implementación básica y varias específicas: TextViewHolder, PhotoViewHolder, AudioViewHolder, ReplyViewHolder, etc. </font><font style="vertical-align: inherit;">Hay alrededor de 70 de ellos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿De qué es responsable BaseViewHolder?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BaseViewHolder solo es responsable de dibujar el avatar y el trozo de burbuja deseado, así como la línea para los mensajes reenviados: azul a la izquierda. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6o/yh/ia/6oyhiaag8f94wm6s69vskpv6r4u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La implementación concreta del contenido ya la llevan a cabo otros herederos de BaseViewHolder: TextViewHolder muestra solo texto, FwdSenderViewHolder, el autor del mensaje reenviado, AudioMsgViewHolder, el mensaje de voz, etc. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/th/wi/sdthwihnbm9jm4xehrbh4mmrv20.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay un problema: ¿qué hacer con el ancho? Imagine un mensaje en al menos dos pantallas. No está muy claro qué ancho establecer, porque la mitad es visible, la mitad no es visible (y ni siquiera se ha creado aún). Absolutamente todo no se puede medir, porque yace. Tengo que mudar un poco, por desgracia. Hay casos simples en los que el mensaje es muy simple: solo texto o voz, en general, consta de un elemento.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_q/i0/ov/_qi0ovd7qibtvqzcya0tzv_o4vq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, use el clásico wrap_content. </font><font style="vertical-align: inherit;">Para un caso complejo, cuando un mensaje consta de varias piezas, tomamos y forzamos cada ViewHolder un ancho fijo. </font><font style="vertical-align: inherit;">Específicamente aquí: 220 dp. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yi/fa/5t/yifa5tx6chfyxf2c26zeak-kaeu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si el texto es muy corto y se reenvía el mensaje, hay un espacio vacío a la derecha. </font><font style="vertical-align: inherit;">No hay escapatoria de esto, porque el rendimiento es más importante. </font><font style="vertical-align: inherit;">Durante varios años, no hubo quejas, tal vez alguien se dio cuenta, pero en general, todos se acostumbraron. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/mz/0l/qbmz0lzz-o_lvhongodanb3fh1m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay casos extremos. </font><font style="vertical-align: inherit;">Si respondemos a un mensaje con una pegatina, entonces podemos especificar el ancho específicamente para tal caso, para que se vea más bonito. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos dividimos en ViewHolders en la etapa de carga de mensajes: comenzamos la carga en segundo plano del mensaje, lo convertimos en elemento, se muestran directamente en ViewHolders.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/12/w_/x7/12w_x7wp4a4a4s5f_dqeqrevlbc.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Global RecycledViewPool</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La mecánica del uso de nuestro messenger es tal que las personas no se sientan en el mismo chat, sino que constantemente se interponen entre ellas. </font><font style="vertical-align: inherit;">En el enfoque estándar, cuando entramos en el chat y lo dejamos, el RecycledViewPool (y el ViewHolder en él) simplemente se destruyen, y cada vez que gastamos recursos creando el ViewHolder. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto se puede resolver con RecycledViewPool global:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dentro del marco de la aplicación, RecycledViewPool vive como un singleton;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reutilizado en la pantalla de mensajes cuando el usuario camina entre pantallas;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">establecer como RecyclerView.setRecycledViewPool (pool).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay dificultades, es importante recordar dos cosas:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vas a la pantalla, haces clic en atrás y sales. </font><font style="vertical-align: inherit;">El problema es que esos ViewHolders que estaban en la pantalla se descartan y no se devuelven al grupo. </font><font style="vertical-align: inherit;">Esto se arregla de la siguiente manera:</font></font><br>
<pre><code class="java hljs">LinearLayoutManager.recycleChildrenOnDetach = <span class="hljs-keyword">true</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecycledViewPool tiene limitaciones: no se pueden almacenar más de cinco ViewHolders para cada ViewType.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si se muestran 9 TextViews en la pantalla, solo se devolverán cinco elementos al RecycledViewPool, y el resto se desechará. </font><font style="vertical-align: inherit;">Puede cambiar el tamaño de RecycledViewPool: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RecycledViewPool.setMaxRecycledViews (viewType, size) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero es un poco triste escribir en cada ViewType con las manos, porque puede escribir su RecycledViewPool, expandir el estándar y convertirlo en NoLimit. </font><font style="vertical-align: inherit;">Por el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlace</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede descargar la implementación terminada.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DiffUtil no siempre es útil</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí hay un caso clásico: descargar, reproducir una pista de audio y un mensaje de voz. </font><font style="vertical-align: inherit;">En este caso, DiffUtil llama spam. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ho/3o/lt/ho3oltgo6763hgc65xxel-ccopa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestro BaseViewHolder tiene un método abstracto updateUploadProgress.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseViewHolder</span> : <span class="hljs-title">ViewHolder</span> </span>{<font></font>
    …<font></font>
    <span class="hljs-function">fun <span class="hljs-title">updateUploadProgress</span><span class="hljs-params">(attachId: Int, progress: Float)</span>
    …        
}
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para lanzar un evento, debemos omitir todos los ViewHolder visibles:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">fun <span class="hljs-title">onUploadProgress</span><span class="hljs-params">(attachId: Int, progress: Float)</span> </span>{<font></font>
    forEachActiveViewHolder {<font></font>
        it.updateUploadProgress(attachId, progress)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es una operación simple, es poco probable que tengamos más de diez ViewHolder en la pantalla. </font><font style="vertical-align: inherit;">Tal enfoque no puede retrasarse en principio. </font><font style="vertical-align: inherit;">¿Cómo encontrar ViewHolder visible? </font><font style="vertical-align: inherit;">Una implementación ingenua sería algo como esto:</font></font><br>
<br>
<pre><code class="java hljs">val firstVisiblePosition = &lt;...&gt;<font></font>
val lastVisiblePosition = &lt;...&gt;<font></font>
<span class="hljs-keyword">for</span> (i in firstVisiblePosition.. lastVisiblePosition) {<font></font>
    val viewHolder = recycler.View.findViewHolderForAdapterPosition(i)<font></font>
    viewHolder.updateUploadProgress(..)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero hay un problema. </font><font style="vertical-align: inherit;">El caché intermedio que mencioné anteriormente, ItemViewCache, contiene ViewHolders activos que simplemente no aparecen en la pantalla. </font><font style="vertical-align: inherit;">El código anterior no los afectará. </font><font style="vertical-align: inherit;">Directamente, nosotros tampoco podemos abordarlos. </font><font style="vertical-align: inherit;">Y luego las muletas vienen en nuestra ayuda. </font><font style="vertical-align: inherit;">Cree un WeakSet que almacene enlaces a ViewHolder. </font><font style="vertical-align: inherit;">A continuación, solo tenemos que pasar por alto este WeakSet.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> : <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">Adapter</span> </span>{<font></font>
    val activeViewHolders = WeakSet&lt;ViewHolder&gt;()<font></font>
        <font></font>
    <span class="hljs-function">fun <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: ViewHolder, position: Int)</span> </span>{<font></font>
        activeViewHolders.add(holder)<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">fun <span class="hljs-title">onViewRecycled</span><span class="hljs-params">(holder: ViewHolder)</span> </span>{<font></font>
        activeViewHolders.remove(holder)<font></font>
    }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ViewHolder Overlay</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere el ejemplo de las historias. Anteriormente, si una persona reaccionaba a una historia con una pegatina, la mostramos así: se </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rc/kd/z1/rckdz16ebmfwftxzfpql2lwmsko.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ve bastante feo. Quería hacerlo mejor, porque las historias son de contenido brillante, y tenemos un pequeño cuadrado allí. Pero queríamos obtener algo como esto: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vj/ma/51/vjma51z9m4eqwlhiagc7xvu2kg0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
hay un problema: nuestro mensaje está dividido en ViewHolder, están ubicados estrictamente uno debajo del otro, pero aquí se superponen. Inmediatamente no está claro cómo resolver esto. Puede crear otro ViewType "historial + etiqueta" o "historial + mensaje de voz". Entonces, en lugar de 70 ViewType, tendríamos 140 ... No, necesitamos encontrar algo más conveniente.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/01/mr/5j/01mr5jqsfdpq_zcq4s3b-vf9pyq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Me viene a la mente una de sus muletas favoritas en Android. </font><font style="vertical-align: inherit;">Por ejemplo, estábamos haciendo algo, pero Pixel Perfect no converge. </font><font style="vertical-align: inherit;">Para solucionar esto, debe eliminar todo y escribir desde cero, pero la pereza. </font><font style="vertical-align: inherit;">Como resultado, podemos hacer margen = -2dp (negativo), y ahora todo encaja. </font><font style="vertical-align: inherit;">Pero tal enfoque no puede usarse aquí. </font><font style="vertical-align: inherit;">Si establece un margen negativo, la pegatina se moverá, pero el lugar que ocupó permanecerá vacío. </font><font style="vertical-align: inherit;">Pero tenemos ItemDecoration, donde itemOffset podemos hacer un número negativo. </font><font style="vertical-align: inherit;">¡Y funciona! </font><font style="vertical-align: inherit;">Como resultado, obtenemos la superposición esperada y, al mismo tiempo, permanece un paradigma en el que cada ViewHolder es amigo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una hermosa solución en una sola línea.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OffsetItemDecoration</span> : <span class="hljs-title">RecyclerViewItemDecoration</span>() </span>{
    <span class="hljs-function">overrride fun <span class="hljs-title">getItemOffsets</span><span class="hljs-params">(offset: Rect, …)</span> </span>{<font></font>
        offset.top = -<span class="hljs-number">100</span>dp<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idlehandler</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es un caso con un asterisco, es complejo y no se necesita con tanta frecuencia en la práctica, pero es importante saber acerca de la existencia de dicho método. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, te diré cómo funciona el hilo principal de UiThread. El esquema general: hay una cola de eventos de tareas en la que las tareas se establecen a través de handler.post, y un bucle infinito que pasa por esta cola. Es decir, UiThread es solo mientras (verdadero). Si hay tareas, las ejecutamos, si no, esperamos hasta que aparezcan.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y3/ee/nn/y3eennjezxs29i4lkbvggnqkgjw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestras realidades habituales, Handler es responsable de poner las tareas en la cola, y Looper la evita sin cesar. </font><font style="vertical-align: inherit;">Hay tareas que no son muy importantes para la interfaz de usuario. </font><font style="vertical-align: inherit;">Por ejemplo, un usuario lee un mensaje; no es tan importante para nosotros cuando lo mostramos en la interfaz de usuario, ahora o después de 20 ms. </font><font style="vertical-align: inherit;">El usuario no notará la diferencia. </font><font style="vertical-align: inherit;">Entonces, ¿quizás valga la pena ejecutar esta tarea en el hilo principal solo cuando es gratis? </font><font style="vertical-align: inherit;">Es decir, sería bueno para nosotros saber cuándo se llama a la línea waitNewTask. </font><font style="vertical-align: inherit;">Para este caso, Looper tiene un addIdleHandler que se activa cuando se activa el código task.isEmpty. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Looper.myQueue (). AddIdleHandler ()</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Y luego la implementación más simple de IdleHandler se verá así:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@AnyThread</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdleHandler</span> </span>{
    <span class="hljs-keyword">private</span> val handler = Handler(Looper.getMainLooper())<font></font>
<font></font>
    <span class="hljs-function">fun <span class="hljs-title">post</span><span class="hljs-params">(task: Runnable)</span> </span>{<font></font>
        handler.post {<font></font>
            Looper.myQueue().addIdleHandler {<font></font>
                task.run()<font></font>
                <span class="hljs-keyword">return</span><span class="hljs-meta">@addIdleHandler</span> <span class="hljs-keyword">false</span><font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Del mismo modo, puede medir un arranque en frío honesto de la aplicación.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Emoji</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilizamos nuestros emoji personalizados en lugar de los del sistema. Aquí hay un ejemplo de cómo se veían los emojis en diferentes plataformas en diferentes años. Los emoji izquierdo y derecho son bastante agradables, pero en el medio ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bv/71/m3/bv71m3d7rginefvtev6ogcgwess.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay un segundo problema: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dw/-1/nx/dw-1nxxjfpggaxcjo_-idb0ofce.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cada fila es el mismo emoji, pero las emociones que reproducen son diferentes. Me gusta la parte inferior derecha, todavía no entiendo lo que significa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay una bicicleta de VKontakte. En ~ 2014, cambiamos ligeramente un emoji. Tal vez alguien recuerda: "Marshmallow" era. Después de su cambio, comenzó un mini disturbio. Por supuesto, no alcanzó el nivel de "devolver el muro", pero la reacción fue bastante interesante. Y esto nos dice sobre la importancia de interpretar emoji.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cómo se hacen los emojis: tenemos un gran mapa de bits, donde todos se ensamblan en un gran "atlas". </font><font style="vertical-align: inherit;">Hay varios de ellos, bajo diferentes DPI. </font><font style="vertical-align: inherit;">Y hay un EmojiSpan que contiene información: dibujo emoji "tal y tal", está en tal y tal mapa de bits en tal y tal ubicación (x, y). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y hay un ReplacementSpan que le permite mostrar algo en lugar de texto en Span. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es decir, encuentra emoji en el texto, lo envuelve con EmojiSpan y el sistema dibuja el emoji deseado en lugar del sistema.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/y5/tq/agy5tq5wl0ys8vbwuqgwhpfeoli.png"><a name="alt"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternativas</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inflar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alguien puede decir que, dado que el inflado es lento, ¿por qué no crear un diseño con las manos y evitar inflarlo? </font><font style="vertical-align: inherit;">Y de ese modo, acelere todo evitando el ViewHolder 100500. </font><font style="vertical-align: inherit;">Es una ilusión. </font><font style="vertical-align: inherit;">Antes de hacer algo, vale la pena medirlo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android tiene una clase de depuración, tiene startMethodTracing y stopMethodTracing.</font></font><br>
<br>
<pre><code class="java hljs">Debug.startMethodTracing(“trace»)<font></font>
inflate(...)<font></font>
Debug.stopMethodTracing()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos permitirá recopilar información sobre el tiempo de ejecución de un código en particular. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ea/hz/wa/eahzwatykq-cflwr2ul3qnwbvq4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y vemos que aquí inflar como tal es incluso invisible. </font><font style="vertical-align: inherit;">Una cuarta parte del tiempo se la pasó cargando dibujables, una cuarta parte cargando colores. </font><font style="vertical-align: inherit;">Y solo en algún lugar de la parte de etc. está nuestro inflado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Traté de traducir el diseño XML en código y lo guardé en algún lugar alrededor de 0,5 ms. </font><font style="vertical-align: inherit;">El aumento, de hecho, no es el más impresionante. </font><font style="vertical-align: inherit;">Y el código se ha vuelto mucho más complicado. </font><font style="vertical-align: inherit;">Es decir, reescribir no tiene mucho sentido.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, en la práctica, muchos no encontrarán este problema en absoluto, porque un inflado largo generalmente ocurre solo cuando la aplicación se vuelve muy grande. </font><font style="vertical-align: inherit;">En nuestra aplicación VKontakte, por ejemplo, hay aproximadamente 200-300 pantallas diferentes, y la carga de todos los recursos se bloquea. </font><font style="vertical-align: inherit;">Qué hacer con esto aún no está claro. </font><font style="vertical-align: inherit;">Lo más probable es que tenga que escribir su propio administrador de recursos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anko</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anko ha quedado en desuso recientemente. </font><font style="vertical-align: inherit;">De todos modos, Anko no es magia, sino un simple azúcar sintáctico. </font><font style="vertical-align: inherit;">Traduce todo a la nueva Vista condicional () de la misma manera. </font><font style="vertical-align: inherit;">Por lo tanto, no hay beneficio de Anko.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Litho / Flutter</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Por qué combiné dos cosas completamente ajenas? </font><font style="vertical-align: inherit;">Porque no se trata de tecnología, sino de la complejidad de la migración a ella. </font><font style="vertical-align: inherit;">No puede simplemente pedir prestado y pasar a una nueva biblioteca. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No está claro si esto nos dará un aumento de rendimiento. </font><font style="vertical-align: inherit;">Y no tendremos nuevos problemas, porque millones de personas con dispositivos completamente diferentes usan nuestra aplicación cada minuto (probablemente ni siquiera haya escuchado acerca de una cuarta parte de ellos). </font><font style="vertical-align: inherit;">Además, los mensajes son una base de código muy grande. </font><font style="vertical-align: inherit;">Es imposible reescribir todo al instante. </font><font style="vertical-align: inherit;">Y hacerlo por la exageración de la tecnología es estúpido. </font><font style="vertical-align: inherit;">Especialmente cuando el Jetpack Compose aparece en algún lugar lejano.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetpack componer</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Google nos promete maná del cielo en forma de esta biblioteca, pero todavía está en alfa. </font><font style="vertical-align: inherit;">Y cuándo estará en el lanzamiento, no está claro. </font><font style="vertical-align: inherit;">Si podemos obtenerlo en su forma actual tampoco está claro. </font><font style="vertical-align: inherit;">Es muy temprano para experimentar. </font><font style="vertical-align: inherit;">Deja que salga estable, deja que los errores principales se cierren. </font><font style="vertical-align: inherit;">Y solo entonces miraremos en su dirección.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una gran vista personalizada</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay otro enfoque del que hablan quienes usan varios mensajeros instantáneos: "tomar y escribir una vista personalizada grande, sin jerarquía complicada". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Cuales son las desventajas?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es difícil de mantener.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No tiene sentido en las realidades actuales.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con Android 4.3, se bombeó el sistema de almacenamiento en caché interno dentro de View. </font><font style="vertical-align: inherit;">Por ejemplo, onMeasure no se llama si la Vista no ha cambiado. </font><font style="vertical-align: inherit;">Y se utilizan los resultados de la medición anterior. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con Android 4.3-4.4, apareció un RenderNode (DisplayList), el procesamiento en caché. </font><font style="vertical-align: inherit;">Veamos un ejemplo. </font><font style="vertical-align: inherit;">Supongamos que hay una celda en la lista de cuadros de diálogo: avatar, título, subtítulo, estado de lectura, hora, otro avatar. </font><font style="vertical-align: inherit;">Condicionalmente - 10 elementos. </font><font style="vertical-align: inherit;">Y escribimos Vista personalizada. </font><font style="vertical-align: inherit;">En este caso, al cambiar una propiedad, volveremos a medir todos los elementos. </font><font style="vertical-align: inherit;">Es decir, solo gasta los recursos adicionales. </font><font style="vertical-align: inherit;">En el caso de ViewGroup, donde cada elemento es una Vista separada, cuando cambia una Vista, invalidaremos solo una Vista (excepto cuando esta Vista afecte el tamaño de otras).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resumen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, has aprendido que usamos el clásico RecyclerView con optimizaciones estándar. Hay una parte de los no estándar, donde lo más importante y fundamental es dividir el mensaje en ViewHolder. Por supuesto, puede decir que esto es de aplicación limitada, pero este enfoque también se puede proyectar en otras cosas, por ejemplo, en un texto grande de 10 mil caracteres. Se puede dividir en párrafos, donde cada párrafo es un ViewHolder separado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También vale la pena maximizar todo en @WorkerThread: analizar enlaces, DiffUtils, descargando así @UiThead tanto como sea posible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El RecycledViewPool global le permite caminar entre pantallas de mensajes y no crear un ViewHolder cada vez. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero hay otras cosas importantes que aún no hemos decidido, por ejemplo, un largo inflado, o más bien, cargando datos de los recursos.</font></font><br>
<br>
<blockquote>    ,   Mobius 2019 Piter  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>,     .     ,     ,  SQLite,     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mobius 2020 Piter</a>     .</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es501978/index.html">¿Cómo funciona el histograma de Prometeo?</a></li>
<li><a href="../es501980/index.html">La historia de un proyecto o cómo creé un PBX de 7 años basado en Asterisk y Php</a></li>
<li><a href="../es501982/index.html">Cómo transferir un sombreador de un motor de juego a Substance Painter</a></li>
<li><a href="../es501984/index.html">¿Qué ver en cuarentena? Una selección de materiales de Technostream (parte 4)</a></li>
<li><a href="../es501986/index.html">Secretos del increíble éxito de Apple AirPods</a></li>
<li><a href="../es501990/index.html">Publicación útil: 4 eventos para resolver los problemas del segundo día en OpenShift y crear operadores</a></li>
<li><a href="../es501992/index.html">Cómo organizar las pruebas para acelerar y estabilizar los lanzamientos de productos. Parte 1</a></li>
<li><a href="../es501994/index.html">Orchestrator for MySQL: por qué no se puede construir un proyecto a prueba de fallas sin él</a></li>
<li><a href="../es501996/index.html">Zen Go (versión de bolsillo)</a></li>
<li><a href="../es501998/index.html">Precio caro de los estilos. Informe Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>