<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõçÔ∏è üßíüèæ ü§∂üèª Um pouco sobre realoca√ß√µes no kernel do Linux üçò üßïüèª üåü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vamos resolver um problema simples - selecione um bloco de mem√≥ria no espa√ßo do kernel do Linux, coloque algum c√≥digo bin√°rio nele e execute-o. Para f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Um pouco sobre realoca√ß√µes no kernel do Linux</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504442/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos resolver um problema simples - selecione um bloco de mem√≥ria no espa√ßo do kernel do Linux, coloque algum c√≥digo bin√°rio nele e execute-o. </font><font style="vertical-align: inherit;">Para fazer isso, escrevemos um m√≥dulo do kernel, nele definimos a fun√ß√£o foo, que desempenhar√° o papel do c√≥digo bin√°rio de que precisamos, usando a fun√ß√£o module_alloc, selecione o bloco de mem√≥ria, copie toda a fun√ß√£o para ele atrav√©s do memcpy e d√™ o controle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√° o que parece:</font></font><br>
<a name="habracut"></a><br>
<pre><code class="plaintext hljs">static noinline int foo(int ret)<font></font>
{<font></font>
	return (ret + 2);<font></font>
}<font></font>
<font></font>
static int exe_init(void)<font></font>
{<font></font>
	int ret = 0;<font></font>
	int (*new_foo)(int);<font></font>
<font></font>
	ret = foo(0);<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
<font></font>
	new_foo = module_alloc(PAGE_SIZE);<font></font>
	set_memory_x((unsigned long)new_foo, 1);<font></font>
<font></font>
	printk(KERN_INFO "foo=%lx new_foo=%lx\n",<font></font>
		(unsigned long)foo, (unsigned long)new_foo);<font></font>
<font></font>
	memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
<font></font>
	ret = new_foo(1);<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
<font></font>
	vfree(new_foo);<font></font>
	return 0;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A fun√ß√£o exe_init √© chamada quando o m√≥dulo √© carregado. </font><font style="vertical-align: inherit;">Examinamos o resultado do trabalho no log do kernel:</font></font><br>
<br>
<pre><code class="plaintext hljs">[ 6972.522422] ret=2<font></font>
[ 6972.522443] foo=ffffffffc0000000 new_foo=ffffffffc0007000<font></font>
[ 6972.522457] ret=3<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo est√° funcionando corretamente. </font><font style="vertical-align: inherit;">E agora adicionamos a fun√ß√£o printk a foo para exibir o argumento:</font></font><br>
<br>
<pre><code class="plaintext hljs">static noinline int foo(int ret)<font></font>
{<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
	return (ret + 2);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
e despejar 25 bytes do conte√∫do da fun√ß√£o new_foo () antes de passar o controle para ela:</font></font><br>
<br>
<pre><code class="plaintext hljs">	memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
	dump((unsigned long)new_foo);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
despejo √© definido como</font></font><br>
<br>
<pre><code class="plaintext hljs">static inline void dump(unsigned long x)<font></font>
{<font></font>
	int i;<font></font>
	for (i = 0; i &lt; 25; i++) \<font></font>
		pr_cont("%.2x ", *((unsigned char *)(x) + i) &amp; 0xFF); \<font></font>
	pr_cont("\n");<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Carregamos o m√≥dulo e obtemos uma falha com a seguinte mensagem no log:</font></font><br>
<br>
<pre><code class="plaintext hljs">[ 8482.806092] ret=0<font></font>
[ 8482.806092] ret=2<font></font>
[ 8482.806111] foo=ffffffffc0000000 new_foo=ffffffffc0007000<font></font>
[ 8482.806113] 53 89 fe 89 fb 48 c7 c7 24 10 00 c0 e8 e8 3d 0b c1 8d 43 02 5b c3 66 2e 0f <font></font>
[ 8482.806135] invalid opcode: 0000 [#1] SMP NOPTI<font></font>
[ 8482.806639] CPU: 0 PID: 5081 Comm: insmod Tainted: G           O      5.4.27 #12<font></font>
[ 8482.807669] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006<font></font>
[ 8482.808560] RIP: 0010:irq_create_direct_mapping+0x79/0x90<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De alguma forma, acabamos na fun√ß√£o irq_create_direct_mapping, embora precis√°ssemos chamar printk. </font><font style="vertical-align: inherit;">Vamos descobrir o que aconteceu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, d√™ uma olhada na lista desmontada da fun√ß√£o foo. </font><font style="vertical-align: inherit;">Obtenha-o com o comando objdump -d:</font></font><br>
<br>
<pre><code class="plaintext hljs">Disassembly of section .text:<font></font>
<font></font>
0000000000000000 &lt;foo&gt;:<font></font>
   0:	53                   	push   %rbx<font></font>
   1:	89 fe                	mov    %edi,%esi<font></font>
   3:	89 fb                	mov    %edi,%ebx<font></font>
   5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi<font></font>
   c:	e8 00 00 00 00       	callq  11 &lt;foo+0x11&gt;<font></font>
  11:	8d 43 02             	lea    0x2(%rbx),%eax<font></font>
  14:	5b                   	pop    %rbx<font></font>
  15:	c3                   	retq   <font></font>
  16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)<font></font>
  1d:	00 00 00 <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A fun√ß√£o foo est√° localizada no in√≠cio da se√ß√£o de texto. No deslocamento 0xC, o c√≥digo de opera√ß√£o do comando de chamada local e8 est√° localizado - pr√≥ximo, porque √© executado no segmento de c√≥digo atual, o valor do seletor n√£o muda. Os pr√≥ximos 4 bytes s√£o o deslocamento relativo ao valor no registro RIP para o qual o controle ser√° transferido, ou seja, RIP = deslocamento RIP +, de acordo com a documenta√ß√£o da Intel (Manual do desenvolvedor de software das arquiteturas Intel 64 e IA-32, Refer√™ncia do conjunto de instru√ß√µes AZ):</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um deslocamento relativo (rel16 ou rel32) geralmente √© especificado como uma etiqueta no c√≥digo de montagem. </font><font style="vertical-align: inherit;">Por√©m, no n√≠vel do c√≥digo da m√°quina, ele √© codificado como um valor imediato assinado de 16 ou 32 bits. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este valor √© adicionado ao valor no registro EIP (RIP). </font><font style="vertical-align: inherit;">No modo de 64 bits, o deslocamento relativo √© sempre um valor imediato de 32 bits, que √© estendido para 64 bits antes de ser adicionado ao valor no registro RIP para o c√°lculo de destino.</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sabemos o endere√ßo da fun√ß√£o foo, que √© 0xffffffffc0000000, portanto, em RIP = 0xffffffffc0000000 + 0xc + 0x5 = 0xffffffffc00000011 (0xc √© o deslocamento da instru√ß√£o e8, 1 byte da instru√ß√£o e 4 bytes do deslocamento). </font><font style="vertical-align: inherit;">Conhecemos o deslocamento, porque </font><font style="vertical-align: inherit;">fun√ß√µes corporais despejadas. </font><font style="vertical-align: inherit;">Vamos calcular para onde a chamada para nos enviar para a fun√ß√£o foo enviar√°:</font></font><br>
<br>
<pre><code class="plaintext hljs">0xffffffffc00000011 + 0xffffffffc10b3de8 = 0xffffffff810b3df9
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este √© o endere√ßo da fun√ß√£o printk:</font></font><br>
<pre><code class="plaintext hljs"># cat /proc/kallsyms | grep ffffffff810b3df9  <font></font>
ffffffff810b3df9 T printk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E agora o mesmo vale para new_foo, cujo endere√ßo √© 0xffffffffc0007000</font></font><br>
<br>
<pre><code class="plaintext hljs">0xffffffffc0007011 + 0xffffffffc10b3de8 = 0xffffffff810badf9
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o existe esse endere√ßo nas academias, mas h√° 0xffffffff88badbad9 - 0x79 = 0xffffffff810bad80</font></font><br>
<pre><code class="plaintext hljs"># cat /proc/kallsyms | grep ffffffff810bad80<font></font>
ffffffff810bad80 T irq_create_direct_mapping<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta √© a pr√≥pria fun√ß√£o na qual o acidente ocorreu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para evitar uma falha, basta recalcular o deslocamento, sabendo o endere√ßo da fun√ß√£o new_foo:</font></font><br>
<br>
<pre><code class="plaintext hljs">memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
unsigned int delta = (unsigned long)printk - (unsigned long)new_foo - 0x11;<font></font>
*(unsigned int *)((void *)new_foo + 0xD) = delta;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ap√≥s essa corre√ß√£o, n√£o haver√° falha, a fun√ß√£o new_foo executar√° e retornar√° o controle com √™xito. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O problema est√° resolvido. </font><font style="vertical-align: inherit;">Resta apenas entender por que no desmontador que lista o deslocamento ap√≥s o c√≥digo de opera√ß√£o e8 ser zero, mas n√£o h√° fun√ß√£o no despejo. </font><font style="vertical-align: inherit;">Para fazer isso, considere o que s√£o as realoca√ß√µes e como o kernel trabalha com elas. </font><font style="vertical-align: inherit;">Mas primeiro, um pouco sobre o formato ELF.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ELF significa Executable and Linkable Format - o formato de arquivos execut√°veis ‚Äã‚Äãe compos√≠veis. Um arquivo ELF √© uma cole√ß√£o de se√ß√µes. A se√ß√£o armazena um conjunto de objetos necess√°rios para o vinculador formar uma imagem execut√°vel - instru√ß√µes, dados, tabelas de s√≠mbolos, registros de realoca√ß√µes etc. Cada se√ß√£o √© descrita por um cabe√ßalho. Todos os cabe√ßalhos s√£o coletados em uma tabela de cabe√ßalhos e s√£o essencialmente uma matriz em que cada elemento tem um √≠ndice. O cabe√ßalho da se√ß√£o cont√©m um deslocamento para o in√≠cio da se√ß√£o e outras informa√ß√µes gerais, como links para outras se√ß√µes, especificando um √≠ndice na tabela de cabe√ßalho.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao montar nosso caso de teste, o compilador n√£o sabe o endere√ßo da fun√ß√£o printk, portanto, preenche o local da chamada com um valor zero e, usando um registro de realoca√ß√£o, informa ao kernel que esta posi√ß√£o deve ser preenchida com um valor v√°lido. Um registro de realoca√ß√£o cont√©m um deslocamento para a posi√ß√£o em que voc√™ deseja fazer altera√ß√µes (posi√ß√£o de realoca√ß√£o), o tipo de realoca√ß√£o e o √≠ndice do s√≠mbolo na tabela de s√≠mbolos, cujo endere√ßo deve ser substitu√≠do no deslocamento especificado. Qual √© o tipo de realoca√ß√£o? Considere abaixo. O cabe√ßalho da se√ß√£o dos registros de realoca√ß√£o refere-se, por meio de √≠ndices, aos cabe√ßalhos da se√ß√£o com uma tabela de caracteres e se√ß√µes, relativos ao in√≠cio dos quais √© especificado um deslocamento para a posi√ß√£o da realoca√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ pode examinar o conte√∫do dos registros de realoca√ß√£o usando o utilit√°rio objdump com a op√ß√£o -r.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A partir da lista desmontada, sabemos que no deslocamento 0xD √© necess√°rio escrever o endere√ßo da fun√ß√£o printk, portanto, procuramos a sa√≠da objdump com a seguinte posi√ß√£o:</font></font><br>
<br>
<pre><code class="plaintext hljs">000000000000000d R_X86_64_PC32     printk-0x0000000000000004
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, temos o registro de realoca√ß√£o necess√°rio indicando a posi√ß√£o no deslocamento 0xD e o nome do s√≠mbolo cujo endere√ßo deve ser gravado nessa posi√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Valor (-4). </font><font style="vertical-align: inherit;">que √© adicionado ao endere√ßo da fun√ß√£o printk √© chamado de adendo e √© levado em considera√ß√£o no c√°lculo do resultado final da realoca√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora observe o s√≠mbolo printk:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ objdump -t exe.ko | grep printk<font></font>
0000000000000000         *UND*	0000000000000000 printk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° um s√≠mbolo, ele √© indefinido dentro do m√≥dulo (indefinido), ent√£o vamos procur√°-lo no kernel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ser√° mais informativo examinar os registros de realoca√ß√£o e s√≠mbolos em formato bin√°rio. </font><font style="vertical-align: inherit;">Isso pode ser feito usando o wireshark, ele pode analisar o formato ELF. </font><font style="vertical-align: inherit;">Aqui est√° a nossa entrada de realoca√ß√£o (copie e cole do writehark, LSB √† esquerda):</font></font><br>
<br>
<pre><code class="plaintext hljs">  0d 00 00 00 00 00 00 00  02 00 00 00 22 00 00 00  fc ff ff ff ff ff ff ff<font></font>
  |                     |  |          ||         |  |                     |<font></font>
  +----  -------+  +--  ---++---+  +---- addendum  ------+<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compare esta entrada com a defini√ß√£o da estrutura correspondente em &lt;linux / elf.h&gt;:</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct elf64_rela {<font></font>
  Elf64_Addr r_offset;	/* Location at which to apply the action */<font></font>
  Elf64_Xword r_info;	/* index and type of relocation */<font></font>
  Elf64_Sxword r_addend;	/* Constant addend used to compute value */<font></font>
} Elf64_Rela;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui temos deslocamento de 8 bytes 0x00000000d, tipo de 4 bytes 0x00000002, √≠ndice de 4 bytes na tabela de caracteres 0x00000022 (ou 34 em decimal) e adendo de 8 bytes -4. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E aqui est√° a entrada da tabela de s√≠mbolos no n√∫mero 34:</font></font><br>
<br>
<pre><code class="plaintext hljs">  01 01 00 00 10 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
e estrutura relacionada</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct elf64_sym {<font></font>
  Elf64_Word st_name;		/* Symbol name, index in string tbl */<font></font>
  unsigned char	st_info;	/* Type and binding attributes */<font></font>
  unsigned char	st_other;	/* No defined meaning, 0 */<font></font>
  Elf64_Half st_shndx;		/* Associated section index */<font></font>
  Elf64_Addr st_value;		/* Value of the symbol */<font></font>
  Elf64_Xword st_size;		/* Associated symbol size */<font></font>
} Elf64_Sym;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os primeiros 4 bytes 0x00000101 s√£o o √≠ndice na tabela de cadeias .strtab para o nome desse caractere, ou seja, printk. O campo st_info define o tipo de s√≠mbolo, pode ser uma fun√ß√£o, objeto de dados etc., consulte a especifica√ß√£o ELF para obter mais detalhes. Iremos pular o campo st_other, agora n√£o nos interessa, e examinar os tr√™s √∫ltimos campos st_shndx, st_value e st_size. st_shndx - o √≠ndice do cabe√ßalho da se√ß√£o na qual o caractere est√° definido. Vemos aqui um valor zero, porque o s√≠mbolo n√£o est√° definido dentro do m√≥dulo, n√£o est√° nas se√ß√µes dispon√≠veis. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, seu valor st_value e tamanho st_size tamb√©m s√£o zero. Esses campos ser√£o preenchidos pelo kernel ao carregar o m√≥dulo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para compara√ß√£o, observe o s√≠mbolo foo, que est√° claramente presente:</font></font><br>
<br>
<pre><code class="plaintext hljs">  08 00 00 00 02 00 02 00  00 00 00 00 00 00 00 00  16 00 00 00 00 00 00 00
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O s√≠mbolo define uma fun√ß√£o que est√° localizada na se√ß√£o .text no endere√ßo relativo ao in√≠cio da se√ß√£o 0x00000000, ou seja, </font><font style="vertical-align: inherit;">no in√≠cio da se√ß√£o, como vimos na lista desmontada, o tamanho da fun√ß√£o √© 22 bytes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Objdump nos mostrar√° as mesmas informa√ß√µes sobre isso:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ objdump -t exe.ko | grep foo<font></font>
0000000000000000 l     F .text	0000000000000016 foo<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando o kernel carrega o m√≥dulo, ele encontra todos os caracteres indefinidos e preenche os campos st_value e st_size com valores v√°lidos. </font><font style="vertical-align: inherit;">Isso √© feito na fun√ß√£o simplify_symbols, arquivo kernel / module.c:</font></font><br>
<br>
<pre><code class="plaintext hljs">/* Change all symbols so that st_value encodes the pointer directly. */<font></font>
static int simplify_symbols(struct module *mod, const struct load_info *info)<font></font>
{<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos par√¢metros da fun√ß√£o, a estrutura load_info do seguinte formul√°rio √© passada</font></font><br>
<br>
<pre><code class="plaintext hljs">struct load_info {<font></font>
	const char *name;<font></font>
	/* pointer to module in temporary copy, freed at end of load_module() */<font></font>
	struct module *mod;<font></font>
	Elf_Ehdr *hdr;<font></font>
	unsigned long len;<font></font>
	Elf_Shdr *sechdrs;<font></font>
	char *secstrings, *strtab;<font></font>
	unsigned long symoffs, stroffs, init_typeoffs, core_typeoffs;<font></font>
	struct _ddebug *debug;<font></font>
	unsigned int num_debug;<font></font>
	bool sig_ok;<font></font>
#ifdef CONFIG_KALLSYMS<font></font>
	unsigned long mod_kallsyms_init_off;<font></font>
#endif<font></font>
	struct {<font></font>
		unsigned int sym, str, mod, vers, info, pcpu;<font></font>
	} index;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os seguintes campos s√£o interessantes para n√≥s: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - hdr - cabe√ßalho do arquivo ELF </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - sechdrs - ponteiro para a tabela de cabe√ßalho da se√ß√£o </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - strtab - tabela de nome do s√≠mbolo - um conjunto de cadeias separadas por zeros </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - index.sym - √≠ndice do cabe√ßalho da se√ß√£o que cont√©m a tabela de s√≠mbolos </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de tudo, a fun√ß√£o ter√° acesso para a se√ß√£o com a tabela de s√≠mbolos. </font><font style="vertical-align: inherit;">A tabela de s√≠mbolos √© uma matriz de elementos do tipo Elf64_Sym:</font></font><br>
<br>
<pre><code class="plaintext hljs">Elf64_Shdr *symsec = &amp;info-&gt;sechdrs[info-&gt;index.sym];<font></font>
Elf64_Sym *sym = (void *)symsec-&gt;sh_addr;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, no loop, examinamos todos os caracteres da tabela, determinando para cada um seu nome:</font></font><br>
<pre><code class="plaintext hljs">for (i = 1; i &lt; symsec-&gt;sh_size / sizeof(Elf_Sym); i++) {<font></font>
	const char *name = info-&gt;strtab + sym[i].st_name;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O campo st_shndx cont√©m o √≠ndice do cabe√ßalho da se√ß√£o na qual esse caractere est√° definido. </font><font style="vertical-align: inherit;">Se houver um valor zero (nosso caso), esse s√≠mbolo n√£o est√° dentro do m√≥dulo, voc√™ deve procur√°-lo no kernel:</font></font><br>
<br>
<pre><code class="plaintext hljs">	switch (sym[i].st_shndx) {<font></font>
	.....<font></font>
	 case SHN_UNDEF: //  0<font></font>
	ksym = resolve_symbol_wait(mod, info, name);<font></font>
 	/* Ok if resolved.  */<font></font>
	if (ksym &amp;&amp; !IS_ERR(ksym)) {<font></font>
		sym[i].st_value = kernel_symbol_value(ksym);<font></font>
		break;<font></font>
	}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, vem a fila de realoca√ß√£o na fun√ß√£o apply_relocations:</font></font><br>
<br>
<pre><code class="plaintext hljs">static int apply_relocations(struct module *mod, const struct load_info *info)<font></font>
{<font></font>
	unsigned int i;<font></font>
	int err = 0;<font></font>
<font></font>
	/* Now do relocations. */<font></font>
	for (i = 1; i &lt; info-&gt;hdr-&gt;e_shnum; i++) {<font></font>
	.....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No loop, procuramos se√ß√µes de realoca√ß√£o e processamos os registros de cada se√ß√£o encontrada na fun√ß√£o apply_relocate_add:</font></font><br>
<br>
<pre><code class="plaintext hljs">if (info-&gt;sechdrs[i].sh_type == SHT_RELA) //   <font></font>
	err = apply_relocate_add(info-&gt;sechdrs, info-&gt;strtab,<font></font>
				info-&gt;index.sym, i, mod);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um ponteiro para uma tabela de cabe√ßalho de se√ß√£o, um ponteiro para uma tabela de nome de s√≠mbolo, um √≠ndice de cabe√ßalho de se√ß√£o com uma tabela de s√≠mbolos e um √≠ndice de cabe√ßalho de se√ß√£o de realoca√ß√£o s√£o passados ‚Äã‚Äãpara apply_relocate_add:</font></font><br>
<br>
<pre><code class="plaintext hljs">int apply_relocate_add(Elf64_Shdr *sechdrs,<font></font>
	   const char *strtab,<font></font>
	   unsigned int symindex,<font></font>
	   unsigned int relsec,<font></font>
	   struct module *me)<font></font>
{<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, abordamos a se√ß√£o de realoca√ß√µes:</font></font><br>
<br>
<pre><code class="plaintext hljs">Elf64_Rela *rel = (void *)sechdrs[relsec].sh_addr;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, em um loop, classificamos uma matriz de suas entradas:</font></font><br>
<br>
<pre><code class="plaintext hljs">for (i = 0; i &lt; sechdrs[relsec].sh_size / sizeof(*rel); i++) {
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encontramos a se√ß√£o para realoca√ß√£o e a posi√ß√£o nela, ou seja, </font><font style="vertical-align: inherit;">onde precisamos fazer altera√ß√µes. </font><font style="vertical-align: inherit;">O campo sh_info do cabe√ßalho da se√ß√£o de realoca√ß√£o √© o √≠ndice do cabe√ßalho da se√ß√£o para realoca√ß√£o, o campo r_offset do registro de realoca√ß√£o √© o deslocamento para a posi√ß√£o dentro da se√ß√£o para realoca√ß√£o:</font></font><br>
<br>
<pre><code class="plaintext hljs">/* This is where to make the change */<font></font>
loc = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr + rel[i].r_offset;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O endere√ßo do caractere a ser substitu√≠do nesta posi√ß√£o, levando em considera√ß√£o o adendo. </font><font style="vertical-align: inherit;">O campo r_info da entrada de realoca√ß√£o cont√©m o √≠ndice desse s√≠mbolo na tabela de s√≠mbolos:</font></font><br>
<br>
<pre><code class="plaintext hljs">	/* This is the symbol it is referring to.  Note that all<font></font>
	   undefined symbols have been resolved.  */<font></font>
	sym = (Elf64_Sym *)sechdrs[symindex].sh_addr<font></font>
		+ ELF64_R_SYM(rel[i].r_info);<font></font>
<font></font>
	val = sym-&gt;st_value + rel[i].r_addend;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O tipo de realoca√ß√£o determina o resultado final dos c√°lculos, em nosso exemplo √© R_X86_64_PLT32:</font></font><br>
<br>
<pre><code class="plaintext hljs">	switch (ELF64_R_TYPE(rel[i].r_info)) {<font></font>
	......<font></font>
	case R_X86_64_PLT32:	<font></font>
		if (*(u32 *)loc != 0)<font></font>
			goto invalid_relocation;<font></font>
		val -= (u64)loc;	//   <font></font>
		*(u32 *)loc = val;  //    <font></font>
		break;<font></font>
	.....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora podemos calcular o valor final, sabendo que sym-&gt; st_value √© o endere√ßo da fun√ß√£o printk 0xffffffff810b3df9, r_addend √© (-4), o deslocamento para a posi√ß√£o de realoca√ß√£o √© 0xd no in√≠cio da se√ß√£o de texto do m√≥dulo ou no in√≠cio da fun√ß√£o foo, ou seja, </font><font style="vertical-align: inherit;">ser√° ffffffffc000000d. </font><font style="vertical-align: inherit;">Substitua todos esses valores e obtenha:</font></font><br>
<br>
<pre><code class="plaintext hljs">val = (u32)(0xffffffff810b3df9 - 0x4 - 0xffffffffc000000d) = 0xc10b3de8
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vejamos o despejo da fun√ß√£o foo, que recebemos no in√≠cio:</font></font><br>
<br>
<pre><code class="plaintext hljs">53 89 fe 89 fb 48 c7 c7 24 10 00 c0 e8 e8 3d 0b c1 8d 43 02 5b c3 66 2e 0f
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No deslocamento 0xD, o valor 0xc10b3de8 √© encontrado, id√™ntico ao calculado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â assim que o kernel processa as realoca√ß√µes e obt√©m o deslocamento necess√°rio para o comando fechar chamada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na prepara√ß√£o do artigo, foi utilizado o kernel Linux vers√£o 5.4.27.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt504414/index.html">Como a Microsoft matou o AppGet</a></li>
<li><a href="../pt504420/index.html">Escrevendo uma arena PvP baseada em turnos com movimentos simult√¢neos</a></li>
<li><a href="../pt504430/index.html">Everyday Life Tinkoff Security Operations Center: An√°lise de √∫nico carregador de inicializa√ß√£o</a></li>
<li><a href="../pt504434/index.html">Programa educacional para os pais: como proteger as crian√ßas dos perigos na Internet</a></li>
<li><a href="../pt504438/index.html">30 mitaps por semana. Abrimos a temporada de ver√£o 2020</a></li>
<li><a href="../pt504444/index.html">Usando o docker em v√°rios est√°gios para criar imagens do Windows</a></li>
<li><a href="../pt504448/index.html">Gera√ß√£o II de jogadores</a></li>
<li><a href="../pt504450/index.html">JavaScript moderno: uma vista lateral</a></li>
<li><a href="../pt504452/index.html">Ontology lan√ßa a camada 2, contribuindo para uma plataforma de cadeia p√∫blica mais integrada</a></li>
<li><a href="../pt504454/index.html">Melhores reposit√≥rios GitHub para desenvolvedores web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>