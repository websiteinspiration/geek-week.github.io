<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✌🏻 🐬 👩‍👩‍👧‍👦 スタックとポインタの言語力学 🎅🏿 💆🏽 🍃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="プレリュード
 これは、ポインター、スタック、ヒープ、エスケープ分析、およびGo /ポインターのセマンティクスのメカニズムと設計に関する洞察を提供するシリーズの4つの記事の最初です。この投稿はスタックとポインタについてです。
 
 目次：
 
 

1. スタックとポインタの言語力学
2. エスケー...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>スタックとポインタの言語力学</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496846/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレリュード</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ポインター、スタック、ヒープ、エスケープ分析、およびGo /ポインターのセマンティクスのメカニズムと設計に関する洞察を提供するシリーズの4つの記事の最初です。</font><font style="vertical-align: inherit;">この投稿はスタックとポインタについてです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
目次：</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタックとポインタの言語力学</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エスケープ分析の言語力学</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記憶プロファイリングの言語力学</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データとセマンティクスに関する設計哲学</font></font></a></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は分解しません-ポインタは理解するのが難しいです。</font><font style="vertical-align: inherit;">ポインタを不適切に使用すると、不快なエラーが発生し、パフォーマンスの問題が発生する可能性もあります。</font><font style="vertical-align: inherit;">これは、競争力のあるプログラムやマルチスレッドプログラムを作成する場合に特に当てはまります。</font><font style="vertical-align: inherit;">当然のことながら、多くの言語はプログラマーからポインターを隠そうとします。</font><font style="vertical-align: inherit;">ただし、Goで記述した場合、ポインターをエスケープすることはできません。</font><font style="vertical-align: inherit;">ポインターを明確に理解しないと、クリーンでシンプル、かつ効率的なコードを作成することが難しくなります。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フレーム枠</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数は、対応する関数ごとに個別のメモリ空間を提供するフレームの境界内で実行されます。各フレームは、関数が独自のコンテキストで機能することを可能にし、フロー制御も提供します。関数はポインタを介してフレーム内のメモリに直接アクセスできますが、フレーム外のメモリにアクセスするには間接アクセスが必要です。関数がフレーム外のメモリにアクセスするには、このメモリをこの関数と組み合わせて使用​​する必要があります。これらの境界によって設定されるメカニズムと制限を最初に理解し、研究する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数が呼び出されると、2つのフレーム間の遷移が発生します。コードは、呼び出し元の関数のフレームから呼び出された関数のフレームに移動します。関数を呼び出すためにデータが必要な場合は、このデータを1つのフレームから別のフレームに転送する必要があります。 Goの2つのフレーム間でのデータの転送は、「値によって」行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「値による」データ転送の利点は、読みやすさです。関数呼び出しで表示される値は、コピーされて反対側で受け入れられるものです。私が「値渡し」をWYSIWYGに関連付けるのはそのためです。これにより、2つの関数間の切り替えのコストを隠さないコードを記述できます。これは、各関数呼び出しが移行中にプログラムにどのように影響するかについての良いメンタルモデルを維持するのに役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「値によって」整数データを渡すことによって関数を呼び出すこの小さなプログラムを見てください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト1：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main
<span class="hljs-number">02</span>
<span class="hljs-number">03</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">04</span>
<span class="hljs-number">05</span>    <span class="hljs-comment">// Declare variable of type int with a value of 10.</span>
<span class="hljs-number">06</span>    count := <span class="hljs-number">10</span>
<span class="hljs-number">07</span>
<span class="hljs-number">08</span>    <span class="hljs-comment">// Display the "value of" and "address of" count.</span>
<span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">10</span>
<span class="hljs-number">11</span>    <span class="hljs-comment">// Pass the "value of" the count.</span>
<span class="hljs-number">12</span>    increment(count)
<span class="hljs-number">13</span>
<span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">15</span> }
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc <span class="hljs-keyword">int</span>)</span></span> {
<span class="hljs-number">19</span>
<span class="hljs-number">20</span>    <span class="hljs-comment">// Increment the "value of" inc.</span>
<span class="hljs-number">21</span>    inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]"</span>)
<span class="hljs-number">23</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goプログラムが起動すると、ランタイムはメインのゴルーチンを作成して、メイン関数内のコードを含むすべてのコードの実行を開始します。 Gorutinは、オペレーティングシステムのスレッドに適合する実行パスであり、最終的にはいくつかのカーネルで実行されます。バージョン1.8以降、各goroutineには、サイズが2048バイトの連続メモリの初期ブロックが提供され、スタックスペースを形成します。この初期スタックサイズは長年にわたって変更されており、将来変更される可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スタックは、個々の機能に与えられるフレーム境界に物理メモリ空間を提供するため、重要です。メインのゴルーチンがリスト1のメインの機能を実行するまでに、プログラムスタック（非常に高いレベル）は次のようになります</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z4/7w/l0/z47wl0tm16nh5u-gf8u9m0kemba.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図1では、スタックの一部がmain関数に対して「フレーム化」されていたことがわかります。</font><font style="vertical-align: inherit;">このセクションは「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタックフレーム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」</font><font style="vertical-align: inherit;">と呼ば</font><font style="vertical-align: inherit;">れ、スタック上のメイン関数の境界を示すのはこのフレームです。</font><font style="vertical-align: inherit;">フレームは、関数が呼び出されたときに実行されるコードの一部として設定されます。</font><font style="vertical-align: inherit;">count変数のメモリがメインのフレーム内の0x10429fa4に割り当てられていることもわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図1に示すように、もう1つの興味深い点があります。アクティブフレームの下のすべてのスタックメモリは無効ですが、アクティブフレーム以降のメモリは有効です。</font><font style="vertical-align: inherit;">スタックの有効部分と無効部分の境界を明確に理解する必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">住所</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数は、コードを読みやすくするために特定のメモリ位置に名前を割り当てるために使用され、操作しているデータを理解するのに役立ちます。</font><font style="vertical-align: inherit;">変数がある場合はメモリに値があり、メモリに値がある場合はアドレスが必要です。</font><font style="vertical-align: inherit;">09行目で、main関数は組み込みのprintln関数を呼び出して、count変数の「値」と「アドレス」を表示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト2：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アンパサンド「＆」を使用して変数の場所の住所を取得することは新しいことではありません。他の言語でもこの演算子を使用します。</font><font style="vertical-align: inherit;">Go Playgroundなどの32ビットアーキテクチャでコードを実行している場合、09行目の出力は以下の出力のようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト3：</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数呼び出し</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、12行目で、メイン関数はインクリメント関数を呼び出します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト4：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">12</span>    increment(count)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数呼び出しを行うと、プログラムはスタックに新しいメモリセクションを作成する必要があります。ただし、すべてがもう少し複雑です。関数呼び出しを正常に完了するには、データがフレームの境界を越えて転送され、遷移中に新しいフレームに配置されることが期待されます。特に、整数値は、通話中にコピーされて送信されることが予想されます。この要件は、18行目のインクリメント関数の宣言を見るとわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト5：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc <span class="hljs-keyword">int</span>)</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
12行目のincrement関数の呼び出しをもう一度見ると、コードが変数countの「値」を渡していることがわかります。この値はコピー、転送され、インクリメント関数の新しいフレームに配置されます。インクリメント関数は、独自のフレームでのみメモリへの読み書きができるため、送信されたカウンタ値の独自のコピーを取得、保存、アクセスするには、inc変数が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
increment関数内のコードが実行を開始する直前のプログラムスタック（非常に高いレベル）は、次のようになります</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2g/jw/n9/2gjwn96mbhikaxys6ftv3cf4s14.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スタックに2つのフレームがあることがわかります。1つはメイン用で、もう1つは増分用です。</font><font style="vertical-align: inherit;">インクリメントのフレーム内には、値10を含むinc変数が表示されます。これは、関数呼び出し中にコピーされて渡されました。</font><font style="vertical-align: inherit;">inc変数のアドレスは0x10429f98であり、フレームはスタックにプッシュされるため、メモリ内では小さくなります。これは、何も意味しない単なる実装の詳細です。</font><font style="vertical-align: inherit;">重要なことは、プログラムがmainのフレームからカウント値を取得し、この値のコピーをフレームに配置して、inc変数を使用して増加させることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
increment内の残りのコードはインクリメントし、inc変数の「値」と「アドレス」を表示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト6：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">21</span>    inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレイグラウンドの22行目の出力は、次のようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト7：</font></font><br>
<br>
<pre><code class="go hljs">inc:    Value Of[ <span class="hljs-number">11</span> ]  Addr Of[ <span class="hljs-number">0x10429f98</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
：ここでは、コードの同じ行を実行した後のようなスタックに見えるものです</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。図3：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/59/1o/kv/591okvkseze5gjqum4k8hp-qv34.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
行21と22を実行した後は、増分関数は終了し、戻ってメイン関数に制御します。</font><font style="vertical-align: inherit;">次に、メイン関数は再びローカル変数countの「値」と「アドレス」を14行目に</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
表示</font><font style="vertical-align: inherit;">します。</font><font style="vertical-align: inherit;">リスト8：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>,count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレイグラウンドでの完全なプログラム出力は次のようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト9：</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]<font></font>
inc:    Value Of[ <span class="hljs-number">11</span> ]  Addr Of[ <span class="hljs-number">0x10429f98</span> ]<font></font>
count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインのフレームのカウント値は、インクリメントの呼び出しの前後で同じです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数から戻る</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数が終了し、制御が呼び出し元の関数に戻ると、スタック上のメモリは実際にどうなりますか？短い答えは何もありません。これは、インクリメント関数が返された後のスタックの様子です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図4：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qq/ve/-n/qqve-nygmg0jnhsnwrubpchwfky.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スタックは、インクリメント関数に関連付けられたフレームが無効なメモリと見なされることを除いて、図3とまったく同じです。これは、メインのフレームがアクティブになったためです。インクリメント機能のために作成されたメモリはそのまま残ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
戻り関数のメモリフレームをクリアすると、このメモリが再び必要になるかどうかわからないため、時間の無駄になります。</font><font style="vertical-align: inherit;">だから、記憶はそのままだった。</font><font style="vertical-align: inherit;">各関数呼び出し中に、フレームが取得されると、このフレームのスタックメモリがクリアされます。</font><font style="vertical-align: inherit;">これは、フレームに収まるすべての値を初期化することによって行われます。</font><font style="vertical-align: inherit;">すべての値が「ゼロ値」として初期化されるため、関数呼び出しのたびにスタックが正しくクリアされます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">価値の共有</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインのフレーム内に存在するカウント変数をインクリメント関数が直接操作することが重要である場合はどうなりますか？</font><font style="vertical-align: inherit;">ここで、ポインタの時が来ます。</font><font style="vertical-align: inherit;">ポインターは1つの目的を果たします-値を関数と共有して、値がフレーム内に直接存在しない場合でも、関数がこの値を読み書きできるようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
値を「共有」する必要がないと思われる場合は、ポインタを使用する必要はありません。</font><font style="vertical-align: inherit;">ポインタを学ぶときは、演算子や構文ではなく、きれいな辞書を使用することを考えることが重要です。</font><font style="vertical-align: inherit;">ポインタは共有されることを意図しており、コードを読み取るときに＆演算子を「共有」というフレーズに置き換えます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポインタのタイプ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
宣言した型、または言語自体によって直接宣言された型ごとに、共有に使用できる無料のポインタ型を取得します。すでにintという組み込み型があるので、* intという名前のポインター型があります。 Userという名前の型を宣言すると、* Userという名前のポインタ型が無料で取得されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのタイプのポインターには、2つの同一の特性があります。まず、*文字で始まります。第2に、それらはすべてメモリ内で同じサイズであり、アドレスを表す4または8バイトを占める表現を持っています。 32ビットアーキテクチャ（たとえば、遊び場）では、ポインタに4バイトのメモリが必要であり、64ビットアーキテクチャ（たとえば、コンピュータ）では、ポインタに8バイトのメモリが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仕様では、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポインタ型</font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型リテラル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と見なされ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。つまり、既存の型で構成される名前のない型です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">間接メモリアクセス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数呼び出しを行い、アドレスを「値で」渡すこの小さなプログラムを見てください。</font><font style="vertical-align: inherit;">これにより、count変数がmainのスタックフレームからインクリメント関数で分割されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト10：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main
<span class="hljs-number">02</span>
<span class="hljs-number">03</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">04</span>
<span class="hljs-number">05</span>    <span class="hljs-comment">// Declare variable of type int with a value of 10.</span>
<span class="hljs-number">06</span>    count := <span class="hljs-number">10</span>
<span class="hljs-number">07</span>
<span class="hljs-number">08</span>    <span class="hljs-comment">// Display the "value of" and "address of" count.</span>
<span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\t\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">10</span>
<span class="hljs-number">11</span>    <span class="hljs-comment">// Pass the "address of" count.</span>
<span class="hljs-number">12</span>    increment(&amp;count)
<span class="hljs-number">13</span>
<span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\t\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">15</span> }
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc *<span class="hljs-keyword">int</span>)</span></span> {
<span class="hljs-number">19</span>
<span class="hljs-number">20</span>    <span class="hljs-comment">// Increment the "value of" count that the "pointer points to". (dereferencing)</span>
<span class="hljs-number">21</span>    *inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]\tValue Points To["</span>, *inc, <span class="hljs-string">"]"</span>)
<span class="hljs-number">23</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
元のプログラムに3つの興味深い変更が加えられました。</font><font style="vertical-align: inherit;">最初の変更は12行目です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト11：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">12</span>    increment(&amp;count)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今回は12行目で、コードは「値」をコピーせずにカウント変数に渡しますが、カウント変数の代わりに「アドレス」を渡します。これで、変数のカウントを関数インクリメントで「共有しています」と言うことができます。これが、＆演算子の言うところです-「共有」。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはまだ「値渡し」であることを理解してください。唯一の違いは、渡す値が整数ではなくアドレスであることです。アドレスも値です。これは、関数を呼び出すためにフレームの境界を越えてコピーおよび渡されるものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アドレス値がコピーされて渡されるため、この整数アドレスを取得して保存するには、増分フレーム内に変数が必要です。整数ポインター変数宣言は18行目にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト12：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc *<span class="hljs-keyword">int</span>)</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプUserの値のアドレスを渡した場合、変数は* Userとして宣言する必要があります。すべてのポインタ変数がアドレス値を格納するという事実にもかかわらず、それらはアドレスを渡すことができず、ポインタのタイプに関連付けられたアドレスのみを渡すことができます。値を共有する基本的な原則は、受信側の関数がその値を読み書きする必要があることです。値を読み書きするには、値のタイプに関する情報が必要です。コンパイラーは、正しいポインター型に関連付けられた値のみがこの関数で使用されるようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、インクリメント関数を呼び出した後のスタックの様子です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図5：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uk/ak/zj/ukakzj1mpr_9m3thjmv2i04e_hw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図5は、アドレスとして値を使用して「値渡し」を実行した場合のスタックの様子を示しています。 increment関数のフレーム内のポインター変数は、mainのフレーム内にあるcount変数を指すようになりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、ポインター変数を使用して、関数はメインのフレーム内にあるカウント変数の間接的な読み取りおよび変更操作を実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト13：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">21</span>    *inc++</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今回は、*文字が演算子として機能し、ポインター変数に適用されます。演算子として*を使用すると、「ポインターが指す値」を意味します。ポインター変数は、それを使用する関数のフレーム外のメモリーへの間接アクセスを提供します。この間接的な読み取りまたは書き込みは、ポインタの逆参照と呼ばれることがあります。インクリメント関数では、フレームにポインタ変数が必要です。ポインタ変数を直接読み取って間接アクセスを実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図6は、21行目以降のスタックの様子を示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図6：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rn/ph/vi/rnphvi1x69rrhspljslmvxilauq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプログラムの最終出力は次のとおりです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト14：</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]              Addr Of[ <span class="hljs-number">0x10429fa4</span> ]<font></font>
inc:    Value Of[ <span class="hljs-number">0x10429fa4</span> ]      Addr Of[ <span class="hljs-number">0x10429f98</span> ]   Value Points To[ <span class="hljs-number">11</span> ]<font></font>
count:  Value Of[ <span class="hljs-number">11</span> ]              Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
incポインタ変数の「値」がカウント変数の「アドレス」と一致していることに気付くでしょう。</font><font style="vertical-align: inherit;">これにより、フレーム外のメモリへの間接アクセスを許可する共有関係が確立されます。</font><font style="vertical-align: inherit;">インクリメント関数がポインタを介して書き込むとすぐに、制御がメイン関数に戻されたときに、変更がメイン関数に表示されます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポインタ変数は特別ではありません</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポインター変数は他の変数と同じ変数であるため、特別ではありません。</font><font style="vertical-align: inherit;">それらにはメモリ割り当てがあり、意味が含まれています。</font><font style="vertical-align: inherit;">たまたま、すべてのポインタ変数は、それらが指す値のタイプに関係なく、常に同じサイズと表示を持っています。</font><font style="vertical-align: inherit;">混乱を招く可能性があるのは、*文字がコード内で演算子として機能し、ポインター型を宣言するために使用されることです。</font><font style="vertical-align: inherit;">型宣言とポインター操作を区別できる場合は、これにより混乱を避けることができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この投稿では、ポインターの目的、スタックの操作、Goでのポインターの仕組みについて説明します。</font><font style="vertical-align: inherit;">これは、一貫性のある読みやすいコードを記述するために必要なメカニズム、設計原理、および使用方法を理解するための最初のステップです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、これはあなたが学んだことです：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数はフレーム境界内で実行され、対応する関数ごとに個別のメモリ空間を提供します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数が呼び出されると、2つのフレーム間の遷移が発生します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「値による」データ転送の利点は、読みやすさです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタックは、個々の機能に与えられるフレーム境界に物理メモリ空間を提供するため、重要です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アクティブフレームの下のすべてのスタックメモリは無効ですが、アクティブフレーム以降のメモリは有効です。</font></font></li>
<li>   ,         .</li>
<li>    ,   ,      .</li>
<li>    —    ,        ,         .</li>
<li>   ,  ,   ,     ,      .</li>
<li>-          ,   .</li>
<li>-   - ,      ,     .     ,    .</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja496832/index.html">フォトツアー：新物理研究所ITMOのハイブリッドナノフォトニクスとオプトエレクトロニクスの研究室で何をしているのか</a></li>
<li><a href="../ja496836/index.html">QSerializer：シンプルなJSON / XMLシリアル化のソリューション</a></li>
<li><a href="../ja496838/index.html">Slackで使用されているプロジェクトの展開方法</a></li>
<li><a href="../ja496840/index.html">ムスクは、12,000の衛星が天文学者に干渉しないと信じています。彼の意見はモデルと一致していません</a></li>
<li><a href="../ja496842/index.html">基本的なPythonツールを使用した単純な流行モデル</a></li>
<li><a href="../ja496848/index.html">モバイル＃340開発者向けの興味深い資料のダイジェスト（4月6〜12日）</a></li>
<li><a href="../ja496850/index.html">Java 14のJPackage用Mavenプラグイン</a></li>
<li><a href="../ja496852/index.html">スムーズな選別</a></li>
<li><a href="../ja496856/index.html">リモコンなし、ただしキューブ付きのスマートホーム</a></li>
<li><a href="../ja496858/index.html">FOSSニュースNo. 11-2020年4月6〜12日の無料およびオープンソースソフトウェアのレビュー</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>