<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòô üë®‚Äçüë©‚Äçüëß‚Äçüëß ü¶ë HighLoad ++, Mikhail Tyulenev (MongoDB): Kausale Konsistenz: von der Theorie zur Praxis üë©üèø‚Äç‚öñÔ∏è ‚òπÔ∏è üê´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die n√§chste HighLoad ++ - Konferenz findet am 6. und 7. April 2020 in St. Petersburg statt. 
 Details und Tickets hier . HighLoad ++ Sibirien 2019. Ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>HighLoad ++, Mikhail Tyulenev (MongoDB): Kausale Konsistenz: von der Theorie zur Praxis</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/487638/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die n√§chste HighLoad ++ - Konferenz findet am 6. und 7. April 2020 in St. Petersburg statt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Details und Tickets </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . HighLoad ++ Sibirien 2019. Halle "Krasnojarsk". 25. Juni, 12:00 Uhr. Abstracts und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pr√§sentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ok/iw/mz/okiwmzx4qkp6dxvjvqjxvfzqtnk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es kommt vor, dass praktische Anforderungen im Widerspruch zu einer Theorie stehen, bei der Aspekte, die f√ºr ein kommerzielles Produkt wichtig sind, nicht ber√ºcksichtigt werden. In diesem Bericht wird der Prozess der Auswahl und Kombination verschiedener Ans√§tze zur Erstellung kausaler Konsistenzkomponenten auf der Grundlage akademischer Forschung auf der Grundlage der Anforderungen eines kommerziellen Produkts vorgestellt. Die Sch√ºler lernen die bestehenden theoretischen Ans√§tze f√ºr logische Uhren, Abh√§ngigkeitsverfolgung, Systemsicherheit, Uhrensynchronisation und warum MongoDB diese oder jene L√∂sungen eingestellt hat.</font></font><a name="habracut"></a><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mikhail Tyulenev (im Folgenden - MT):</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ich werde √ºber kausale Konsistenz sprechen - Dies ist eine Funktion, an der wir in MongoDB gearbeitet haben. </font><font style="vertical-align: inherit;">Ich arbeite in einer Gruppe verteilter Systeme, wir haben es vor ungef√§hr zwei Jahren gemacht. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ih/xx/xg/ihxxxghkrknnqdxg7tb4w97izi0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dabei musste ich mich mit viel akademischer Forschung vertraut machen, da diese Funktion gut untersucht ist. </font><font style="vertical-align: inherit;">Es stellte sich heraus, dass kein einziger Artikel in die Anforderungen der Produktion passt, die Datenbank angesichts der sehr spezifischen Anforderungen, die wahrscheinlich in Produktionsanwendungen gestellt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde dar√ºber sprechen, wie wir als Verbraucher akademischer Forschung etwas daraus zubereiten, das wir unseren Benutzern dann als fertiges Gericht pr√§sentieren k√∂nnen, das bequem und sicher zu verwenden ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kausale Konsistenz. </font><font style="vertical-align: inherit;">Definieren wir Konzepte</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst m√∂chte ich allgemein skizzieren, was kausale Konsistenz ist. Es gibt zwei Charaktere - Leonard und Penny (die Serie ‚ÄûThe Big Bang Theory‚Äú): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7q/nw/lr/7qnwlrmqtidow8cl_jrdakec3d0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, Penny ist in Europa und Leonard m√∂chte eine Art √úberraschung f√ºr sie machen, eine Party. Und er hat nichts Besseres gefunden, als sie von der Freundesliste zu streichen und Updates zu senden, um alle Freunde zu f√ºttern: "Lass uns Penny gl√ºcklich machen!" (Sie in Europa sieht im Schlaf nicht alles und kann nicht sehen, weil sie nicht da ist.) Am Ende wird dieser Beitrag gel√∂scht, aus dem "Feed" gel√∂scht und der Zugriff wiederhergestellt, sodass nichts bemerkt wird und kein Skandal auftritt.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles in Ordnung, aber nehmen wir an, dass das System verteilt ist und die Ereignisse etwas schief gelaufen sind. </font><font style="vertical-align: inherit;">M√∂glicherweise kommt es beispielsweise vor, dass die Penny-Zugriffsbeschr√§nkung nach dem Erscheinen dieses Beitrags aufgetreten ist, wenn die Ereignisse nicht durch einen Kausalzusammenhang verbunden sind. </font><font style="vertical-align: inherit;">Tats√§chlich ist dies ein Beispiel daf√ºr, wann kausale Konsistenz erforderlich ist, um eine Gesch√§ftsfunktion zu erf√ºllen (in diesem Fall). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tats√§chlich sind dies nicht triviale Eigenschaften der Datenbank - nur sehr wenige Menschen unterst√ºtzen sie. </font><font style="vertical-align: inherit;">Kommen wir zu den Modellen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konsistenzmodelle</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist ein Konsistenzmodell in Datenbanken im Allgemeinen? </font><font style="vertical-align: inherit;">Dies sind einige der Garantien, die ein verteiltes System in Bezug darauf gibt, welche Daten und in welcher Reihenfolge der Client empfangen kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grunds√§tzlich kommt es bei allen Konsistenzmodellen darauf an, wie verteilt das System wie ein System ist, das beispielsweise auf einem Laptop mit demselben Nicken funktioniert. </font><font style="vertical-align: inherit;">Und so sehr √§hnelt das System, das auf Tausenden von geoverteilten ‚ÄûKnoten‚Äú funktioniert, einem Laptop, bei dem alle diese Eigenschaften im Prinzip automatisch ausgef√ºhrt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher gelten Konsistenzmodelle nur f√ºr verteilte Systeme. </font><font style="vertical-align: inherit;">Bei allen Systemen, die zuvor mit derselben vertikalen Skalierung existierten und arbeiteten, traten solche Probleme nicht auf. </font><font style="vertical-align: inherit;">Es gab einen Puffer-Cache, aus dem immer alles gelesen wurde.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starkes Modell</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tats√§chlich ist das allererste Modell Stark (oder die Linie der Aufstiegsf√§higkeit, wie sie oft genannt wird). </font><font style="vertical-align: inherit;">Dies ist ein Konsistenzmodell, das sicherstellt, dass jede √Ñnderung f√ºr alle Benutzer des Systems sichtbar ist, sobald eine Best√§tigung eingeht, dass sie stattgefunden hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dadurch wird eine globale Reihenfolge aller Ereignisse in der Datenbank erstellt. </font><font style="vertical-align: inherit;">Dies ist eine sehr starke Konsistenz-Eigenschaft und im Allgemeinen sehr teuer. </font><font style="vertical-align: inherit;">Es ist jedoch sehr gut gepflegt. </font><font style="vertical-align: inherit;">Es ist einfach sehr teuer und langsam - sie werden einfach selten verwendet. </font><font style="vertical-align: inherit;">Dies nennt man Aufstiegsf√§higkeit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt eine weitere, leistungsst√§rkere Eigenschaft, die im "Spanner" unterst√ºtzt wird - die externe Konsistenz. </font><font style="vertical-align: inherit;">Wir werden etwas sp√§ter √ºber ihn sprechen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kausal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Folgende ist Kausal, genau das, wor√ºber ich gesprochen habe. Es gibt mehrere Unterebenen zwischen Stark und Kausal, √ºber die ich nicht sprechen werde, aber alle sind auf Kausal zur√ºckzuf√ºhren. Dies ist ein wichtiges Modell, da es das st√§rkste aller Modelle ist und die st√§rkste Konsistenz bei Vorhandensein eines Netzwerks oder von Partitionen aufweist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kausale ist eigentlich eine Situation, in der Ereignisse durch einen Kausalzusammenhang verbunden sind. Sehr oft werden sie aus Sicht des Kunden als Read your on-Rechte wahrgenommen. Wenn der Kunde einige Werte beobachtet hat, kann er die Werte in der Vergangenheit nicht sehen. Er beginnt bereits, Pr√§fixablesungen zu sehen. Es kommt alles auf dasselbe an.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kausale als Konsistenzmodell sind eine Teilreihenfolge von Ereignissen auf dem Server, bei der Ereignisse von allen Clients in derselben Reihenfolge beobachtet werden. </font><font style="vertical-align: inherit;">In diesem Fall Leonard und Penny.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eventuell</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das dritte Modell ist die eventuelle Konsistenz. Dies unterst√ºtzt absolut alle verteilten Systeme, ein Minimalmodell, das im Allgemeinen Sinn macht. Dies bedeutet Folgendes: Wenn sich die Daten √§ndern, werden sie irgendwann konsistent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einem solchen Moment sagt sie nichts, sonst w√ºrde sie sich in externe Konsistenz verwandeln - es w√ºrde eine ganz andere Geschichte geben. Trotzdem ist dies ein sehr beliebtes Modell, das h√§ufigste. Standardm√§√üig verwenden alle Benutzer verteilter Systeme Eventual Consistency. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich m√∂chte einige vergleichende Beispiele geben: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yn/5s/p9/yn5sp9tyjn4dh4q3vonroirvxic.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was bedeuten diese Pfeile?</font></font><br>
<br>
<ul>
<li><b>Latency.</b>          :    ,       ,    ,     .   Eventual Consistency   ,   ,  ,    memory       .</li>
<li><b>Availability.</b>           , partitions,  -  ‚Äì      ,    ,         - . Eventual Consistency        ‚Äì    ,  .</li>
<li><b>Anomalies.</b>  , ,   .  Strong Consistency       ,  Eventual Consistency     .  :     Eventual Consistency,    ?    ,  Eventual Consistency- ,   , ,    ;        -   ;       .   ,       .</li>
</ul><br>
<h3> CAP</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie die W√∂rter Konsistenz, Verf√ºgbarkeit sehen - woran denken Sie? Richtig - CAP-Theorem! Jetzt m√∂chte ich den Mythos zerstreuen ... Ich bin es nicht - da ist Martin Kleppman, der einen wunderbaren Artikel geschrieben hat, ein wundervolles Buch. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-k/rc/v1/-krcv1vofhv9ofnwbty6ql6hvhg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das CAP-Theorem ist ein in den 2000er Jahren formuliertes Prinzip: Konsistenz, Verf√ºgbarkeit, Partitionen: Nehmen Sie zwei, und Sie k√∂nnen nicht drei ausw√§hlen. Es war ein bestimmtes Prinzip. Einige Jahre sp√§ter wurde es von Gilbert und Lynch als Theorem bewiesen. Dann wurde es als Mantra verwendet - Systeme wurden in CA, CP, AP usw. unterteilt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Satz wurde tats√§chlich aus folgenden Gr√ºnden bewiesen ... Erstens wurde Verf√ºgbarkeit nicht als kontinuierlicher Wert von Null bis Hundert betrachtet (0 - das System ist "tot", 100 - Antworten schnell; wir sind es gewohnt, ihn zu ber√ºcksichtigen), sondern als eine Eigenschaft des Algorithmus Dies stellt sicher, dass bei allen Ausf√ºhrungen Daten zur√ºckgegeben werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt kein Wort √ºber die Reaktionszeit! Es gibt einen Algorithmus, der Daten nach 100 Jahren zur√ºckgibt - einen perfekt verf√ºgbaren Algorithmus, der Teil des CAP-Theorems ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens: Es wurde ein Satz f√ºr √Ñnderungen der Werte desselben Schl√ºssels bewiesen, obwohl diese √Ñnderungen eine ver√§nderbare Linie sind. Dies bedeutet, dass sie tats√§chlich praktisch nicht verwendet werden, da die Modelle unterschiedliche m√∂gliche Konsistenz, starke Konsistenz (m√∂glicherweise) aufweisen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum ist das alles? </font><font style="vertical-align: inherit;">Dar√ºber hinaus wird der CAP-Satz in der Form, in der er bewiesen ist, dass er praktisch nicht anwendbar ist, selten verwendet. </font><font style="vertical-align: inherit;">In einer theoretischen Form schr√§nkt es irgendwie alles ein. </font><font style="vertical-align: inherit;">Es stellt sich heraus, dass ein bestimmtes Prinzip intuitiv wahr ist, aber im Allgemeinen in keiner Weise bewiesen wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kausale Konsistenz - das st√§rkste Modell</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was jetzt passiert - Sie k√∂nnen alle drei Dinge erhalten: Konsistenz, Verf√ºgbarkeit kann √ºber Partitionen erhalten werden. </font><font style="vertical-align: inherit;">Insbesondere ist die kausale Konsistenz das st√§rkste Konsistenzmodell, das bei vorhandenen Partitionen (Netzwerkunterbrechungen) immer noch funktioniert. </font><font style="vertical-align: inherit;">Deshalb ist es von so gro√üem Interesse, und deshalb besch√§ftigen wir uns damit. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ty/4s/k8/ty4sk8sx4n73xnsxlkw2wtb1ity.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens vereinfacht es die Arbeit der Anwendungsentwickler. </font><font style="vertical-align: inherit;">Insbesondere der Server bietet viel Unterst√ºtzung: Wenn garantiert ist, dass alle Datens√§tze, die in einem Client vorkommen, in dieser Reihenfolge auf dem anderen Client eintreffen. </font><font style="vertical-align: inherit;">Zweitens h√§lt es Partitionen stand.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Innenk√ºche MongoDB</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir erinnern uns an das Mittagessen und gehen in die K√ºche. Ich werde √ºber das Systemmodell sprechen, n√§mlich was ist MongoDB f√ºr diejenigen, die zuerst von einer solchen Datenbank h√∂ren. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fn/-b/kj/fn-bkjwvkdxcokzum9xwwkshcu8.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/2u/qz/3g/2uqz3gts5ipfvvojtpo2epigtf4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MongoDB (im Folgenden als "MongoBD" bezeichnet) ist ein verteiltes System, das horizontale Skalierung, dh Sharding, unterst√ºtzt. und innerhalb jedes Shards unterst√ºtzt es auch Datenredundanz, d. h. Replikation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Sharding in "MongoBD" (nicht relationale Datenbank) f√ºhrt einen automatischen Ausgleich durch, dh jede Sammlung von Dokumenten (oder "Tabelle" in Bezug auf relationale Daten) in Teile, und der Server verschiebt sie bereits automatisch zwischen Shards. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Abfrage-Router, der Abfragen f√ºr den Client verteilt, ist ein Client, √ºber den er funktioniert. Er wei√ü bereits, wo und welche Daten sich befinden, sendet alle Anfragen an den richtigen Shard.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer wichtiger Punkt: MongoDB ist ein einzelner Master. </font><font style="vertical-align: inherit;">Es gibt eine Prim√§rdatenbank - sie kann Datens√§tze aufnehmen, die die darin enthaltenen Schl√ºssel unterst√ºtzen. </font><font style="vertical-align: inherit;">Sie k√∂nnen nicht mit mehreren Mastern schreiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben Release 4.2 gemacht - dort sind neue interessante Dinge aufgetaucht. </font><font style="vertical-align: inherit;">Insbesondere f√ºgten sie Lucene - die Suche - ein, es war ausf√ºhrbares Java direkt in "Mongo", und dort wurde es m√∂glich, Lucene zu durchsuchen, genau wie in "Elastic". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und sie haben ein neues Produkt entwickelt - Charts, das auch auf Atlas (Mongos eigene Cloud) verf√ºgbar ist. </font><font style="vertical-align: inherit;">Sie haben Free Tier - damit k√∂nnen Sie herumspielen. </font><font style="vertical-align: inherit;">Die Diagramme haben mir sehr gut gefallen - die Datenvisualisierung ist sehr intuitiv.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zutaten mit kausaler Konsistenz</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe ungef√§hr 230 Artikel gez√§hlt, die zu diesem Thema ver√∂ffentlicht wurden - von Leslie Lampert. </font><font style="vertical-align: inherit;">Aus meiner Erinnerung werde ich Ihnen einige Teile dieser Materialien bringen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/2_/dt/2n/2_dt2nhood8jlup51kyeddsy7w8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles begann mit einem Artikel von Leslie Lampert, der in den 1970er Jahren geschrieben wurde. </font><font style="vertical-align: inherit;">Wie Sie sehen, sind einige Untersuchungen zu diesem Thema noch nicht abgeschlossen. </font><font style="vertical-align: inherit;">Jetzt ist die kausale Konsistenz im Zusammenhang mit der Entwicklung verteilter Systeme von Interesse.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einschr√§nkungen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was sind die Einschr√§nkungen? </font><font style="vertical-align: inherit;">Dies ist tats√§chlich einer der Hauptpunkte, da sich die Einschr√§nkungen, die Produktionssysteme auferlegen, stark von den Einschr√§nkungen unterscheiden, die in wissenschaftlichen Artikeln bestehen. </font><font style="vertical-align: inherit;">Oft sind sie ziemlich k√ºnstlich.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qd/nh/ql/qdnhql6zcor1hzt53ur72spzqzy.jpeg"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstens ist ‚ÄûMongoDB‚Äú, wie ich bereits sagte, ein einzelner Master (dies vereinfacht sich erheblich).</font></font></li>
<li> ,   10     .     -  ,      .</li>
<li>   ,   ,      ,    binary,     ,    .</li>
<li>  ,   Research  :      . ¬´¬ª ‚Äì  . ,     ,  ‚Äì    .  ,     .</li>
<li>  ,     ‚Äì  :    ,   performance degradation   .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiterer Punkt ist im Allgemeinen antiakademisch: Kompatibilit√§t fr√ºherer und zuk√ºnftiger Versionen. </font><font style="vertical-align: inherit;">Alte Treiber m√ºssen neue Updates unterst√ºtzen, und die Datenbank muss alte Treiber unterst√ºtzen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All dies bringt im Allgemeinen Einschr√§nkungen mit sich.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kausale Konsistenzkomponenten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde jetzt √ºber einige der Komponenten sprechen. </font><font style="vertical-align: inherit;">Wenn wir die allgemeine kausale Konsistenz ber√ºcksichtigen, k√∂nnen wir Bl√∂cke unterscheiden. </font><font style="vertical-align: inherit;">Wir haben aus den Werken ausgew√§hlt, die zu einem bestimmten Block geh√∂ren: Abh√§ngigkeitsverfolgung, Auswahl der Stunden, wie diese Uhren miteinander synchronisiert werden k√∂nnen und wie wir die Sicherheit gew√§hrleisten - dies ist ein ungef√§hrer Plan dessen, wor√ºber ich sprechen werde:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zv/rb/rq/zvrbrqunyfdrj1pmbrjncugqed4.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollst√§ndige Abh√§ngigkeitsverfolgung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum wird es ben√∂tigt? Damit bei der Replikation der Daten - jeder Datensatz - jede Daten√§nderung Informationen dar√ºber enth√§lt, von welchen √Ñnderungen sie abh√§ngt. Die allererste und naive √Ñnderung ist, wenn jede Nachricht, die einen Datensatz enth√§lt, Informationen zu vorherigen Nachrichten enth√§lt: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gk/ue/jh/gkuejhztxm81mfji3fazhsmbmbm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel ist die Zahl in geschweiften Klammern die Anzahl der Datens√§tze. Manchmal werden diese Datens√§tze mit Werten sogar vollst√§ndig √ºbertragen, manchmal werden einige Versionen √ºbertragen. Die Quintessenz ist, dass jede √Ñnderung Informationen √ºber die vorherige enth√§lt (offensichtlich tr√§gt sie alles in sich).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum haben wir uns entschieden, diesen Ansatz nicht zu verwenden (vollst√§ndige Verfolgung)? </font><font style="vertical-align: inherit;">Weil dieser Ansatz unpraktisch ist: Jede √Ñnderung im sozialen Netzwerk h√§ngt von allen vorherigen √Ñnderungen in diesem sozialen Netzwerk ab und √ºbertr√§gt beispielsweise Facebook oder Vkontakte in jedem Update. </font><font style="vertical-align: inherit;">Trotzdem gibt es eine Menge Forschung, n√§mlich Full Dependency Tracking - dies sind soziale Netzwerke, in einigen Situationen funktioniert es wirklich.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explizite Abh√§ngigkeitsverfolgung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der n√§chste ist begrenzter. </font><font style="vertical-align: inherit;">Auch hier wird die √úbermittlung von Informationen ber√ºcksichtigt, aber nur das, was eindeutig davon abh√§ngt. </font><font style="vertical-align: inherit;">Was davon abh√§ngt, wird in der Regel bereits von der Anwendung festgelegt. </font><font style="vertical-align: inherit;">Wenn Daten repliziert werden, werden nur Antworten zur√ºckgegeben, wenn eine Anforderung gestellt wird, wenn vorherige Abh√§ngigkeiten erf√ºllt wurden, dh angezeigt werden. </font><font style="vertical-align: inherit;">Dies ist die Essenz der Funktionsweise der kausalen Konsistenz. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y_/jc/mw/y_jcmwt2w-vqj9guslui0wl8vgi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie sieht, dass Datensatz 5 von Datensatz 1, 2, 3, 4 abh√§ngt. Sie wartet, bis der Client Zugriff auf die √Ñnderungen erh√§lt, die durch Pennys Zugriffsverordnung vorgenommen wurden, wenn alle vorherigen √Ñnderungen bereits an die Datenbank √ºbergeben wurden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies passt auch nicht zu uns, weil es sowieso zu viele Informationen gibt, und dies wird sich verlangsamen. </font><font style="vertical-align: inherit;">Es gibt einen anderen Ansatz ...</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lamport Uhr</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie sind sehr alt. Lamport Clock impliziert, dass diese Abh√§ngigkeiten zu einer Skalarfunktion namens Lamport Clock zusammengefasst werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Skalarfunktion ist eine abstrakte Zahl. Oft als logische Zeit bezeichnet. Bei jedem Ereignis erh√∂ht sich dieser Z√§hler. Der dem Prozess derzeit bekannte Z√§hler sendet jede Nachricht. Es ist klar, dass Prozesse m√∂glicherweise nicht synchron sind und v√∂llig unterschiedliche Zeiten haben k√∂nnen. Trotzdem gleicht das System die Uhr irgendwie mit solchen Nachrichten aus. Was passiert in diesem Fall?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe diese gro√üe Scherbe in zwei Teile zerbrochen, so dass klar war: Freunde k√∂nnen in einem Knoten leben, der einen Teil der Sammlung enth√§lt, und Feed kann in einem anderen Knoten leben, der einen Teil dieser Sammlung enth√§lt. Es ist klar, wie sie aus der Reihe kommen k√∂nnen? Zuerst sagt Feed "Repliziert" und dann Freunde. Wenn das System keine Garantie daf√ºr bietet, dass der Feed erst angezeigt wird, wenn auch die Friends-Abh√§ngigkeiten in der Friends-Sammlung geliefert werden, haben wir nur eine Situation, die ich erw√§hnt habe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie sehen, wie sich die logische Z√§hlerzeit im Feed erh√∂ht:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gv/pz/vw/gvpzvwwxqonuthkwv6j2ez0fruc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher ist die Haupteigenschaft dieser Lamport-Uhr- und Kausalkonsistenz (erkl√§rt durch Lamport-Uhr) wie folgt: Wenn wir Ereignisse A und B haben und Ereignis B von Ereignis A * abh√§ngt, ist die LogicalTime von Ereignis A geringer als die LogicalTime von Ereignis B. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Manchmal sagen sie sogar, dass A vor B passiert ist, dh A vor B passiert ist - dies ist eine Art Beziehung, die teilweise die gesamte Menge von Ereignissen ordnet, die im Allgemeinen passiert sind.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Das Gegenteil ist falsch. Dies ist tats√§chlich einer der Hauptnachteile von Lamport Clock - Teilbestellung. Es gibt ein Konzept f√ºr gleichzeitige Ereignisse, dh Ereignisse, bei denen weder (A vor B) noch (A vor B) aufgetreten sind. Ein Beispiel ist die parallele Hinzuf√ºgung von Leonard zu Freunden eines anderen (nicht einmal Leonard, sondern Sheldon zum Beispiel).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist die Eigenschaft, die h√§ufig bei der Arbeit mit Lamport-Uhren verwendet wird: Sie sehen sich die Funktion genau an und ziehen daraus eine Schlussfolgerung - m√∂glicherweise sind diese Ereignisse abh√§ngig. </font><font style="vertical-align: inherit;">Denn in einer Richtung ist dies wahr: Wenn LogicalTime A kleiner als LogicalTime B ist, kann B nicht vor A auftreten; </font><font style="vertical-align: inherit;">und wenn mehr, dann vielleicht.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vektoruhr</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die logische Entwicklung von Lamport-Uhren ist die Vektoruhr. Sie unterscheiden sich darin, dass jeder Knoten, der sich hier befindet, eine eigene Uhr enth√§lt und als Vektor √ºbertragen wird. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall sehen Sie, dass der Nullindex des Vektors f√ºr den Feed verantwortlich ist und der erste Index des Vektors f√ºr Freunde (jeder dieser Knoten). Und jetzt werden sie zunehmen: Der Nullindex des "Feeds" steigt bei der Aufnahme - 1, 2, 3: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cv/xm/cd/cvxmcdiz_dgbjsu7elnj3xt2hcc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie ist die Vektoruhr besser? Die Tatsache, dass sie herausfinden k√∂nnen, welche Ereignisse gleichzeitig auftreten und wann sie auf verschiedenen Knoten auftreten. Dies ist sehr wichtig f√ºr ein Sharding-System wie das MongoBD. Wir haben uns jedoch nicht daf√ºr entschieden, obwohl es eine wunderbare Sache ist und gro√üartig funktioniert und wahrscheinlich zu uns passen w√ºrde ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir zehntausend Shards haben, k√∂nnen wir nicht zehntausend Komponenten √ºbertragen, selbst wenn wir komprimieren, denken wir uns etwas anderes aus - trotzdem ist die Nutzlast um ein Vielfaches geringer als das Volumen dieses gesamten Vektors. </font><font style="vertical-align: inherit;">Deshalb haben wir unsere Herzen und Z√§hne zusammengebissen, diesen Ansatz aufgegeben und sind zu einem anderen √ºbergegangen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spanner TrueTime. </font><font style="vertical-align: inherit;">Atomuhr</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich sagte, dass es eine Geschichte √ºber Spanner geben wird. Das ist eine coole Sache, genau im 21. Jahrhundert: Atomuhren, GPS-Synchronisation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Welche Idee? Spanner ist ein Google-System, das seit kurzem sogar f√ºr Benutzer verf√ºgbar ist (sie haben SQL daran angeh√§ngt). Jede Transaktion dort hat einen Zeitstempel. Da die Zeit synchronisiert ist *, kann jedem Ereignis eine bestimmte Zeit zugewiesen werden - die Atomuhr hat eine Wartezeit, nach der garantiert wird, dass eine andere Zeit auftritt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zn/vw/e3/znvwe3zwpqvjhsx-qglxpbqen9g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch einfaches Schreiben in die Datenbank und Warten auf einen bestimmten Zeitraum wird die Serialisierung des Ereignisses automatisch garantiert. Sie haben das st√§rkste Konsistenzmodell, das man sich im Prinzip vorstellen kann - es ist externe Konsistenz.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
* Dies ist das Hauptproblem von Lampart-Uhren - sie sind auf verteilten Systemen niemals synchron. </font><font style="vertical-align: inherit;">Sie k√∂nnen divergieren, auch mit NTP funktionieren sie immer noch nicht sehr gut. </font><font style="vertical-align: inherit;">"Spanner" hat eine Atomuhr und die Synchronisation scheint dann Mikrosekunden zu sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum haben wir uns nicht entschieden? </font><font style="vertical-align: inherit;">Wir gehen nicht davon aus, dass unsere Benutzer eine eingebaute Atomuhr haben. </font><font style="vertical-align: inherit;">Wenn sie erscheinen und in jeden Laptop eingebaut sind, wird es eine Art super coole GPS-Synchronisation geben - dann ja ... In der Zwischenzeit ist Amazon, Basisstationen f√ºr Fanatiker das Beste, was m√∂glich ist ... Deshalb haben wir andere Uhren verwendet.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hybriduhr</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist tats√§chlich das, was den ‚ÄûMongoBD‚Äú ankreuzt und gleichzeitig die kausale Konsistenz sicherstellt. </font><font style="vertical-align: inherit;">Was sind sie Hybrid? </font><font style="vertical-align: inherit;">Ein Hybrid ist ein Skalarwert, besteht jedoch aus zwei Komponenten:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hi/wz/uv/hiwzuvz-czbmb52b9iypojrr0_u.jpeg"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste ist die Unix-√Ñra (wie viele Sekunden sind seit dem "Beginn der Computerwelt" vergangen).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das zweite ist ein Inkrement, ebenfalls ein 32-Bit-Int ohne Vorzeichen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist eigentlich alles. </font><font style="vertical-align: inherit;">Es gibt einen solchen Ansatz: Der Teil, der f√ºr die Zeit verantwortlich ist, wird st√§ndig mit der Uhr synchronisiert; </font><font style="vertical-align: inherit;">Jedes Mal, wenn eine Aktualisierung erfolgt, wird dieser Teil mit der Uhr synchronisiert und es stellt sich heraus, dass die Zeit immer mehr oder weniger korrekt ist. Mit Inkrement k√∂nnen Sie zwischen Ereignissen unterscheiden, die zur gleichen Zeit aufgetreten sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum ist das f√ºr MongoBD wichtig? </font><font style="vertical-align: inherit;">Da Sie zu einem bestimmten Zeitpunkt Sicherungswiederherstellungen erstellen k√∂nnen, wird das Ereignis nach Zeit indiziert. </font><font style="vertical-align: inherit;">Dies ist wichtig, wenn einige Ereignisse ben√∂tigt werden. </font><font style="vertical-align: inherit;">Bei einer Datenbank sind Ereignisse √Ñnderungen an der Datenbank, die zu bestimmten Zeitpunkten auftreten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde Ihnen nur den wichtigsten Grund nennen (bitte sagen Sie es niemandem)! </font><font style="vertical-align: inherit;">Wir haben dies getan, weil geordnete, indizierte Daten in MongoDB OpLog so aussehen. </font><font style="vertical-align: inherit;">OpLog ist eine Datenstruktur, die absolut alle √Ñnderungen in der Datenbank enth√§lt: Sie gehen zuerst zu OpLog und werden dann bereits auf Storage selbst angewendet, wenn es sich um ein repliziertes Datum oder einen Shard handelt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das war der Hauptgrund. </font><font style="vertical-align: inherit;">Es gibt jedoch auch praktische Anforderungen f√ºr die Entwicklung der Datenbank, was bedeutet, dass es einfach sein sollte - es gibt wenig Code, so wenig kaputte Dinge wie m√∂glich, die neu geschrieben und getestet werden m√ºssen. </font><font style="vertical-align: inherit;">Die Tatsache, dass unsere Oplogs von einer Hybriduhr indiziert wurden, hat uns sehr geholfen und es uns erm√∂glicht, die richtige Wahl zu treffen. </font><font style="vertical-align: inherit;">Es hat sich wirklich ausgezahlt und irgendwie magisch funktioniert, beim allerersten Prototyp. </font><font style="vertical-align: inherit;">Es war sehr cool!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uhrensynchronisation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der wissenschaftlichen Literatur sind mehrere Synchronisationsmethoden beschrieben. </font><font style="vertical-align: inherit;">Ich spreche von Synchronisation, wenn wir zwei verschiedene Shards haben. </font><font style="vertical-align: inherit;">Wenn ein Replikatsatz vorhanden ist, ist dort keine Synchronisierung erforderlich: Es handelt sich um einen ‚Äûeinzelnen Master‚Äú. </font><font style="vertical-align: inherit;">Wir haben ein OpLog, in das alle √Ñnderungen eingehen - in diesem Fall ist alles bereits im "Oplog" selbst sequentiell geordnet. </font><font style="vertical-align: inherit;">Wenn wir jedoch zwei verschiedene Shards haben, ist hier die Zeitsynchronisation wichtig. </font><font style="vertical-align: inherit;">Hier haben Vektoruhren mehr geholfen! </font><font style="vertical-align: inherit;">Aber wir haben sie nicht. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ei/kq/bk/eikqbkbbzrsdquzxjxlzayc81qq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite ist Heartbeats. </font><font style="vertical-align: inherit;">Sie k√∂nnen einige Signale austauschen, die in jeder Zeiteinheit auftreten. </font><font style="vertical-align: inherit;">Aber Hartbits sind zu langsam, wir k√∂nnen unserem Kunden keine Latenz gew√§hren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wahre Zeit ist nat√ºrlich eine wunderbare Sache. </font><font style="vertical-align: inherit;">Aber auch dies ist wahrscheinlich die Zukunft ... Obwohl der Atlas bereits erstellt werden kann, gibt es bereits schnelle "amazonische" Zeitsynchronisierer. </font><font style="vertical-align: inherit;">Aber es wird nicht jedem zur Verf√ºgung stehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Klatschen ist, wenn alle Nachrichten Zeit enthalten. </font><font style="vertical-align: inherit;">Dies ist ungef√§hr das, was wir verwenden. </font><font style="vertical-align: inherit;">Jede Nachricht zwischen Knoten, einem Treiber, einem Router von Datenknoten, absolut alles f√ºr MongoDB sind einige Elemente, Datenbankkomponenten, die Stunden enthalten, die flie√üen. </font><font style="vertical-align: inherit;">√úberall dort, wo sie die Bedeutung von Hybridzeit haben, wird sie √ºbertragen. </font><font style="vertical-align: inherit;">64 Bit? </font><font style="vertical-align: inherit;">Es erlaubt, es ist m√∂glich.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie funktioniert das alles zusammen?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier schaue ich mir ein Replikatset an, um es ein bisschen einfacher zu machen. Es gibt prim√§re und sekund√§re. Secondary f√ºhrt die Replikation durch und ist nicht immer vollst√§ndig mit Primary synchronisiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den "Prim√§rfarben" befindet sich eine Einf√ºgung (Einf√ºgung) mit einem bestimmten Zeitwert. Dieser Einsatz erh√∂ht den internen Z√§hler um 11, wenn er maximal ist. Oder es √ºberpr√ºft die Uhrwerte und synchronisiert mit der Uhr, wenn die Uhr gr√∂√üer ist. Auf diese Weise k√∂nnen Sie nach Zeit sortieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem er eine Aufzeichnung gemacht hat, tritt ein wichtiger Moment ein. Die Stunden sind in "MongoDB" und werden nur erh√∂ht, wenn sie im "Oplog" aufgezeichnet sind. Dies ist ein Ereignis, das den Status des Systems √§ndert. In allen klassischen Artikeln wird ein Ereignis als eine Nachricht betrachtet, die in einen Knoten eingeht: Eine Nachricht ist eingetroffen - das hei√üt, das System hat seinen Status ge√§ndert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies liegt an der Tatsache, dass es w√§hrend der Studie nicht vollst√§ndig m√∂glich ist zu verstehen, wie diese Nachricht interpretiert wird. Wir wissen mit Sicherheit, dass wenn es nicht im ‚ÄûOplog‚Äú wiedergegeben wird, es in keiner Weise interpretiert wird und nur der Eintrag im ‚ÄûOplog‚Äú eine √Ñnderung des Systemzustands darstellt. Dies vereinfacht alles f√ºr uns: Das Modell vereinfacht und erm√∂glicht es uns, im Rahmen eines Replikatsatzes und vieler anderer n√ºtzlicher Dinge zu organisieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt den Wert zur√ºck, der bereits im ‚ÄûOplog‚Äú aufgezeichnet wurde - wir wissen, dass dieser Wert im ‚ÄûOplog‚Äú bereits liegt und seine Zeit 12 ist. Jetzt beginnt der Lesevorgang beispielsweise an einem anderen Knoten (sekund√§r) und wird bereits nach ClusterTime selbst √ºbertragen Botschaft. Er sagt: ‚ÄûIch brauche alles, was nach mindestens 12 oder zw√∂lf passiert ist‚Äú (siehe Abb. Oben).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies wird als Causal a Consistent (CAT) bezeichnet. Theoretisch gibt es ein solches Konzept, dass es sich um eine Zeitscheibe handelt, die an sich konsistent ist. In diesem Fall k√∂nnen wir sagen, dass dies der Zustand des Systems ist, der zum Zeitpunkt 12 beobachtet wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt gibt es hier nichts mehr, da es die Situation zu imitieren scheint, in der Secondary Daten von Primary replizieren muss. Er wartet ... Und jetzt sind die Daten gekommen - geben diese Werte zur√ºck. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/a1/q7/3q/a1q73qclyk9sn567b2x8szr_ejm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So funktioniert alles. Fast.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was bedeutet "fast"? Nehmen wir an, es gibt jemanden, der gelesen und verstanden hat, wie das alles funktioniert. Ich habe festgestellt, dass jedes Mal, wenn ClusterTime auftritt, die interne logische Uhr aktualisiert wird und der n√§chste Datensatz um eins erh√∂ht wird. Diese Funktion nimmt 20 Zeilen ein. Angenommen, diese Person √ºbertr√§gt die gr√∂√ütm√∂gliche 64-Bit-Zahl minus eins. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum ist minus eins? Da die interne Uhr durch diesen Wert ersetzt wird (dies ist offensichtlich die gr√∂√ütm√∂gliche und mehr als die aktuelle Zeit), wird im ‚ÄûOlog‚Äú ein Eintrag angezeigt, und die Uhr wird um einen weiteren erh√∂ht - und es gibt bereits einen Maximalwert (es gibt einfach alle Einheiten, es gibt keinen Weg mehr , vorzeichenlose Ints).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist klar, dass das System danach f√ºr nichts v√∂llig unzug√§nglich wird. </font><font style="vertical-align: inherit;">Es kann nur entladen, gereinigt werden - viel Handarbeit. </font><font style="vertical-align: inherit;">Volle Verf√ºgbarkeit: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/iu/lz/fs/iulzfslzcst3tn9c-qpouy9zqsk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn dies an einem anderen Ort repliziert wird, legt sich der gesamte Cluster einfach hin. </font><font style="vertical-align: inherit;">Eine absolut inakzeptable Situation, die jeder sehr schnell und einfach organisieren kann! </font><font style="vertical-align: inherit;">Daher haben wir diesen Moment als einen der wichtigsten angesehen. </font><font style="vertical-align: inherit;">Wie kann man das verhindern?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser Weg ist es, clusterTime zu signieren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So wird es in der Nachricht √ºbertragen (vor dem blauen Text). Wir haben aber auch begonnen, eine Signatur (blauer Text) zu generieren: Die </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zg/9r/iu/zg9riuabqzdlnw9dwttrwkwzkmi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Signatur wird von einem Schl√ºssel generiert, der in der Datenbank innerhalb des gesch√ºtzten Bereichs gespeichert ist. es wird generiert, aktualisiert (Benutzer sehen nichts). Hash wird generiert und jede Nachricht wird w√§hrend der Erstellung signiert und nach Erhalt validiert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wahrscheinlich stellt sich bei Menschen die Frage: "Wie sehr verlangsamt es sich?" Ich sagte, dass es schnell funktionieren sollte, insbesondere wenn diese Funktion nicht vorhanden ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was bedeutet es in diesem Fall, die kausale Konsistenz zu verwenden? Dies zeigt den Parameter afterClusterTime an. Und ohne es werden ohnehin einfach Werte √ºbergeben. Klatschen funktioniert seit Version 3.6 immer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir die st√§ndige Generierung von Signaturen verlassen, verlangsamt dies das System auch ohne Funktionen, die unseren Ans√§tzen und Anforderungen nicht entsprechen. </font><font style="vertical-align: inherit;">Und was haben wir getan?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mach es schnell!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine einfache Sache, aber der Trick ist interessant - ich werde es teilen, vielleicht wird jemand interessiert sein. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben einen Hash, der signierte Daten speichert. </font><font style="vertical-align: inherit;">Alle Daten durchlaufen den Cache. </font><font style="vertical-align: inherit;">Der Cache signiert nicht speziell die Zeit, sondern den Bereich. </font><font style="vertical-align: inherit;">Wenn ein bestimmter Wert erreicht ist, generieren wir einen Bereich, maskieren die letzten 16 Bits und signieren diesen Wert: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/s8/ml/3a/s8ml3aaec2pj5xl8t0zvkrp7iik.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch den Empfang einer solchen Signatur beschleunigen wir das System (bedingt) um das 65.000-fache. </font><font style="vertical-align: inherit;">Es funktioniert gro√üartig: Als sie die Experimente durchgef√ºhrt haben, wurde die Zeit, in der wir ein konsistentes Update hatten, dort wirklich um das Zehntausendfache reduziert. </font><font style="vertical-align: inherit;">Es ist klar, dass dies nicht funktioniert, wenn sie uneins sind. </font><font style="vertical-align: inherit;">In den meisten praktischen F√§llen funktioniert dies jedoch. </font><font style="vertical-align: inherit;">Die Kombination der Range-Signatur mit der Signatur l√∂ste das Sicherheitsproblem.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was haben wir gelernt?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lehren daraus haben wir gezogen:</font></font><br>
<br>
<ul>
<li>  , , ,       .     -  ( ,      . .),  , .   ,       ,    ,   .        ‚Äì   .<br>
<br>
,     ,      (¬´¬ª, ) ‚Äì      .     ?    .     ,      .   ‚Äì   ,   .</li>
<li>    .  ,        ¬´¬ª     ,   ,  ,      availability, latency  .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das letzte ist, dass wir verschiedene Ideen ber√ºcksichtigen und mehrere allgemein unterschiedliche Artikel zu einem Ansatz zusammenfassen mussten. </font><font style="vertical-align: inherit;">Die Idee zum Signieren kam zum Beispiel aus einem Artikel, in dem das Paxos-Protokoll untersucht wurde, das f√ºr nicht-byzantinisches Faylor innerhalb des Autorisierungsprotokolls und f√ºr byzantinische au√üerhalb des Autorisierungsprotokolls gilt. Im Allgemeinen haben wir dies letztendlich genau getan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier gibt es absolut nichts Neues! </font><font style="vertical-align: inherit;">Aber sobald wir alles zusammengemischt haben ... Es ist wie zu sagen, dass das Olivier-Salatrezept Unsinn ist, weil Eier, Mayonnaise und Gurken bereits erfunden wurden ... Es geht um die gleiche Geschichte.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/6o/pc/q8/6opcq8ew4bcry9qnt0lsdlasflo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit werde ich enden. </font><font style="vertical-align: inherit;">Danke!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragen</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frage des Publikums (im Folgenden - B):</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Danke, Michael f√ºr den Bericht! Das Thema Zeit ist interessant. Sie verwenden Klatschen. Sie sagten, dass jeder seine eigene Zeit hat, jeder seine Ortszeit kennt. So wie ich es verstehe, haben wir einen Treiber - es kann viele Clients mit Treibern geben, auch Abfrageplaner, viele Shards ... Aber was wird das System tun, wenn wir pl√∂tzlich eine Diskrepanz haben: Jemand entscheidet, dass er f√ºr eine Minute ist voraus, jemand - eine Minute dahinter? Wo werden wir uns befinden? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Wirklich eine gute Frage! Ich wollte nur √ºber Scherben sagen. Wenn ich die Frage richtig verstehe, haben wir diese Situation: Es gibt Shard 1 und Shard 2, das Lesen erfolgt von diesen beiden Shards - sie haben eine Diskrepanz, sie interagieren nicht miteinander, weil die Zeit, die sie kennen, unterschiedlich ist, insbesondere die Zeit, die Sie existieren in Oplogs.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, Shard 1 hat eine Million Datens√§tze gemacht, Shard 2 hat √ºberhaupt nichts getan, und die Anfrage kam in zwei Shards. Und der erste hat afterClusterTime √ºber eine Million. In einer solchen Situation wird Shard 2, wie ich bereits erkl√§rt habe, niemals reagieren. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ich wollte wissen, wie sie synchronisieren und eine logische Zeit ausw√§hlen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Sehr einfach zu synchronisieren. Shard, wenn afterClusterTime zu ihm kommt und er die Zeit nicht im "Catch" findet - initiiert keine genehmigte. Das hei√üt, er hebt seine H√§nde mit seinen H√§nden auf diesen Wert. Dies bedeutet, dass keine Ereignisse vorhanden sind, die dieser Abfrage entsprechen. Er schafft dieses Ereignis k√ºnstlich und wird so zum Causal Consistent. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Und wenn danach noch einige andere Ereignisse zu ihm kommen, die irgendwo im Netzwerk verloren gegangen sind? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Die Scherbe ist so angeordnet, dass sie nicht mehr kommt, da es sich um einen einzelnen Meister handelt. Wenn er bereits aufgenommen hat, werden sie nicht kommen, sondern danach sein. Es kann nicht passieren, dass irgendwo etwas steckt, dann wird er nicht schreiben, und dann sind diese Ereignisse eingetroffen - und die kausale Konsistenz wurde verletzt. Wenn er nicht schreibt, m√ºssen sie alle als n√§chstes kommen (er wird auf sie warten). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t2/wb/oo/t2wboofhfs7qpepqz8zwsm1o0u4.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BEIM:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ich habe ein paar Fragen zu den Zeilen. Die kausale Konsistenz setzt voraus, dass eine bestimmte Warteschlange von Aktionen ausgef√ºhrt werden muss. Was passiert, wenn wir ein Paket verlieren? Also ging der 10., der 11. ... der 12. verschwand und alle anderen warten darauf, dass er erf√ºllt wird. Und pl√∂tzlich ist unser Auto gestorben, wir k√∂nnen nichts mehr tun. Gibt es eine maximale Warteschlangenl√§nge, die sich ansammelt, bevor sie ausgef√ºhrt wird? Welcher fatale Fehler tritt auf, wenn ein Zustand verloren geht? Wenn wir dar√ºber hinaus aufschreiben, dass es einen fr√ºheren Zustand gibt, sollten wir dann irgendwie davon ausgehen? Und sie haben nicht von ihm gesto√üen! </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Auch eine wunderbare Frage! Was machen wir? MongoDB hat das Konzept von Quorum-Datens√§tzen, Quorum liest. Wann kann eine Nachricht verschwinden? Wenn der Datensatz nicht beschlussf√§hig ist oder wenn der Messwert nicht beschlussf√§hig ist (etwas M√ºll kann auch haften bleiben). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Bezug auf die kausale Konsistenz haben wir einen gro√üen experimentellen Test durchgef√ºhrt. Das Ergebnis war, dass Verst√∂√üe gegen die kausale Konsistenz auftreten, wenn Aufzeichnung und Lesen nicht beschlussf√§hig sind. Genau das, was du sagst!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser Tipp: Verwenden Sie bei Verwendung der kausalen Konsistenz mindestens das Quorum. In diesem Fall geht nichts verloren, auch wenn der Quorumdatensatz verloren geht ... Dies ist eine orthogonale Situation: Wenn der Benutzer nicht m√∂chte, dass die Daten verloren gehen, m√ºssen Sie den Quorumdatensatz verwenden. Die kausale Konsistenz garantiert keine Haltbarkeit. Die Haltbarkeitsgarantie wird durch Replikation und mit der Replikation verbundene Maschinen gew√§hrleistet. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Wenn wir eine Instanz erstellen, die Sharding f√ºr uns erledigt (nicht Master, sondern Slave), h√§ngt sie von der Unix-Zeit ihrer eigenen Maschine oder von der Zeit des ‚ÄûMasters‚Äú ab. zum ersten Mal oder regelm√§√üig synchronisiert? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Jetzt mache ich es klar. Scherbe (d. H. Horizontale Trennwand) - es gibt immer Prim√§r. Und in einer Scherbe kann es einen ‚ÄûMeister‚Äú geben und es kann Repliken geben. Der Shard unterst√ºtzt jedoch immer das Schreiben, da er eine bestimmte Dom√§ne unterst√ºtzen muss (Primary befindet sich im Shard). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Das hei√üt, alles h√§ngt nur vom "Meister" ab? Immer die "Master" -Zeit verwenden? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ja. Sie k√∂nnen im √ºbertragenen Sinne sagen: Die Uhr tickt, wenn es eine Aufnahme im "Master", im "Olog" gibt. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Wir haben einen Kunden, der eine Verbindung herstellt und der nichts √ºber die Zeit wissen muss. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Im Allgemeinen m√ºssen Sie nichts wissen! Wenn wir dar√ºber sprechen, wie es auf dem Client funktioniert: Wenn er auf dem Client die kausale Konsistenz verwenden m√∂chte, muss er eine Sitzung √∂ffnen. Jetzt ist alles da: beide Transaktionen in der Sitzung und das Abrufen von Rechten ... Eine Sitzung ist eine Reihenfolge von logischen Ereignissen, die mit einem Client auftreten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn er diese Sitzung √∂ffnet und dort sagt, dass er kausale Konsistenz w√ºnscht (wenn die Sitzung standardm√§√üig kausale Konsistenz unterst√ºtzt), funktioniert alles automatisch. Der Fahrer merkt sich diese Zeit und erh√∂ht sie, wenn er eine neue Nachricht erh√§lt. Es merkt sich, welche Antwort die vorherige vom Server zur√ºckgegeben hat, der die Daten zur√ºckgegeben hat. Die folgende Anforderung enth√§lt afterCluster ("Zeit ist gr√∂√üer als diese").</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Kunde muss absolut nichts wissen! Das ist f√ºr ihn absolut undurchsichtig. Was kann ich tun, wenn Benutzer diese Funktionen verwenden? Erstens k√∂nnen Sie Secondaries sicher lesen: Sie k√∂nnen in Primary schreiben und aus geografisch replizierten Secondaries lesen und sicherstellen, dass es funktioniert. Gleichzeitig k√∂nnen die auf Primary aufgezeichneten Sitzungen sogar auf Secondary √ºbertragen werden, dh Sie k√∂nnen nicht eine Sitzung, sondern mehrere verwenden. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Das Thema "Eventuelle Konsistenz" ist stark mit der neuen Compute Science-Schicht verkn√ºpft - CRDT-Datentypen (Conflict-free Replicated Data Types). Haben Sie √ºber die Integration dieser Datentypen in die Datenbank nachgedacht und was k√∂nnen Sie dazu sagen? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Gute Frage! CRDT ist sinnvoll f√ºr Schreibkonflikte: in MongoDB - Single Master. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BEIM:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ich habe eine Frage von den Devops. In der realen Welt gibt es solche Jesuitensituationen, in denen das byzantinische Versagen eintritt und die b√∂sen Menschen innerhalb des gesch√ºtzten Bereichs beginnen, sich an das Protokoll zu halten und Handwerkspakete auf besondere Weise zu senden? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/8d/m3/p5/8dm3p5em6rsqsv2ojzy-vdylffg.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - B√∂se Menschen im Umkreis sind wie ein trojanisches Pferd! B√∂se Menschen im Umkreis k√∂nnen viele schlechte Dinge tun. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Es ist klar, dass Sie grob gesagt ein Loch im Server lassen, durch das Sie den Elefantenzoo stecken und den gesamten Cluster f√ºr immer zusammenbrechen k√∂nnen. Die manuelle Wiederherstellung wird einige Zeit in Anspruch nehmen. Dies ist, gelinde gesagt, falsch. Auf der anderen Seite ist dies merkw√ºrdig: In der Praxis gibt es in der Praxis Situationen, in denen nat√ºrlich √§hnliche interne Angriffe auftreten? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Da ich im wirklichen Leben selten auf Sicherheitsverletzungen sto√üe, kann ich nicht sagen - vielleicht passieren sie. Aber wenn wir √ºber Entwicklungsphilosophie sprechen, dann denken wir so: Wir haben einen Umkreis, der den Leuten Sicherheit bietet - es ist eine Burg, eine Mauer; und innerhalb des Perimeters k√∂nnen Sie alles tun, was Sie wollen. Es ist klar, dass es Benutzer gibt, die nur schauen k√∂nnen, und es gibt Benutzer, die das Verzeichnis l√∂schen k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abh√§ngig von den Rechten kann der Schaden, den Benutzer anrichten k√∂nnen, eine Maus oder ein Elefant sein. Es ist klar, dass ein Benutzer mit vollen Rechten √ºberhaupt alles tun kann. Ein Benutzer mit nicht weitreichenden Schadensrechten kann erheblich weniger verursachen. Insbesondere kann er das System nicht brechen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BEIM:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Im sicheren Bereich kletterte jemand, um unerwartete Protokolle f√ºr den Server zu erstellen, um den Server mit Krebs einzurichten, und wenn Sie Gl√ºck haben, dann den gesamten Cluster ... Kommt es jemals so "gut" vor? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ich habe noch nie von solchen Dingen geh√∂rt. Die Tatsache, dass Sie auf diese Weise den Server f√ºllen k√∂nnen, ist kein Geheimnis. Um sich darin zu f√ºllen, aus dem Protokoll zu stammen, ein autorisierter Benutzer zu sein, der so etwas in eine Nachricht schreiben kann ... Eigentlich ist es unm√∂glich, weil es sowieso √ºberpr√ºft wird. Es ist m√∂glich, diese Authentifizierung f√ºr Benutzer zu deaktivieren, die dies nicht m√∂chten. Dies ist dann ihr Problem. Grob gesagt haben sie selbst die Mauern zerst√∂rt und Sie k√∂nnen dort einen Elefanten stopfen, der mit F√º√üen treten wird ... Im Allgemeinen k√∂nnen Sie sich als Handwerker verkleiden, kommen und ihn holen! </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BEIM:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Danke f√ºr den Bericht. </font><font style="vertical-align: inherit;">Sergey (Yandex). </font><font style="vertical-align: inherit;">In ‚ÄûMong‚Äú gibt es eine Konstante, die die Anzahl der stimmberechtigten Mitglieder im Replikatsatz begrenzt, und diese Konstante betr√§gt 7 (sieben). </font><font style="vertical-align: inherit;">Warum ist das eine Konstante? </font><font style="vertical-align: inherit;">Warum ist das kein Parameter? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Replica Set Wir haben auch 40 Knoten. </font><font style="vertical-align: inherit;">Es gibt immer eine Mehrheit. </font><font style="vertical-align: inherit;">Ich wei√ü nicht, welche Version ... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Im Replikatset k√∂nnen Sie nicht stimmberechtigte Mitglieder ausf√ºhren, aber maximal 7 abstimmen. Wie k√∂nnen Sie dann deaktivieren, wenn das Replikatset in 3 Rechenzentren gezogen wird? </font><font style="vertical-align: inherit;">Ein Rechenzentrum kann leicht ausgeschaltet werden, und ein anderer Computer f√§llt aus. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Dies liegt bereits etwas au√üerhalb des Berichtsbereichs. </font><font style="vertical-align: inherit;">Dies ist eine h√§ufige Frage. </font><font style="vertical-align: inherit;">Vielleicht kann ich es ihm dann sagen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9t/cr/ga/9tcrgaodiufisllhrktf_5iok_a.jpeg"><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/UnAprFMX1d4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein bisschen Werbung :)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielen Dank f√ºr Ihren Aufenthalt bei uns. Gef√§llt dir unser Artikel? M√∂chten Sie weitere interessante Materialien sehen? Unterst√ºtzen Sie uns, indem Sie eine Bestellung </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">aufgeben</font></a><font style="vertical-align: inherit;"> oder Ihren Freunden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloud-basiertes VPS f√ºr Entwickler ab 4,99 US-Dollar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> empfehlen </font><font style="vertical-align: inherit;">, ein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einzigartiges Analogon von Einstiegsservern, das von uns f√ºr Sie erfunden wurde: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die ganze Wahrheit √ºber VPS (KVM) E5-2697 v3 (6 Kerne) 10 GB DDR4 480 GB SSD 1 Gbit / s ab 19 $ oder wie teilt man den Server?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Optionen sind mit RAID1 und RAID10, bis zu 24 Kernen und bis zu 40 GB DDR4 verf√ºgbar). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xd 2-mal g√ºnstiger im Equinix Tier IV-Rechenzentrum in Amsterdam?</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nur wir haben </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2,6 GHz 14C 64 GB DDR4 4 x 960 GB SSD 1 Gbit / s 100 TV von 199 US-Dollar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in den Niederlanden!</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R420 - 2x E5-2430 2,2 GHz 6C 128 GB DDR3 2x960 GB SSD 1 Gbit / s 100 TB - ab 99 US-Dollar! </font></font></b></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr √ºber</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den Aufbau eines Infrastrukturgeb√§udes. </font><font style="vertical-align: inherit;">Klasse C mit Dell R730xd E5-2650 v4-Servern f√ºr 9.000 Euro pro Cent?</font></font></a></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de487626/index.html">Wie Parksensoren funktionieren und wie man ihn austrickst</a></li>
<li><a href="../de487628/index.html">Diagnose des Alterns anhand von 9 Kennzeichen der Alterungserscheinungen</a></li>
<li><a href="../de487630/index.html">Der einfachste Algorithmus zum Erstellen eines Feldpuzzles (Teil 1)</a></li>
<li><a href="../de487632/index.html">‚ÄûKollegen, atmen Sie leiser‚Äú: Warum uns B√ºrol√§rm verr√ºckt macht - wir diskutieren √ºber Forschung</a></li>
<li><a href="../de487636/index.html">APIs, f√ºr die es sich endlich lohnt, ein Upgrade von Java 8 durchzuf√ºhren. Teil 2</a></li>
<li><a href="../de487640/index.html">Testen der Spielautomatisierung</a></li>
<li><a href="../de487644/index.html">Abrufen von B√∂rsenkursen mit Python</a></li>
<li><a href="../de487646/index.html">Reagenzglas-Neutronenstern. Sonolumineszenz</a></li>
<li><a href="../de487648/index.html">Es k√∂nnte ein anderes Javascript-Framework sein.</a></li>
<li><a href="../de487650/index.html">Hoffe auf das SDK und mache nichts falsch: Das Problem verschachtelter Schriftrollen im BottomSheetBehavior</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>