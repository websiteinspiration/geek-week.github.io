<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😙 👨‍👩‍👧‍👧 🦑 HighLoad ++, Mikhail Tyulenev (MongoDB): Kausale Konsistenz: von der Theorie zur Praxis 👩🏿‍⚖️ ☹️ 🐫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die nächste HighLoad ++ - Konferenz findet am 6. und 7. April 2020 in St. Petersburg statt. 
 Details und Tickets hier . HighLoad ++ Sibirien 2019. Ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>HighLoad ++, Mikhail Tyulenev (MongoDB): Kausale Konsistenz: von der Theorie zur Praxis</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/487638/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die nächste HighLoad ++ - Konferenz findet am 6. und 7. April 2020 in St. Petersburg statt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Details und Tickets </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . HighLoad ++ Sibirien 2019. Halle "Krasnojarsk". 25. Juni, 12:00 Uhr. Abstracts und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Präsentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ok/iw/mz/okiwmzx4qkp6dxvjvqjxvfzqtnk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es kommt vor, dass praktische Anforderungen im Widerspruch zu einer Theorie stehen, bei der Aspekte, die für ein kommerzielles Produkt wichtig sind, nicht berücksichtigt werden. In diesem Bericht wird der Prozess der Auswahl und Kombination verschiedener Ansätze zur Erstellung kausaler Konsistenzkomponenten auf der Grundlage akademischer Forschung auf der Grundlage der Anforderungen eines kommerziellen Produkts vorgestellt. Die Schüler lernen die bestehenden theoretischen Ansätze für logische Uhren, Abhängigkeitsverfolgung, Systemsicherheit, Uhrensynchronisation und warum MongoDB diese oder jene Lösungen eingestellt hat.</font></font><a name="habracut"></a><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mikhail Tyulenev (im Folgenden - MT):</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ich werde über kausale Konsistenz sprechen - Dies ist eine Funktion, an der wir in MongoDB gearbeitet haben. </font><font style="vertical-align: inherit;">Ich arbeite in einer Gruppe verteilter Systeme, wir haben es vor ungefähr zwei Jahren gemacht. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ih/xx/xg/ihxxxghkrknnqdxg7tb4w97izi0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dabei musste ich mich mit viel akademischer Forschung vertraut machen, da diese Funktion gut untersucht ist. </font><font style="vertical-align: inherit;">Es stellte sich heraus, dass kein einziger Artikel in die Anforderungen der Produktion passt, die Datenbank angesichts der sehr spezifischen Anforderungen, die wahrscheinlich in Produktionsanwendungen gestellt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde darüber sprechen, wie wir als Verbraucher akademischer Forschung etwas daraus zubereiten, das wir unseren Benutzern dann als fertiges Gericht präsentieren können, das bequem und sicher zu verwenden ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kausale Konsistenz. </font><font style="vertical-align: inherit;">Definieren wir Konzepte</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst möchte ich allgemein skizzieren, was kausale Konsistenz ist. Es gibt zwei Charaktere - Leonard und Penny (die Serie „The Big Bang Theory“): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7q/nw/lr/7qnwlrmqtidow8cl_jrdakec3d0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, Penny ist in Europa und Leonard möchte eine Art Überraschung für sie machen, eine Party. Und er hat nichts Besseres gefunden, als sie von der Freundesliste zu streichen und Updates zu senden, um alle Freunde zu füttern: "Lass uns Penny glücklich machen!" (Sie in Europa sieht im Schlaf nicht alles und kann nicht sehen, weil sie nicht da ist.) Am Ende wird dieser Beitrag gelöscht, aus dem "Feed" gelöscht und der Zugriff wiederhergestellt, sodass nichts bemerkt wird und kein Skandal auftritt.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles in Ordnung, aber nehmen wir an, dass das System verteilt ist und die Ereignisse etwas schief gelaufen sind. </font><font style="vertical-align: inherit;">Möglicherweise kommt es beispielsweise vor, dass die Penny-Zugriffsbeschränkung nach dem Erscheinen dieses Beitrags aufgetreten ist, wenn die Ereignisse nicht durch einen Kausalzusammenhang verbunden sind. </font><font style="vertical-align: inherit;">Tatsächlich ist dies ein Beispiel dafür, wann kausale Konsistenz erforderlich ist, um eine Geschäftsfunktion zu erfüllen (in diesem Fall). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich sind dies nicht triviale Eigenschaften der Datenbank - nur sehr wenige Menschen unterstützen sie. </font><font style="vertical-align: inherit;">Kommen wir zu den Modellen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konsistenzmodelle</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist ein Konsistenzmodell in Datenbanken im Allgemeinen? </font><font style="vertical-align: inherit;">Dies sind einige der Garantien, die ein verteiltes System in Bezug darauf gibt, welche Daten und in welcher Reihenfolge der Client empfangen kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grundsätzlich kommt es bei allen Konsistenzmodellen darauf an, wie verteilt das System wie ein System ist, das beispielsweise auf einem Laptop mit demselben Nicken funktioniert. </font><font style="vertical-align: inherit;">Und so sehr ähnelt das System, das auf Tausenden von geoverteilten „Knoten“ funktioniert, einem Laptop, bei dem alle diese Eigenschaften im Prinzip automatisch ausgeführt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher gelten Konsistenzmodelle nur für verteilte Systeme. </font><font style="vertical-align: inherit;">Bei allen Systemen, die zuvor mit derselben vertikalen Skalierung existierten und arbeiteten, traten solche Probleme nicht auf. </font><font style="vertical-align: inherit;">Es gab einen Puffer-Cache, aus dem immer alles gelesen wurde.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starkes Modell</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich ist das allererste Modell Stark (oder die Linie der Aufstiegsfähigkeit, wie sie oft genannt wird). </font><font style="vertical-align: inherit;">Dies ist ein Konsistenzmodell, das sicherstellt, dass jede Änderung für alle Benutzer des Systems sichtbar ist, sobald eine Bestätigung eingeht, dass sie stattgefunden hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dadurch wird eine globale Reihenfolge aller Ereignisse in der Datenbank erstellt. </font><font style="vertical-align: inherit;">Dies ist eine sehr starke Konsistenz-Eigenschaft und im Allgemeinen sehr teuer. </font><font style="vertical-align: inherit;">Es ist jedoch sehr gut gepflegt. </font><font style="vertical-align: inherit;">Es ist einfach sehr teuer und langsam - sie werden einfach selten verwendet. </font><font style="vertical-align: inherit;">Dies nennt man Aufstiegsfähigkeit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt eine weitere, leistungsstärkere Eigenschaft, die im "Spanner" unterstützt wird - die externe Konsistenz. </font><font style="vertical-align: inherit;">Wir werden etwas später über ihn sprechen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kausal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Folgende ist Kausal, genau das, worüber ich gesprochen habe. Es gibt mehrere Unterebenen zwischen Stark und Kausal, über die ich nicht sprechen werde, aber alle sind auf Kausal zurückzuführen. Dies ist ein wichtiges Modell, da es das stärkste aller Modelle ist und die stärkste Konsistenz bei Vorhandensein eines Netzwerks oder von Partitionen aufweist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kausale ist eigentlich eine Situation, in der Ereignisse durch einen Kausalzusammenhang verbunden sind. Sehr oft werden sie aus Sicht des Kunden als Read your on-Rechte wahrgenommen. Wenn der Kunde einige Werte beobachtet hat, kann er die Werte in der Vergangenheit nicht sehen. Er beginnt bereits, Präfixablesungen zu sehen. Es kommt alles auf dasselbe an.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kausale als Konsistenzmodell sind eine Teilreihenfolge von Ereignissen auf dem Server, bei der Ereignisse von allen Clients in derselben Reihenfolge beobachtet werden. </font><font style="vertical-align: inherit;">In diesem Fall Leonard und Penny.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eventuell</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das dritte Modell ist die eventuelle Konsistenz. Dies unterstützt absolut alle verteilten Systeme, ein Minimalmodell, das im Allgemeinen Sinn macht. Dies bedeutet Folgendes: Wenn sich die Daten ändern, werden sie irgendwann konsistent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einem solchen Moment sagt sie nichts, sonst würde sie sich in externe Konsistenz verwandeln - es würde eine ganz andere Geschichte geben. Trotzdem ist dies ein sehr beliebtes Modell, das häufigste. Standardmäßig verwenden alle Benutzer verteilter Systeme Eventual Consistency. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich möchte einige vergleichende Beispiele geben: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yn/5s/p9/yn5sp9tyjn4dh4q3vonroirvxic.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was bedeuten diese Pfeile?</font></font><br>
<br>
<ul>
<li><b>Latency.</b>          :    ,       ,    ,     .   Eventual Consistency   ,   ,  ,    memory       .</li>
<li><b>Availability.</b>           , partitions,  -  –      ,    ,         - . Eventual Consistency        –    ,  .</li>
<li><b>Anomalies.</b>  , ,   .  Strong Consistency       ,  Eventual Consistency     .  :     Eventual Consistency,    ?    ,  Eventual Consistency- ,   , ,    ;        -   ;       .   ,       .</li>
</ul><br>
<h3> CAP</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie die Wörter Konsistenz, Verfügbarkeit sehen - woran denken Sie? Richtig - CAP-Theorem! Jetzt möchte ich den Mythos zerstreuen ... Ich bin es nicht - da ist Martin Kleppman, der einen wunderbaren Artikel geschrieben hat, ein wundervolles Buch. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-k/rc/v1/-krcv1vofhv9ofnwbty6ql6hvhg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das CAP-Theorem ist ein in den 2000er Jahren formuliertes Prinzip: Konsistenz, Verfügbarkeit, Partitionen: Nehmen Sie zwei, und Sie können nicht drei auswählen. Es war ein bestimmtes Prinzip. Einige Jahre später wurde es von Gilbert und Lynch als Theorem bewiesen. Dann wurde es als Mantra verwendet - Systeme wurden in CA, CP, AP usw. unterteilt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Satz wurde tatsächlich aus folgenden Gründen bewiesen ... Erstens wurde Verfügbarkeit nicht als kontinuierlicher Wert von Null bis Hundert betrachtet (0 - das System ist "tot", 100 - Antworten schnell; wir sind es gewohnt, ihn zu berücksichtigen), sondern als eine Eigenschaft des Algorithmus Dies stellt sicher, dass bei allen Ausführungen Daten zurückgegeben werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt kein Wort über die Reaktionszeit! Es gibt einen Algorithmus, der Daten nach 100 Jahren zurückgibt - einen perfekt verfügbaren Algorithmus, der Teil des CAP-Theorems ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens: Es wurde ein Satz für Änderungen der Werte desselben Schlüssels bewiesen, obwohl diese Änderungen eine veränderbare Linie sind. Dies bedeutet, dass sie tatsächlich praktisch nicht verwendet werden, da die Modelle unterschiedliche mögliche Konsistenz, starke Konsistenz (möglicherweise) aufweisen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum ist das alles? </font><font style="vertical-align: inherit;">Darüber hinaus wird der CAP-Satz in der Form, in der er bewiesen ist, dass er praktisch nicht anwendbar ist, selten verwendet. </font><font style="vertical-align: inherit;">In einer theoretischen Form schränkt es irgendwie alles ein. </font><font style="vertical-align: inherit;">Es stellt sich heraus, dass ein bestimmtes Prinzip intuitiv wahr ist, aber im Allgemeinen in keiner Weise bewiesen wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kausale Konsistenz - das stärkste Modell</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was jetzt passiert - Sie können alle drei Dinge erhalten: Konsistenz, Verfügbarkeit kann über Partitionen erhalten werden. </font><font style="vertical-align: inherit;">Insbesondere ist die kausale Konsistenz das stärkste Konsistenzmodell, das bei vorhandenen Partitionen (Netzwerkunterbrechungen) immer noch funktioniert. </font><font style="vertical-align: inherit;">Deshalb ist es von so großem Interesse, und deshalb beschäftigen wir uns damit. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ty/4s/k8/ty4sk8sx4n73xnsxlkw2wtb1ity.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens vereinfacht es die Arbeit der Anwendungsentwickler. </font><font style="vertical-align: inherit;">Insbesondere der Server bietet viel Unterstützung: Wenn garantiert ist, dass alle Datensätze, die in einem Client vorkommen, in dieser Reihenfolge auf dem anderen Client eintreffen. </font><font style="vertical-align: inherit;">Zweitens hält es Partitionen stand.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Innenküche MongoDB</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir erinnern uns an das Mittagessen und gehen in die Küche. Ich werde über das Systemmodell sprechen, nämlich was ist MongoDB für diejenigen, die zuerst von einer solchen Datenbank hören. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fn/-b/kj/fn-bkjwvkdxcokzum9xwwkshcu8.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/2u/qz/3g/2uqz3gts5ipfvvojtpo2epigtf4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MongoDB (im Folgenden als "MongoBD" bezeichnet) ist ein verteiltes System, das horizontale Skalierung, dh Sharding, unterstützt. und innerhalb jedes Shards unterstützt es auch Datenredundanz, d. h. Replikation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Sharding in "MongoBD" (nicht relationale Datenbank) führt einen automatischen Ausgleich durch, dh jede Sammlung von Dokumenten (oder "Tabelle" in Bezug auf relationale Daten) in Teile, und der Server verschiebt sie bereits automatisch zwischen Shards. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Abfrage-Router, der Abfragen für den Client verteilt, ist ein Client, über den er funktioniert. Er weiß bereits, wo und welche Daten sich befinden, sendet alle Anfragen an den richtigen Shard.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer wichtiger Punkt: MongoDB ist ein einzelner Master. </font><font style="vertical-align: inherit;">Es gibt eine Primärdatenbank - sie kann Datensätze aufnehmen, die die darin enthaltenen Schlüssel unterstützen. </font><font style="vertical-align: inherit;">Sie können nicht mit mehreren Mastern schreiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben Release 4.2 gemacht - dort sind neue interessante Dinge aufgetaucht. </font><font style="vertical-align: inherit;">Insbesondere fügten sie Lucene - die Suche - ein, es war ausführbares Java direkt in "Mongo", und dort wurde es möglich, Lucene zu durchsuchen, genau wie in "Elastic". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und sie haben ein neues Produkt entwickelt - Charts, das auch auf Atlas (Mongos eigene Cloud) verfügbar ist. </font><font style="vertical-align: inherit;">Sie haben Free Tier - damit können Sie herumspielen. </font><font style="vertical-align: inherit;">Die Diagramme haben mir sehr gut gefallen - die Datenvisualisierung ist sehr intuitiv.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zutaten mit kausaler Konsistenz</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe ungefähr 230 Artikel gezählt, die zu diesem Thema veröffentlicht wurden - von Leslie Lampert. </font><font style="vertical-align: inherit;">Aus meiner Erinnerung werde ich Ihnen einige Teile dieser Materialien bringen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/2_/dt/2n/2_dt2nhood8jlup51kyeddsy7w8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles begann mit einem Artikel von Leslie Lampert, der in den 1970er Jahren geschrieben wurde. </font><font style="vertical-align: inherit;">Wie Sie sehen, sind einige Untersuchungen zu diesem Thema noch nicht abgeschlossen. </font><font style="vertical-align: inherit;">Jetzt ist die kausale Konsistenz im Zusammenhang mit der Entwicklung verteilter Systeme von Interesse.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einschränkungen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was sind die Einschränkungen? </font><font style="vertical-align: inherit;">Dies ist tatsächlich einer der Hauptpunkte, da sich die Einschränkungen, die Produktionssysteme auferlegen, stark von den Einschränkungen unterscheiden, die in wissenschaftlichen Artikeln bestehen. </font><font style="vertical-align: inherit;">Oft sind sie ziemlich künstlich.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qd/nh/ql/qdnhql6zcor1hzt53ur72spzqzy.jpeg"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstens ist „MongoDB“, wie ich bereits sagte, ein einzelner Master (dies vereinfacht sich erheblich).</font></font></li>
<li> ,   10     .     -  ,      .</li>
<li>   ,   ,      ,    binary,     ,    .</li>
<li>  ,   Research  :      . «» –  . ,     ,  –    .  ,     .</li>
<li>  ,     –  :    ,   performance degradation   .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiterer Punkt ist im Allgemeinen antiakademisch: Kompatibilität früherer und zukünftiger Versionen. </font><font style="vertical-align: inherit;">Alte Treiber müssen neue Updates unterstützen, und die Datenbank muss alte Treiber unterstützen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All dies bringt im Allgemeinen Einschränkungen mit sich.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kausale Konsistenzkomponenten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde jetzt über einige der Komponenten sprechen. </font><font style="vertical-align: inherit;">Wenn wir die allgemeine kausale Konsistenz berücksichtigen, können wir Blöcke unterscheiden. </font><font style="vertical-align: inherit;">Wir haben aus den Werken ausgewählt, die zu einem bestimmten Block gehören: Abhängigkeitsverfolgung, Auswahl der Stunden, wie diese Uhren miteinander synchronisiert werden können und wie wir die Sicherheit gewährleisten - dies ist ein ungefährer Plan dessen, worüber ich sprechen werde:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zv/rb/rq/zvrbrqunyfdrj1pmbrjncugqed4.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollständige Abhängigkeitsverfolgung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum wird es benötigt? Damit bei der Replikation der Daten - jeder Datensatz - jede Datenänderung Informationen darüber enthält, von welchen Änderungen sie abhängt. Die allererste und naive Änderung ist, wenn jede Nachricht, die einen Datensatz enthält, Informationen zu vorherigen Nachrichten enthält: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gk/ue/jh/gkuejhztxm81mfji3fazhsmbmbm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel ist die Zahl in geschweiften Klammern die Anzahl der Datensätze. Manchmal werden diese Datensätze mit Werten sogar vollständig übertragen, manchmal werden einige Versionen übertragen. Die Quintessenz ist, dass jede Änderung Informationen über die vorherige enthält (offensichtlich trägt sie alles in sich).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum haben wir uns entschieden, diesen Ansatz nicht zu verwenden (vollständige Verfolgung)? </font><font style="vertical-align: inherit;">Weil dieser Ansatz unpraktisch ist: Jede Änderung im sozialen Netzwerk hängt von allen vorherigen Änderungen in diesem sozialen Netzwerk ab und überträgt beispielsweise Facebook oder Vkontakte in jedem Update. </font><font style="vertical-align: inherit;">Trotzdem gibt es eine Menge Forschung, nämlich Full Dependency Tracking - dies sind soziale Netzwerke, in einigen Situationen funktioniert es wirklich.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explizite Abhängigkeitsverfolgung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der nächste ist begrenzter. </font><font style="vertical-align: inherit;">Auch hier wird die Übermittlung von Informationen berücksichtigt, aber nur das, was eindeutig davon abhängt. </font><font style="vertical-align: inherit;">Was davon abhängt, wird in der Regel bereits von der Anwendung festgelegt. </font><font style="vertical-align: inherit;">Wenn Daten repliziert werden, werden nur Antworten zurückgegeben, wenn eine Anforderung gestellt wird, wenn vorherige Abhängigkeiten erfüllt wurden, dh angezeigt werden. </font><font style="vertical-align: inherit;">Dies ist die Essenz der Funktionsweise der kausalen Konsistenz. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y_/jc/mw/y_jcmwt2w-vqj9guslui0wl8vgi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie sieht, dass Datensatz 5 von Datensatz 1, 2, 3, 4 abhängt. Sie wartet, bis der Client Zugriff auf die Änderungen erhält, die durch Pennys Zugriffsverordnung vorgenommen wurden, wenn alle vorherigen Änderungen bereits an die Datenbank übergeben wurden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies passt auch nicht zu uns, weil es sowieso zu viele Informationen gibt, und dies wird sich verlangsamen. </font><font style="vertical-align: inherit;">Es gibt einen anderen Ansatz ...</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lamport Uhr</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie sind sehr alt. Lamport Clock impliziert, dass diese Abhängigkeiten zu einer Skalarfunktion namens Lamport Clock zusammengefasst werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Skalarfunktion ist eine abstrakte Zahl. Oft als logische Zeit bezeichnet. Bei jedem Ereignis erhöht sich dieser Zähler. Der dem Prozess derzeit bekannte Zähler sendet jede Nachricht. Es ist klar, dass Prozesse möglicherweise nicht synchron sind und völlig unterschiedliche Zeiten haben können. Trotzdem gleicht das System die Uhr irgendwie mit solchen Nachrichten aus. Was passiert in diesem Fall?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe diese große Scherbe in zwei Teile zerbrochen, so dass klar war: Freunde können in einem Knoten leben, der einen Teil der Sammlung enthält, und Feed kann in einem anderen Knoten leben, der einen Teil dieser Sammlung enthält. Es ist klar, wie sie aus der Reihe kommen können? Zuerst sagt Feed "Repliziert" und dann Freunde. Wenn das System keine Garantie dafür bietet, dass der Feed erst angezeigt wird, wenn auch die Friends-Abhängigkeiten in der Friends-Sammlung geliefert werden, haben wir nur eine Situation, die ich erwähnt habe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie sehen, wie sich die logische Zählerzeit im Feed erhöht:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gv/pz/vw/gvpzvwwxqonuthkwv6j2ez0fruc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher ist die Haupteigenschaft dieser Lamport-Uhr- und Kausalkonsistenz (erklärt durch Lamport-Uhr) wie folgt: Wenn wir Ereignisse A und B haben und Ereignis B von Ereignis A * abhängt, ist die LogicalTime von Ereignis A geringer als die LogicalTime von Ereignis B. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Manchmal sagen sie sogar, dass A vor B passiert ist, dh A vor B passiert ist - dies ist eine Art Beziehung, die teilweise die gesamte Menge von Ereignissen ordnet, die im Allgemeinen passiert sind.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Das Gegenteil ist falsch. Dies ist tatsächlich einer der Hauptnachteile von Lamport Clock - Teilbestellung. Es gibt ein Konzept für gleichzeitige Ereignisse, dh Ereignisse, bei denen weder (A vor B) noch (A vor B) aufgetreten sind. Ein Beispiel ist die parallele Hinzufügung von Leonard zu Freunden eines anderen (nicht einmal Leonard, sondern Sheldon zum Beispiel).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist die Eigenschaft, die häufig bei der Arbeit mit Lamport-Uhren verwendet wird: Sie sehen sich die Funktion genau an und ziehen daraus eine Schlussfolgerung - möglicherweise sind diese Ereignisse abhängig. </font><font style="vertical-align: inherit;">Denn in einer Richtung ist dies wahr: Wenn LogicalTime A kleiner als LogicalTime B ist, kann B nicht vor A auftreten; </font><font style="vertical-align: inherit;">und wenn mehr, dann vielleicht.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vektoruhr</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die logische Entwicklung von Lamport-Uhren ist die Vektoruhr. Sie unterscheiden sich darin, dass jeder Knoten, der sich hier befindet, eine eigene Uhr enthält und als Vektor übertragen wird. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall sehen Sie, dass der Nullindex des Vektors für den Feed verantwortlich ist und der erste Index des Vektors für Freunde (jeder dieser Knoten). Und jetzt werden sie zunehmen: Der Nullindex des "Feeds" steigt bei der Aufnahme - 1, 2, 3: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cv/xm/cd/cvxmcdiz_dgbjsu7elnj3xt2hcc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie ist die Vektoruhr besser? Die Tatsache, dass sie herausfinden können, welche Ereignisse gleichzeitig auftreten und wann sie auf verschiedenen Knoten auftreten. Dies ist sehr wichtig für ein Sharding-System wie das MongoBD. Wir haben uns jedoch nicht dafür entschieden, obwohl es eine wunderbare Sache ist und großartig funktioniert und wahrscheinlich zu uns passen würde ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir zehntausend Shards haben, können wir nicht zehntausend Komponenten übertragen, selbst wenn wir komprimieren, denken wir uns etwas anderes aus - trotzdem ist die Nutzlast um ein Vielfaches geringer als das Volumen dieses gesamten Vektors. </font><font style="vertical-align: inherit;">Deshalb haben wir unsere Herzen und Zähne zusammengebissen, diesen Ansatz aufgegeben und sind zu einem anderen übergegangen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spanner TrueTime. </font><font style="vertical-align: inherit;">Atomuhr</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich sagte, dass es eine Geschichte über Spanner geben wird. Das ist eine coole Sache, genau im 21. Jahrhundert: Atomuhren, GPS-Synchronisation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Welche Idee? Spanner ist ein Google-System, das seit kurzem sogar für Benutzer verfügbar ist (sie haben SQL daran angehängt). Jede Transaktion dort hat einen Zeitstempel. Da die Zeit synchronisiert ist *, kann jedem Ereignis eine bestimmte Zeit zugewiesen werden - die Atomuhr hat eine Wartezeit, nach der garantiert wird, dass eine andere Zeit auftritt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zn/vw/e3/znvwe3zwpqvjhsx-qglxpbqen9g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch einfaches Schreiben in die Datenbank und Warten auf einen bestimmten Zeitraum wird die Serialisierung des Ereignisses automatisch garantiert. Sie haben das stärkste Konsistenzmodell, das man sich im Prinzip vorstellen kann - es ist externe Konsistenz.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
* Dies ist das Hauptproblem von Lampart-Uhren - sie sind auf verteilten Systemen niemals synchron. </font><font style="vertical-align: inherit;">Sie können divergieren, auch mit NTP funktionieren sie immer noch nicht sehr gut. </font><font style="vertical-align: inherit;">"Spanner" hat eine Atomuhr und die Synchronisation scheint dann Mikrosekunden zu sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum haben wir uns nicht entschieden? </font><font style="vertical-align: inherit;">Wir gehen nicht davon aus, dass unsere Benutzer eine eingebaute Atomuhr haben. </font><font style="vertical-align: inherit;">Wenn sie erscheinen und in jeden Laptop eingebaut sind, wird es eine Art super coole GPS-Synchronisation geben - dann ja ... In der Zwischenzeit ist Amazon, Basisstationen für Fanatiker das Beste, was möglich ist ... Deshalb haben wir andere Uhren verwendet.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hybriduhr</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist tatsächlich das, was den „MongoBD“ ankreuzt und gleichzeitig die kausale Konsistenz sicherstellt. </font><font style="vertical-align: inherit;">Was sind sie Hybrid? </font><font style="vertical-align: inherit;">Ein Hybrid ist ein Skalarwert, besteht jedoch aus zwei Komponenten:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hi/wz/uv/hiwzuvz-czbmb52b9iypojrr0_u.jpeg"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste ist die Unix-Ära (wie viele Sekunden sind seit dem "Beginn der Computerwelt" vergangen).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das zweite ist ein Inkrement, ebenfalls ein 32-Bit-Int ohne Vorzeichen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist eigentlich alles. </font><font style="vertical-align: inherit;">Es gibt einen solchen Ansatz: Der Teil, der für die Zeit verantwortlich ist, wird ständig mit der Uhr synchronisiert; </font><font style="vertical-align: inherit;">Jedes Mal, wenn eine Aktualisierung erfolgt, wird dieser Teil mit der Uhr synchronisiert und es stellt sich heraus, dass die Zeit immer mehr oder weniger korrekt ist. Mit Inkrement können Sie zwischen Ereignissen unterscheiden, die zur gleichen Zeit aufgetreten sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum ist das für MongoBD wichtig? </font><font style="vertical-align: inherit;">Da Sie zu einem bestimmten Zeitpunkt Sicherungswiederherstellungen erstellen können, wird das Ereignis nach Zeit indiziert. </font><font style="vertical-align: inherit;">Dies ist wichtig, wenn einige Ereignisse benötigt werden. </font><font style="vertical-align: inherit;">Bei einer Datenbank sind Ereignisse Änderungen an der Datenbank, die zu bestimmten Zeitpunkten auftreten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde Ihnen nur den wichtigsten Grund nennen (bitte sagen Sie es niemandem)! </font><font style="vertical-align: inherit;">Wir haben dies getan, weil geordnete, indizierte Daten in MongoDB OpLog so aussehen. </font><font style="vertical-align: inherit;">OpLog ist eine Datenstruktur, die absolut alle Änderungen in der Datenbank enthält: Sie gehen zuerst zu OpLog und werden dann bereits auf Storage selbst angewendet, wenn es sich um ein repliziertes Datum oder einen Shard handelt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das war der Hauptgrund. </font><font style="vertical-align: inherit;">Es gibt jedoch auch praktische Anforderungen für die Entwicklung der Datenbank, was bedeutet, dass es einfach sein sollte - es gibt wenig Code, so wenig kaputte Dinge wie möglich, die neu geschrieben und getestet werden müssen. </font><font style="vertical-align: inherit;">Die Tatsache, dass unsere Oplogs von einer Hybriduhr indiziert wurden, hat uns sehr geholfen und es uns ermöglicht, die richtige Wahl zu treffen. </font><font style="vertical-align: inherit;">Es hat sich wirklich ausgezahlt und irgendwie magisch funktioniert, beim allerersten Prototyp. </font><font style="vertical-align: inherit;">Es war sehr cool!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uhrensynchronisation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der wissenschaftlichen Literatur sind mehrere Synchronisationsmethoden beschrieben. </font><font style="vertical-align: inherit;">Ich spreche von Synchronisation, wenn wir zwei verschiedene Shards haben. </font><font style="vertical-align: inherit;">Wenn ein Replikatsatz vorhanden ist, ist dort keine Synchronisierung erforderlich: Es handelt sich um einen „einzelnen Master“. </font><font style="vertical-align: inherit;">Wir haben ein OpLog, in das alle Änderungen eingehen - in diesem Fall ist alles bereits im "Oplog" selbst sequentiell geordnet. </font><font style="vertical-align: inherit;">Wenn wir jedoch zwei verschiedene Shards haben, ist hier die Zeitsynchronisation wichtig. </font><font style="vertical-align: inherit;">Hier haben Vektoruhren mehr geholfen! </font><font style="vertical-align: inherit;">Aber wir haben sie nicht. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ei/kq/bk/eikqbkbbzrsdquzxjxlzayc81qq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite ist Heartbeats. </font><font style="vertical-align: inherit;">Sie können einige Signale austauschen, die in jeder Zeiteinheit auftreten. </font><font style="vertical-align: inherit;">Aber Hartbits sind zu langsam, wir können unserem Kunden keine Latenz gewähren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wahre Zeit ist natürlich eine wunderbare Sache. </font><font style="vertical-align: inherit;">Aber auch dies ist wahrscheinlich die Zukunft ... Obwohl der Atlas bereits erstellt werden kann, gibt es bereits schnelle "amazonische" Zeitsynchronisierer. </font><font style="vertical-align: inherit;">Aber es wird nicht jedem zur Verfügung stehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Klatschen ist, wenn alle Nachrichten Zeit enthalten. </font><font style="vertical-align: inherit;">Dies ist ungefähr das, was wir verwenden. </font><font style="vertical-align: inherit;">Jede Nachricht zwischen Knoten, einem Treiber, einem Router von Datenknoten, absolut alles für MongoDB sind einige Elemente, Datenbankkomponenten, die Stunden enthalten, die fließen. </font><font style="vertical-align: inherit;">Überall dort, wo sie die Bedeutung von Hybridzeit haben, wird sie übertragen. </font><font style="vertical-align: inherit;">64 Bit? </font><font style="vertical-align: inherit;">Es erlaubt, es ist möglich.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie funktioniert das alles zusammen?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier schaue ich mir ein Replikatset an, um es ein bisschen einfacher zu machen. Es gibt primäre und sekundäre. Secondary führt die Replikation durch und ist nicht immer vollständig mit Primary synchronisiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den "Primärfarben" befindet sich eine Einfügung (Einfügung) mit einem bestimmten Zeitwert. Dieser Einsatz erhöht den internen Zähler um 11, wenn er maximal ist. Oder es überprüft die Uhrwerte und synchronisiert mit der Uhr, wenn die Uhr größer ist. Auf diese Weise können Sie nach Zeit sortieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem er eine Aufzeichnung gemacht hat, tritt ein wichtiger Moment ein. Die Stunden sind in "MongoDB" und werden nur erhöht, wenn sie im "Oplog" aufgezeichnet sind. Dies ist ein Ereignis, das den Status des Systems ändert. In allen klassischen Artikeln wird ein Ereignis als eine Nachricht betrachtet, die in einen Knoten eingeht: Eine Nachricht ist eingetroffen - das heißt, das System hat seinen Status geändert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies liegt an der Tatsache, dass es während der Studie nicht vollständig möglich ist zu verstehen, wie diese Nachricht interpretiert wird. Wir wissen mit Sicherheit, dass wenn es nicht im „Oplog“ wiedergegeben wird, es in keiner Weise interpretiert wird und nur der Eintrag im „Oplog“ eine Änderung des Systemzustands darstellt. Dies vereinfacht alles für uns: Das Modell vereinfacht und ermöglicht es uns, im Rahmen eines Replikatsatzes und vieler anderer nützlicher Dinge zu organisieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt den Wert zurück, der bereits im „Oplog“ aufgezeichnet wurde - wir wissen, dass dieser Wert im „Oplog“ bereits liegt und seine Zeit 12 ist. Jetzt beginnt der Lesevorgang beispielsweise an einem anderen Knoten (sekundär) und wird bereits nach ClusterTime selbst übertragen Botschaft. Er sagt: „Ich brauche alles, was nach mindestens 12 oder zwölf passiert ist“ (siehe Abb. Oben).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies wird als Causal a Consistent (CAT) bezeichnet. Theoretisch gibt es ein solches Konzept, dass es sich um eine Zeitscheibe handelt, die an sich konsistent ist. In diesem Fall können wir sagen, dass dies der Zustand des Systems ist, der zum Zeitpunkt 12 beobachtet wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt gibt es hier nichts mehr, da es die Situation zu imitieren scheint, in der Secondary Daten von Primary replizieren muss. Er wartet ... Und jetzt sind die Daten gekommen - geben diese Werte zurück. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/a1/q7/3q/a1q73qclyk9sn567b2x8szr_ejm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So funktioniert alles. Fast.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was bedeutet "fast"? Nehmen wir an, es gibt jemanden, der gelesen und verstanden hat, wie das alles funktioniert. Ich habe festgestellt, dass jedes Mal, wenn ClusterTime auftritt, die interne logische Uhr aktualisiert wird und der nächste Datensatz um eins erhöht wird. Diese Funktion nimmt 20 Zeilen ein. Angenommen, diese Person überträgt die größtmögliche 64-Bit-Zahl minus eins. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum ist minus eins? Da die interne Uhr durch diesen Wert ersetzt wird (dies ist offensichtlich die größtmögliche und mehr als die aktuelle Zeit), wird im „Olog“ ein Eintrag angezeigt, und die Uhr wird um einen weiteren erhöht - und es gibt bereits einen Maximalwert (es gibt einfach alle Einheiten, es gibt keinen Weg mehr , vorzeichenlose Ints).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist klar, dass das System danach für nichts völlig unzugänglich wird. </font><font style="vertical-align: inherit;">Es kann nur entladen, gereinigt werden - viel Handarbeit. </font><font style="vertical-align: inherit;">Volle Verfügbarkeit: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/iu/lz/fs/iulzfslzcst3tn9c-qpouy9zqsk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn dies an einem anderen Ort repliziert wird, legt sich der gesamte Cluster einfach hin. </font><font style="vertical-align: inherit;">Eine absolut inakzeptable Situation, die jeder sehr schnell und einfach organisieren kann! </font><font style="vertical-align: inherit;">Daher haben wir diesen Moment als einen der wichtigsten angesehen. </font><font style="vertical-align: inherit;">Wie kann man das verhindern?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser Weg ist es, clusterTime zu signieren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So wird es in der Nachricht übertragen (vor dem blauen Text). Wir haben aber auch begonnen, eine Signatur (blauer Text) zu generieren: Die </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zg/9r/iu/zg9riuabqzdlnw9dwttrwkwzkmi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Signatur wird von einem Schlüssel generiert, der in der Datenbank innerhalb des geschützten Bereichs gespeichert ist. es wird generiert, aktualisiert (Benutzer sehen nichts). Hash wird generiert und jede Nachricht wird während der Erstellung signiert und nach Erhalt validiert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wahrscheinlich stellt sich bei Menschen die Frage: "Wie sehr verlangsamt es sich?" Ich sagte, dass es schnell funktionieren sollte, insbesondere wenn diese Funktion nicht vorhanden ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was bedeutet es in diesem Fall, die kausale Konsistenz zu verwenden? Dies zeigt den Parameter afterClusterTime an. Und ohne es werden ohnehin einfach Werte übergeben. Klatschen funktioniert seit Version 3.6 immer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir die ständige Generierung von Signaturen verlassen, verlangsamt dies das System auch ohne Funktionen, die unseren Ansätzen und Anforderungen nicht entsprechen. </font><font style="vertical-align: inherit;">Und was haben wir getan?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mach es schnell!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine einfache Sache, aber der Trick ist interessant - ich werde es teilen, vielleicht wird jemand interessiert sein. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben einen Hash, der signierte Daten speichert. </font><font style="vertical-align: inherit;">Alle Daten durchlaufen den Cache. </font><font style="vertical-align: inherit;">Der Cache signiert nicht speziell die Zeit, sondern den Bereich. </font><font style="vertical-align: inherit;">Wenn ein bestimmter Wert erreicht ist, generieren wir einen Bereich, maskieren die letzten 16 Bits und signieren diesen Wert: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/s8/ml/3a/s8ml3aaec2pj5xl8t0zvkrp7iik.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch den Empfang einer solchen Signatur beschleunigen wir das System (bedingt) um das 65.000-fache. </font><font style="vertical-align: inherit;">Es funktioniert großartig: Als sie die Experimente durchgeführt haben, wurde die Zeit, in der wir ein konsistentes Update hatten, dort wirklich um das Zehntausendfache reduziert. </font><font style="vertical-align: inherit;">Es ist klar, dass dies nicht funktioniert, wenn sie uneins sind. </font><font style="vertical-align: inherit;">In den meisten praktischen Fällen funktioniert dies jedoch. </font><font style="vertical-align: inherit;">Die Kombination der Range-Signatur mit der Signatur löste das Sicherheitsproblem.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was haben wir gelernt?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lehren daraus haben wir gezogen:</font></font><br>
<br>
<ul>
<li>  , , ,       .     -  ( ,      . .),  , .   ,       ,    ,   .        –   .<br>
<br>
,     ,      («», ) –      .     ?    .     ,      .   –   ,   .</li>
<li>    .  ,        «»     ,   ,  ,      availability, latency  .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das letzte ist, dass wir verschiedene Ideen berücksichtigen und mehrere allgemein unterschiedliche Artikel zu einem Ansatz zusammenfassen mussten. </font><font style="vertical-align: inherit;">Die Idee zum Signieren kam zum Beispiel aus einem Artikel, in dem das Paxos-Protokoll untersucht wurde, das für nicht-byzantinisches Faylor innerhalb des Autorisierungsprotokolls und für byzantinische außerhalb des Autorisierungsprotokolls gilt. Im Allgemeinen haben wir dies letztendlich genau getan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier gibt es absolut nichts Neues! </font><font style="vertical-align: inherit;">Aber sobald wir alles zusammengemischt haben ... Es ist wie zu sagen, dass das Olivier-Salatrezept Unsinn ist, weil Eier, Mayonnaise und Gurken bereits erfunden wurden ... Es geht um die gleiche Geschichte.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/6o/pc/q8/6opcq8ew4bcry9qnt0lsdlasflo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit werde ich enden. </font><font style="vertical-align: inherit;">Danke!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragen</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frage des Publikums (im Folgenden - B):</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Danke, Michael für den Bericht! Das Thema Zeit ist interessant. Sie verwenden Klatschen. Sie sagten, dass jeder seine eigene Zeit hat, jeder seine Ortszeit kennt. So wie ich es verstehe, haben wir einen Treiber - es kann viele Clients mit Treibern geben, auch Abfrageplaner, viele Shards ... Aber was wird das System tun, wenn wir plötzlich eine Diskrepanz haben: Jemand entscheidet, dass er für eine Minute ist voraus, jemand - eine Minute dahinter? Wo werden wir uns befinden? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Wirklich eine gute Frage! Ich wollte nur über Scherben sagen. Wenn ich die Frage richtig verstehe, haben wir diese Situation: Es gibt Shard 1 und Shard 2, das Lesen erfolgt von diesen beiden Shards - sie haben eine Diskrepanz, sie interagieren nicht miteinander, weil die Zeit, die sie kennen, unterschiedlich ist, insbesondere die Zeit, die Sie existieren in Oplogs.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, Shard 1 hat eine Million Datensätze gemacht, Shard 2 hat überhaupt nichts getan, und die Anfrage kam in zwei Shards. Und der erste hat afterClusterTime über eine Million. In einer solchen Situation wird Shard 2, wie ich bereits erklärt habe, niemals reagieren. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ich wollte wissen, wie sie synchronisieren und eine logische Zeit auswählen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Sehr einfach zu synchronisieren. Shard, wenn afterClusterTime zu ihm kommt und er die Zeit nicht im "Catch" findet - initiiert keine genehmigte. Das heißt, er hebt seine Hände mit seinen Händen auf diesen Wert. Dies bedeutet, dass keine Ereignisse vorhanden sind, die dieser Abfrage entsprechen. Er schafft dieses Ereignis künstlich und wird so zum Causal Consistent. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Und wenn danach noch einige andere Ereignisse zu ihm kommen, die irgendwo im Netzwerk verloren gegangen sind? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Die Scherbe ist so angeordnet, dass sie nicht mehr kommt, da es sich um einen einzelnen Meister handelt. Wenn er bereits aufgenommen hat, werden sie nicht kommen, sondern danach sein. Es kann nicht passieren, dass irgendwo etwas steckt, dann wird er nicht schreiben, und dann sind diese Ereignisse eingetroffen - und die kausale Konsistenz wurde verletzt. Wenn er nicht schreibt, müssen sie alle als nächstes kommen (er wird auf sie warten). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t2/wb/oo/t2wboofhfs7qpepqz8zwsm1o0u4.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BEIM:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ich habe ein paar Fragen zu den Zeilen. Die kausale Konsistenz setzt voraus, dass eine bestimmte Warteschlange von Aktionen ausgeführt werden muss. Was passiert, wenn wir ein Paket verlieren? Also ging der 10., der 11. ... der 12. verschwand und alle anderen warten darauf, dass er erfüllt wird. Und plötzlich ist unser Auto gestorben, wir können nichts mehr tun. Gibt es eine maximale Warteschlangenlänge, die sich ansammelt, bevor sie ausgeführt wird? Welcher fatale Fehler tritt auf, wenn ein Zustand verloren geht? Wenn wir darüber hinaus aufschreiben, dass es einen früheren Zustand gibt, sollten wir dann irgendwie davon ausgehen? Und sie haben nicht von ihm gestoßen! </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Auch eine wunderbare Frage! Was machen wir? MongoDB hat das Konzept von Quorum-Datensätzen, Quorum liest. Wann kann eine Nachricht verschwinden? Wenn der Datensatz nicht beschlussfähig ist oder wenn der Messwert nicht beschlussfähig ist (etwas Müll kann auch haften bleiben). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Bezug auf die kausale Konsistenz haben wir einen großen experimentellen Test durchgeführt. Das Ergebnis war, dass Verstöße gegen die kausale Konsistenz auftreten, wenn Aufzeichnung und Lesen nicht beschlussfähig sind. Genau das, was du sagst!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser Tipp: Verwenden Sie bei Verwendung der kausalen Konsistenz mindestens das Quorum. In diesem Fall geht nichts verloren, auch wenn der Quorumdatensatz verloren geht ... Dies ist eine orthogonale Situation: Wenn der Benutzer nicht möchte, dass die Daten verloren gehen, müssen Sie den Quorumdatensatz verwenden. Die kausale Konsistenz garantiert keine Haltbarkeit. Die Haltbarkeitsgarantie wird durch Replikation und mit der Replikation verbundene Maschinen gewährleistet. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Wenn wir eine Instanz erstellen, die Sharding für uns erledigt (nicht Master, sondern Slave), hängt sie von der Unix-Zeit ihrer eigenen Maschine oder von der Zeit des „Masters“ ab. zum ersten Mal oder regelmäßig synchronisiert? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Jetzt mache ich es klar. Scherbe (d. H. Horizontale Trennwand) - es gibt immer Primär. Und in einer Scherbe kann es einen „Meister“ geben und es kann Repliken geben. Der Shard unterstützt jedoch immer das Schreiben, da er eine bestimmte Domäne unterstützen muss (Primary befindet sich im Shard). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Das heißt, alles hängt nur vom "Meister" ab? Immer die "Master" -Zeit verwenden? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ja. Sie können im übertragenen Sinne sagen: Die Uhr tickt, wenn es eine Aufnahme im "Master", im "Olog" gibt. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Wir haben einen Kunden, der eine Verbindung herstellt und der nichts über die Zeit wissen muss. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Im Allgemeinen müssen Sie nichts wissen! Wenn wir darüber sprechen, wie es auf dem Client funktioniert: Wenn er auf dem Client die kausale Konsistenz verwenden möchte, muss er eine Sitzung öffnen. Jetzt ist alles da: beide Transaktionen in der Sitzung und das Abrufen von Rechten ... Eine Sitzung ist eine Reihenfolge von logischen Ereignissen, die mit einem Client auftreten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn er diese Sitzung öffnet und dort sagt, dass er kausale Konsistenz wünscht (wenn die Sitzung standardmäßig kausale Konsistenz unterstützt), funktioniert alles automatisch. Der Fahrer merkt sich diese Zeit und erhöht sie, wenn er eine neue Nachricht erhält. Es merkt sich, welche Antwort die vorherige vom Server zurückgegeben hat, der die Daten zurückgegeben hat. Die folgende Anforderung enthält afterCluster ("Zeit ist größer als diese").</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Kunde muss absolut nichts wissen! Das ist für ihn absolut undurchsichtig. Was kann ich tun, wenn Benutzer diese Funktionen verwenden? Erstens können Sie Secondaries sicher lesen: Sie können in Primary schreiben und aus geografisch replizierten Secondaries lesen und sicherstellen, dass es funktioniert. Gleichzeitig können die auf Primary aufgezeichneten Sitzungen sogar auf Secondary übertragen werden, dh Sie können nicht eine Sitzung, sondern mehrere verwenden. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Das Thema "Eventuelle Konsistenz" ist stark mit der neuen Compute Science-Schicht verknüpft - CRDT-Datentypen (Conflict-free Replicated Data Types). Haben Sie über die Integration dieser Datentypen in die Datenbank nachgedacht und was können Sie dazu sagen? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Gute Frage! CRDT ist sinnvoll für Schreibkonflikte: in MongoDB - Single Master. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BEIM:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ich habe eine Frage von den Devops. In der realen Welt gibt es solche Jesuitensituationen, in denen das byzantinische Versagen eintritt und die bösen Menschen innerhalb des geschützten Bereichs beginnen, sich an das Protokoll zu halten und Handwerkspakete auf besondere Weise zu senden? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/8d/m3/p5/8dm3p5em6rsqsv2ojzy-vdylffg.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Böse Menschen im Umkreis sind wie ein trojanisches Pferd! Böse Menschen im Umkreis können viele schlechte Dinge tun. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Es ist klar, dass Sie grob gesagt ein Loch im Server lassen, durch das Sie den Elefantenzoo stecken und den gesamten Cluster für immer zusammenbrechen können. Die manuelle Wiederherstellung wird einige Zeit in Anspruch nehmen. Dies ist, gelinde gesagt, falsch. Auf der anderen Seite ist dies merkwürdig: In der Praxis gibt es in der Praxis Situationen, in denen natürlich ähnliche interne Angriffe auftreten? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Da ich im wirklichen Leben selten auf Sicherheitsverletzungen stoße, kann ich nicht sagen - vielleicht passieren sie. Aber wenn wir über Entwicklungsphilosophie sprechen, dann denken wir so: Wir haben einen Umkreis, der den Leuten Sicherheit bietet - es ist eine Burg, eine Mauer; und innerhalb des Perimeters können Sie alles tun, was Sie wollen. Es ist klar, dass es Benutzer gibt, die nur schauen können, und es gibt Benutzer, die das Verzeichnis löschen können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abhängig von den Rechten kann der Schaden, den Benutzer anrichten können, eine Maus oder ein Elefant sein. Es ist klar, dass ein Benutzer mit vollen Rechten überhaupt alles tun kann. Ein Benutzer mit nicht weitreichenden Schadensrechten kann erheblich weniger verursachen. Insbesondere kann er das System nicht brechen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BEIM:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Im sicheren Bereich kletterte jemand, um unerwartete Protokolle für den Server zu erstellen, um den Server mit Krebs einzurichten, und wenn Sie Glück haben, dann den gesamten Cluster ... Kommt es jemals so "gut" vor? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ich habe noch nie von solchen Dingen gehört. Die Tatsache, dass Sie auf diese Weise den Server füllen können, ist kein Geheimnis. Um sich darin zu füllen, aus dem Protokoll zu stammen, ein autorisierter Benutzer zu sein, der so etwas in eine Nachricht schreiben kann ... Eigentlich ist es unmöglich, weil es sowieso überprüft wird. Es ist möglich, diese Authentifizierung für Benutzer zu deaktivieren, die dies nicht möchten. Dies ist dann ihr Problem. Grob gesagt haben sie selbst die Mauern zerstört und Sie können dort einen Elefanten stopfen, der mit Füßen treten wird ... Im Allgemeinen können Sie sich als Handwerker verkleiden, kommen und ihn holen! </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BEIM:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Danke für den Bericht. </font><font style="vertical-align: inherit;">Sergey (Yandex). </font><font style="vertical-align: inherit;">In „Mong“ gibt es eine Konstante, die die Anzahl der stimmberechtigten Mitglieder im Replikatsatz begrenzt, und diese Konstante beträgt 7 (sieben). </font><font style="vertical-align: inherit;">Warum ist das eine Konstante? </font><font style="vertical-align: inherit;">Warum ist das kein Parameter? </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Replica Set Wir haben auch 40 Knoten. </font><font style="vertical-align: inherit;">Es gibt immer eine Mehrheit. </font><font style="vertical-align: inherit;">Ich weiß nicht, welche Version ... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Im Replikatset können Sie nicht stimmberechtigte Mitglieder ausführen, aber maximal 7 abstimmen. Wie können Sie dann deaktivieren, wenn das Replikatset in 3 Rechenzentren gezogen wird? </font><font style="vertical-align: inherit;">Ein Rechenzentrum kann leicht ausgeschaltet werden, und ein anderer Computer fällt aus. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Dies liegt bereits etwas außerhalb des Berichtsbereichs. </font><font style="vertical-align: inherit;">Dies ist eine häufige Frage. </font><font style="vertical-align: inherit;">Vielleicht kann ich es ihm dann sagen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9t/cr/ga/9tcrgaodiufisllhrktf_5iok_a.jpeg"><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/UnAprFMX1d4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein bisschen Werbung :)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielen Dank für Ihren Aufenthalt bei uns. Gefällt dir unser Artikel? Möchten Sie weitere interessante Materialien sehen? Unterstützen Sie uns, indem Sie eine Bestellung </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">aufgeben</font></a><font style="vertical-align: inherit;"> oder Ihren Freunden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloud-basiertes VPS für Entwickler ab 4,99 US-Dollar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> empfehlen </font><font style="vertical-align: inherit;">, ein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einzigartiges Analogon von Einstiegsservern, das von uns für Sie erfunden wurde: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die ganze Wahrheit über VPS (KVM) E5-2697 v3 (6 Kerne) 10 GB DDR4 480 GB SSD 1 Gbit / s ab 19 $ oder wie teilt man den Server?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Optionen sind mit RAID1 und RAID10, bis zu 24 Kernen und bis zu 40 GB DDR4 verfügbar). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xd 2-mal günstiger im Equinix Tier IV-Rechenzentrum in Amsterdam?</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nur wir haben </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2,6 GHz 14C 64 GB DDR4 4 x 960 GB SSD 1 Gbit / s 100 TV von 199 US-Dollar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in den Niederlanden!</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R420 - 2x E5-2430 2,2 GHz 6C 128 GB DDR3 2x960 GB SSD 1 Gbit / s 100 TB - ab 99 US-Dollar! </font></font></b></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr über</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den Aufbau eines Infrastrukturgebäudes. </font><font style="vertical-align: inherit;">Klasse C mit Dell R730xd E5-2650 v4-Servern für 9.000 Euro pro Cent?</font></font></a></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de487626/index.html">Wie Parksensoren funktionieren und wie man ihn austrickst</a></li>
<li><a href="../de487628/index.html">Diagnose des Alterns anhand von 9 Kennzeichen der Alterungserscheinungen</a></li>
<li><a href="../de487630/index.html">Der einfachste Algorithmus zum Erstellen eines Feldpuzzles (Teil 1)</a></li>
<li><a href="../de487632/index.html">„Kollegen, atmen Sie leiser“: Warum uns Bürolärm verrückt macht - wir diskutieren über Forschung</a></li>
<li><a href="../de487636/index.html">APIs, für die es sich endlich lohnt, ein Upgrade von Java 8 durchzuführen. Teil 2</a></li>
<li><a href="../de487640/index.html">Testen der Spielautomatisierung</a></li>
<li><a href="../de487644/index.html">Abrufen von Börsenkursen mit Python</a></li>
<li><a href="../de487646/index.html">Reagenzglas-Neutronenstern. Sonolumineszenz</a></li>
<li><a href="../de487648/index.html">Es könnte ein anderes Javascript-Framework sein.</a></li>
<li><a href="../de487650/index.html">Hoffe auf das SDK und mache nichts falsch: Das Problem verschachtelter Schriftrollen im BottomSheetBehavior</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>