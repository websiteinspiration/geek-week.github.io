<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶🏽 👩🏾‍💼 🧑🏿 启动ASP.NET Core中的异步代码：避开GetAwaiter（）的4种方法。 🛅 💪🏾 👨🏼‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="自从C＃5.0中引入async / await机制以来，所有文章和文档中都不断教导我们在同步中使用异步代码非常糟糕。他们呼吁像GetAwaiter（）。GetResult（）那样的恐惧。但是，在某些情况下，Microsoft程序员本身并不轻视此设计。
 
 
 
 工作任务的背景
 我们现在正在从传...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>启动ASP.NET Core中的异步代码：避开GetAwaiter（）的4种方法。</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/496300/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自从C＃5.0中引入async / await机制以来，所有文章和文档中都不断教导我们在同步中使用异步代码非常糟糕。</font><font style="vertical-align: inherit;">他们呼吁像GetAwaiter（）。GetResult（）那样的恐惧。</font><font style="vertical-align: inherit;">但是，在某些情况下，Microsoft程序员本身并不轻视此设计。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yl/m9/nb/ylm9nbu--2sz9pzjxu-tgx8k5t4.png"><br>
 <a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工作任务的背景</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们现在正在从传统身份验证过渡到OAuth 2.0，OAuth 2.0已经成为我们行业的标准。</font><font style="vertical-align: inherit;">我现在正在使用的服务已经成为与新系统集成以及向JWT身份验证过渡的试验。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在集成过程中，我们进行了实验，考虑了各种选项，如何减轻令牌提供者（在我们的情况下为IdentityServer）的负担，并确保整个系统的更高可靠性。</font><font style="vertical-align: inherit;">将基于JWT的验证连接到ASP.NET Core非常简单，并且与令牌提供程序的特定实现无关：</font></font><br>
<br>
<pre><code class="cs hljs">services<font></font>
      .AddAuthentication()<font></font>
      .AddJwtBearer(); <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是这两行背后隐藏着什么？</font><font style="vertical-align: inherit;">在他们的幕后，创建了一个JWTBearerHandler，它已经处理了来自API客户端的JWT。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fs/sx/ce/fssxce2duwjnem0_zgekkezhglm.jpeg" width="550"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请求</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
时</font><i><font style="vertical-align: inherit;">客户端，API和令牌提供者之间</font></i><font style="vertical-align: inherit;">的交互JWTBearerHandler从客户端收到令牌时，它不会将令牌发送给提供者进行验证，相反，它请求Signing Key provider（签名密钥提供者）-签名令牌的密钥的公共部分。根据此密钥，验证令牌是否由正确的提供者签名。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在JWTBearerHandler中放置HttpClient，它通过网络与提供程序进行交互。但是，如果我们假设提供者的签名密钥不打算经常更改，那么在启动应用程序，缓存自己并摆脱持续的网络请求时，您可以选择一次。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我获得了用于签名密钥的代码：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AuthenticationBuilder <span class="hljs-title">AddJwtAuthentication</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> AuthenticationBuilder builder, AuthJwtOptions options</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> signingKeys = <span class="hljs-keyword">new</span> List&lt;SecurityKey&gt;();<font></font>
<font></font>
    <span class="hljs-keyword">var</span> jwtBearerOptions = <span class="hljs-keyword">new</span> JwtBearerOptions {Authority = options?.Authority};<font></font>
    <font></font>
    <span class="hljs-keyword">new</span> JwtBearerPostConfigureOptions().PostConfigure(<span class="hljs-keyword">string</span>.Empty, jwtBearerOptions);
    <span class="hljs-keyword">try</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> config = jwtBearerOptions.ConfigurationManager<font></font>
            .GetConfigurationAsync(<span class="hljs-keyword">new</span> CancellationTokenSource(options?.AuthorityTimeoutInMs ?? <span class="hljs-number">5000</span>).Token)<font></font>
            .GetAwaiter().GetResult();<font></font>
        <span class="hljs-keyword">var</span> providerSigningKeys = config.SigningKeys;<font></font>
        signingKeys.AddRange(providerSigningKeys);<font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span> (Exception)<font></font>
    {<font></font>
        <span class="hljs-comment">// ignored</span><font></font>
    }<font></font>
<font></font>
    builder<font></font>
        .AddJwtBearer(options =&gt;<font></font>
        {<font></font>
            options.TokenValidationParameters = <span class="hljs-keyword">new</span> TokenValidationParameters<font></font>
            {<font></font>
                <span class="hljs-comment">// ...</span><font></font>
                IssuerSigningKeys = signingKeys,<font></font>
                <span class="hljs-comment">// ...</span><font></font>
            };<font></font>
        });<font></font>
    <span class="hljs-keyword">return</span> builder;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第12行中，我们遇到了.GetAwaiter（）。GetResult（）。</font><font style="vertical-align: inherit;">这是因为AuthenticationBuilder是在Startup类的公共void ConfigureServices（IServiceCollection服务）{...}内配置的，并且此方法没有异步版本。</font><font style="vertical-align: inherit;">麻烦。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从C＃7.1开始，我们有一个异步的Main（）。</font><font style="vertical-align: inherit;">但是Asp.NET Core中的异步启动配置方法尚未交付。</font><font style="vertical-align: inherit;">从美学上讲，我很讨厌写GetAwaiter（）。GetResult（）（被教我不要这样做！），所以我上网寻找其他人如何处理这个问题。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我被GetAwaiter（）。GetResult（）困扰，但Microsoft却没有</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我首先找到了一个选项，Microsoft程序员在类似的任务中使用了该选项来</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从Azure KeyVault中获取秘密</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果您经过几层抽象，那么我们将看到：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Load</span>(<span class="hljs-params"></span>)</span> =&gt; LoadAsync().ConfigureAwait(<span class="hljs-literal">false</span>).GetAwaiter().GetResult();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再次问好，GetAwaiter（）。GetResult（）！</font><font style="vertical-align: inherit;">还有其他解决方案吗？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
经过短暂的谷歌搜索后，我发现了</font><font style="vertical-align: inherit;">安德鲁·洛克</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Andrew Lock）</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">撰写</font></a><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">一系列精彩文章</font></a><font style="vertical-align: inherit;">，一年前</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">，</font></a><font style="vertical-align: inherit;">安德鲁·洛克</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">（</font></a><font style="vertical-align: inherit;"> Andrew Lock）曾想到与我同一个问题。</font><font style="vertical-align: inherit;">即使出于相同的原因-从美学上讲，他也不喜欢同步调用异步代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，我建议所有对此主题感兴趣的人阅读安德鲁撰写的五篇文章的整个系列。</font><font style="vertical-align: inherit;">他在那里详细分析了哪些工作任务导致了此问题，然后考虑了几种错误的方法，然后仅描述了解决方案。</font><font style="vertical-align: inherit;">在我的文章中，我将尝试简要介绍他的研究，将重点更多地放在解决方案上。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步任务在启动Web服务中的作用</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
退后一步查看整个图片。</font><font style="vertical-align: inherit;">无论采用哪种框架，我都想解决什么概念性问题？</font></font><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有必要启动Web服务，以便它处理其客户端的请求，但是存在一组（相对）冗长的操作，没有这些操作，服务将无法响应客户端，否则其答案将是不正确的。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此类操作的示例：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">验证强类型的配置。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">填充缓存。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与数据库或其他服务的初步连接。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JIT和程序集加载（服务预热）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据库迁移。</font><font style="vertical-align: inherit;">这是安德鲁·洛克（Andrew Lock）的例子之一，但他本人也承认，毕竟，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在启动服务时</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此操作是</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">不可取的</font></a><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我想找到一个解决方案，该解决方案允许您在应用程序启动时以自然的方式执行任意异步任务，而无需GetAwaiter（）。GetResult（）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些任务必须在应用程序开始接受请求之前完成，但是对于它们的工作，他们可能需要配置和注册应用程序的服务。</font><font style="vertical-align: inherit;">因此，必须在DI配置之后执行这些任务。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这个想法可以用图表的形式表示：</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nc/eh/ym/ncehymvjo0cm3yz5p3uq-uycvpq.jpeg"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案1：可能会使继承人感到困惑的可行解决方案</font></font></h2><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lock提供</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
的第一个工作解决方案</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><font></font>
{<font></font>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span><font></font>
   {<font></font>
       IWebHost webHost = CreateWebHostBuilder(args).Build();<font></font>
<font></font>
       <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> scope = webHost.Services.CreateScope())<font></font>
       {<font></font>
           <span class="hljs-comment">//   </span>
           <span class="hljs-keyword">var</span> myService = scope.ServiceProvider.GetRequiredService&lt;MyService&gt;();<font></font>
<font></font>
           <span class="hljs-keyword">await</span> myService.DoAsyncJob();<font></font>
       }<font></font>
<font></font>
       <span class="hljs-keyword">await</span> webHost.RunAsync();<font></font>
   }<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IWebHostBuilder <span class="hljs-title">CreateWebHostBuilder</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span> =&gt;<font></font>
       WebHost.CreateDefaultBuilder(args)<font></font>
           .UseStartup&lt;Startup&gt;();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C＃7.1中异步Main（）的出现使这种方法成为可能。</font><font style="vertical-align: inherit;">唯一的负面影响是我们将配置部分从Startup.cs转移到Program.cs。</font><font style="vertical-align: inherit;">这种针对ASP.NET框架的非标准解决方案可能会使继承我们代码的人感到困惑。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案2：在DI中嵌入异步操作</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，安德鲁提出了该解决方案的改进版本。</font><font style="vertical-align: inherit;">声明了异步任务的接口：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IStartupTask</span><font></font>
{<font></font>
    <span class="hljs-function">Task <span class="hljs-title">ExecuteAsync</span>(<span class="hljs-params">CancellationToken cancellationToken = <span class="hljs-keyword">default</span></span>)</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以及在DI中注册这些任务的扩展方法：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ServiceCollectionExtensions</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IServiceCollection AddStartupTask&lt;T&gt;(<span class="hljs-keyword">this</span> IServiceCollection services)
        <span class="hljs-keyword">where</span> T : <span class="hljs-keyword">class</span>, <span class="hljs-title">IStartupTask</span><font></font>
        =&gt; services.AddTransient&lt;IStartupTask, T&gt;();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，声明了另一个扩展方法，已经用于IWebHost：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StartupTaskWebHostExtensions</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">RunWithTasksAsync</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> IWebHost webHost, CancellationToken cancellationToken = <span class="hljs-keyword">default</span></span>)</span><font></font>
    {<font></font>
        <span class="hljs-comment">//      DI</span>
        <span class="hljs-keyword">var</span> startupTasks = webHost.Services.GetServices&lt;IStartupTask&gt;();<font></font>
<font></font>
        <span class="hljs-comment">//   </span>
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> startupTask <span class="hljs-keyword">in</span> startupTasks)<font></font>
        {<font></font>
            <span class="hljs-keyword">await</span> startupTask.ExecuteAsync(cancellationToken);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">//    </span>
        <span class="hljs-keyword">await</span> webHost.RunAsync(cancellationToken);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Program.cs中，我们仅更改一行。</font><font style="vertical-align: inherit;">代替：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">await</span> CreateWebHostBuilder(args).Build().Run();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们称之为：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">await</span> CreateWebHostBuilder(args).Build().RunWithTasksAsync();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我认为，一种很棒的方法可以使启动应用程序时长时间操作的工作尽可能透明。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案＃3：对于那些切换到ASP.NET Core 3.x的用户</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，如果您使用的是ASP.NET Core 3.x，则还有另一种选择。</font><font style="vertical-align: inherit;">我将再次参考</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andrew Lock的文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是ASP.NET Core 2.x的WebHost启动代码：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WebHost</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">StartAsync</span>(<span class="hljs-params">CancellationToken cancellationToken = <span class="hljs-keyword">default</span></span>)</span><font></font>
    {<font></font>
        <span class="hljs-comment">// ... initial setup</span>
        <span class="hljs-keyword">await</span> Server.StartAsync(hostingApp, cancellationToken).ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Fire IApplicationLifetime.Started</span><font></font>
        _applicationLifetime?.NotifyStarted();<font></font>
<font></font>
        <span class="hljs-comment">// Fire IHostedService.Start</span>
        <span class="hljs-keyword">await</span> _hostedServiceExecutor.StartAsync(cancellationToken).ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
<font></font>
        <span class="hljs-comment">// ...remaining setup</span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是</font><font style="vertical-align: inherit;">ASP.NET Core 3.0中</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的相同方法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WebHost</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">StartAsync</span>(<span class="hljs-params">CancellationToken cancellationToken = <span class="hljs-keyword">default</span></span>)</span><font></font>
    {<font></font>
        <span class="hljs-comment">// ... initial setup</span><font></font>
<font></font>
        <span class="hljs-comment">// Fire IHostedService.Start</span>
        <span class="hljs-keyword">await</span> _hostedServiceExecutor.StartAsync(cancellationToken).ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
<font></font>
        <span class="hljs-comment">// ... more setup</span>
        <span class="hljs-keyword">await</span> Server.StartAsync(hostingApp, cancellationToken).ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Fire IApplicationLifetime.Started</span><font></font>
        _applicationLifetime?.NotifyStarted();<font></font>
<font></font>
        <span class="hljs-comment">// ...remaining setup</span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在ASP.NET Core 3.x中，首先启动HostedServices，然后才启动主WebHost，与之相反。</font><font style="vertical-align: inherit;">这给了我们什么？</font><font style="vertical-align: inherit;">现在，可以在IHostedService接口的StartAsync（CancellationToken）方法内部调用所有异步操作，并且无需创建单独的接口和扩展方法即可达到相同的效果。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案4：健康检查和Kubernetes的故事</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个人可以对此平静下来，但是有另一种方法，突然间它在当前现实中变得很重要。这是使用健康检查。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本思想是尽早启动Kestrel服务器，以通知负载平衡器该服务已准备好接受请求。但是同时，所有非健康检查请求都将返回503（服务不可用）。 Microsoft网站上有一篇相当</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">广泛的文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">内容涉及如何在ASP.NET Core中使用运行状况检查。我想考虑这种方法，但没有适用于我们任务的特殊细节。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
安德鲁·洛克（Andrew Lock）</font><font style="vertical-align: inherit;">对此方法</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另有单独的文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它的主要优点是可以避免网络超时。</font></font><br>
<blockquote> ,          ,    ,     .  Kestrel   ,       ,       «   ».</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此，我将不为健康检查方法提供完整的Andrew Lock解决方案。它非常庞大，但是没有什么复杂的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
简而言之，您将需要启动Web服务，而不必等待异步操作的完成。在这种情况下，运行状况检查端点应了解这些操作的状态，在执行这些操作时发出503，在它们完成时发出200。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
老实说，当我研究此选项时，我有一定的怀疑态度。与以前的方法相比，整个解决方案看起来很麻烦。如果我们进行类比，那么这就是如何再次将</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EAP方法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与事件订阅一起使用，而不是已经熟悉的异步/等待。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是随后，Kubernetes开始发挥作用。</font><font style="vertical-align: inherit;">他有自己的准备调查概念。</font><font style="vertical-align: inherit;">我将在我的免费演讲中引用“实践中的Kubernetes”一书：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">始终确定准备情况探针。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您没有准备情况调查，那么您的Pod几乎会立即成为服务的端点。</font><font style="vertical-align: inherit;">如果您的应用程序花费太多时间准备接受传入请求，则客户端对服务的请求也将启动尚未准备好接受传入连接的Pod。</font><font style="vertical-align: inherit;">结果，客户端将收到“连接被拒绝”错误。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我进行了一个简单的实验：我在HostedService中创建了一个带有长时间异步任务的ASP.NET Core 3服务：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LongTaskHostedService</span> : <span class="hljs-title">IHostedService</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">StartAsync</span>(<span class="hljs-params">CancellationToken cancellationToken</span>)</span><font></font>
    {<font></font>
            Console.WriteLine(<span class="hljs-string">"Long task started..."</span>);
            <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">5000</span>, cancellationToken);<font></font>
            Console.WriteLine(<span class="hljs-string">"Long task finished."</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">StopAsync</span>(<span class="hljs-params">CancellationToken cancellationToken</span>)</span><font></font>
    {...}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我使用minikube启动此服务，然后在延迟的5秒钟内将其数目增加到2以下时，我的第二个请求并没有产生有用的信息，而是“连接被拒绝”。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes 1.16 UPD</font></font></b><div class="spoiler_text">    , ,   Kubernetes 1.16  startup probe (   ).     ,     readiness probe.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>.      .<br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发现</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从所有这些研究中可以得出什么结论？</font><font style="vertical-align: inherit;">也许每个人都应该为自己的项目决定哪种解决方案最合适。</font><font style="vertical-align: inherit;">如果假定异步操作不会花费太多时间，并且客户端具有某种重试策略，则可以使用所有方法，从ASP.NET Core 3.x中的GetAwaiter（）.GetResult（）开始，以IHostedService结束。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一方面，如果您使用Kubernetes并且您的异步操作可以执行很长时间，那么您就不能没有运行状况检查（也称为就绪/启动探针）。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN496260/index.html">在家工作的网络安全提示</a></li>
<li><a href="../zh-CN496262/index.html">获取CVE ID</a></li>
<li><a href="../zh-CN496266/index.html">冠状病毒：我们都会死吗？</a></li>
<li><a href="../zh-CN496268/index.html">2020年面向企业客户的华为企业网络产品和解决方案</a></li>
<li><a href="../zh-CN496272/index.html">差异性隐私：比较库</a></li>
<li><a href="../zh-CN496302/index.html">如何不在黑客不在时将公司交给黑客。SOC专家提示</a></li>
<li><a href="../zh-CN496304/index.html">在制作游戏时如何继续学习UE4</a></li>
<li><a href="../zh-CN496308/index.html">创建无缝噪声图</a></li>
<li><a href="../zh-CN499818/index.html">乌兹别克电报营销</a></li>
<li><a href="../zh-CN499820/index.html">为什么我们选择Kotlin作为我们的目标语言之一。第2部分：Kotlin多平台</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>