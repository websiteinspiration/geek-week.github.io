<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸🏼 🏻 🧚🏻 Stas Afanasyev. Juno. Pipelines basierend auf io.Reader / io.Writer. Teil 1 🔀 💾 👉🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In dem Bericht werden wir über das Konzept von io.Reader / io.Writer sprechen, warum sie benötigt werden, wie sie korrekt implementiert werden und wel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Stas Afanasyev. Juno. Pipelines basierend auf io.Reader / io.Writer. Teil 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/491484/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dem Bericht werden wir über das Konzept von io.Reader / io.Writer sprechen, warum sie benötigt werden, wie sie korrekt implementiert werden und welche Fallstricke diesbezüglich bestehen, sowie über das Erstellen von Pipelines basierend auf Standard- und benutzerdefinierten io.Reader / io.Writer-Implementierungen .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rd/nv/uj/rdnvujcjwsukejxq_6a9syayawu.jpeg"><a name="habracut"></a><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stanislav Afanasyev (im Folgenden - SA):</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Guten Tag! Ich heiße Stas. Ich kam aus Minsk, von der Firma Juno. Vielen Dank, dass Sie an diesem regnerischen Tag gekommen sind und die Kraft gefunden haben, das Haus zu verlassen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heute möchte ich mit Ihnen über ein Thema wie das Erstellen von Pipelines Go sprechen, das auf io.Reader / io.Writer-Schnittstellen basiert. Worüber ich heute sprechen werde, ist im Allgemeinen das Konzept der io.Reader / io.Writer-Schnittstellen, warum sie benötigt werden, wie man sie richtig verwendet und, was am wichtigsten ist, wie man sie richtig implementiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden auch über den Bau von Pipelines sprechen, die auf verschiedenen Implementierungen dieser Schnittstellen basieren. Wir werden über bestehende Methoden sprechen, deren Vor- und Nachteile diskutieren. Ich werde verschiedene Fallstricke erwähnen (dies wird im Überfluss vorhanden sein).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir beginnen, müssen wir die Frage beantworten, warum diese Schnittstellen überhaupt benötigt werden. </font><font style="vertical-align: inherit;">Heben Sie Ihre Hände, die mit Go eng zusammenarbeiten (jeden Tag, jeden zweiten Tag) ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d2/pd/f4/d2pdf4kdwdjk_vxkqz6fwckqrgk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Großartig! </font><font style="vertical-align: inherit;">Wir haben immer noch eine Go-Community. </font><font style="vertical-align: inherit;">Ich denke, viele von Ihnen haben mit diesen Schnittstellen gearbeitet, zumindest davon gehört. </font><font style="vertical-align: inherit;">Sie wissen vielleicht nicht einmal davon, aber Sie hätten sicherlich etwas über sie hören sollen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens sind diese Schnittstellen eine Abstraktion der Eingabe-Ausgabe-Operation in all ihren Erscheinungsformen. </font><font style="vertical-align: inherit;">Zweitens ist es eine sehr praktische API, mit der Sie Pipelines wie einen Konstruktor aus Cubes erstellen können, ohne wirklich über die internen Details der Implementierung nachdenken zu müssen. </font><font style="vertical-align: inherit;">Zumindest war das ursprünglich beabsichtigt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist eine sehr einfache Schnittstelle. Es besteht nur aus einer Methode - der Read-Methode. Konzeptionell kann die Implementierung der io.Reader-Schnittstelle eine Netzwerkverbindung sein - beispielsweise wenn noch keine Daten vorhanden sind, diese jedoch dort angezeigt werden können: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/n-/4n/dc/n-4ndcbxpoxkul6h227ue7hruli.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es kann sich um einen Puffer im Speicher handeln, in dem die Daten bereits vorhanden sind und vollständig ausgelesen werden können. Es kann auch ein Dateideskriptor sein - wir können diese Datei in Teilen lesen, wenn sie sehr groß ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die konzeptionelle Implementierung der io.Reader-Schnittstelle ist der Zugriff auf einige Daten. Alle Fälle, die ich geschrieben habe, werden von der Read-Methode unterstützt. Es gibt nur ein Argument - dies ist Slice-Byte.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Punkt, den Sie hier ansprechen sollten. Diejenigen, die kürzlich zu Go gekommen sind oder von einer anderen Technologie stammen, bei der es keine ähnliche API gab (ich bin eine davon), diese Signatur ist etwas verwirrend. Die Read-Methode scheint dieses Slice irgendwie zu lesen. In der Tat ist das Gegenteil der Fall: Die Reader-Schnittstellenimplementierung liest die darin enthaltenen Daten und füllt diesen Slice mit den Daten, die diese Implementierung enthält.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die maximale Datenmenge, die auf Anfrage von der Read-Methode gelesen werden kann, entspricht der Länge dieses Slice. </font><font style="vertical-align: inherit;">Eine reguläre Implementierung gibt so viele Daten zurück, wie zum Zeitpunkt der Anforderung zurückgegeben werden können, oder die maximale Menge, die in dieses Slice passt. </font><font style="vertical-align: inherit;">Dies deutet darauf hin, dass Reader in Teilen gelesen werden kann: mindestens byteweise, mindestens zehn - wie Sie möchten. </font><font style="vertical-align: inherit;">Und der Client, der Reader gemäß den Rückgabewerten der Read-Methode aufruft, überlegt, wie er weiterleben soll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Read-Methode gibt zwei Werte zurück:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anzahl der abgezogenen Bytes;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Fehler, wenn es aufgetreten ist.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Werte beeinflussen das weitere Verhalten des Kunden. </font><font style="vertical-align: inherit;">Auf der Folie befindet sich ein GIF, das diesen soeben beschriebenen Vorgang anzeigt:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/si/ww/sf/siwwsf6u8mb1nkztg0ltnumkckw.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/p1/hk/mb/p1hkmbpfp8-twtnznjj2ihireaa.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Io.Reader - Wie geht das?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt genau zwei Möglichkeiten, wie Ihre Daten die Reader-Oberfläche erfüllen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/l0/fm/e7/l0fme7quz_tqzilkfiuiddpgjk4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste ist der einfachste. Wenn Sie eine Art Slice-Byte haben und möchten, dass es die Reader-Schnittstelle erfüllt, können Sie die Implementierung einer Standardbibliothek übernehmen, die diese Schnittstelle bereits erfüllt. Zum Beispiel Reader aus dem Byte-Paket. Auf der Folie oben sehen Sie die Signatur, wie dieser Reader erstellt wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt einen komplizierteren Weg - die Reader-Oberfläche selbst zu implementieren. Die Dokumentation enthält ungefähr 30 Zeilen mit kniffligen Regeln, Einschränkungen, die befolgt werden müssen. Bevor wir über alle sprechen, wurde es für mich interessant: „Und in welchen Fällen reichen nicht genügend Standardimplementierungen (Standardbibliothek) aus? Wann müssen wir die Reader-Schnittstelle selbst implementieren? “</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diese Frage zu beantworten, nahm ich tausend der beliebtesten Repositories auf Github (nach Anzahl der Sterne), fügte sie hinzu und fand dort alle Implementierungen der Reader-Oberfläche. </font><font style="vertical-align: inherit;">Auf der Folie habe ich einige Statistiken (kategorisiert) darüber, wann Leute diese Schnittstelle implementieren.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die beliebteste Kategorie sind Verbindungen. </font><font style="vertical-align: inherit;">Dies ist eine Implementierung von proprietären Protokollen und Wrappern für vorhandene Typen. </font><font style="vertical-align: inherit;">Brad Fitzpatrick hat also ein Camlistore-Projekt - es gibt ein Beispiel in Form von statTrackingConn, das im Allgemeinen ein gewöhnlicher Wrapper über den Con-Typ aus dem Netzpaket ist (fügt diesem Typ Metriken hinzu).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweitbeliebteste Kategorie sind benutzerdefinierte Puffer. </font><font style="vertical-align: inherit;">Hier hat mir das einzige Beispiel gefallen: dataBuffer aus dem x / net-Paket. </font><font style="vertical-align: inherit;">Seine Besonderheit ist, dass es in Chunks geschnittene Daten speichert und beim Subtrahieren diese Chunks durchläuft. </font><font style="vertical-align: inherit;">Wenn die Daten im Block vorbei sind, werden sie zum nächsten Block weitergeleitet. </font><font style="vertical-align: inherit;">Gleichzeitig berücksichtigt er die Länge, die Stelle, an der er die übertragene Scheibe ausfüllen kann.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere Kategorie sind alle Arten von Fortschrittsbalken, die die Anzahl der Bytes zählen, die beim Senden von Metriken abgezogen werden ...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basierend auf diesen Daten können wir sagen, dass die Notwendigkeit, die io.Reader-Schnittstelle zu implementieren, ziemlich häufig auftritt. </font><font style="vertical-align: inherit;">Lassen Sie uns dann über die Regeln sprechen, die in der Dokumentation enthalten sind.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentationsregeln</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie gesagt, die Liste der Regeln und im Allgemeinen die Dokumentation ist ziemlich umfangreich und umfangreich. 30 Zeilen reichen für eine Schnittstelle, die nur aus drei Zeilen besteht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erste, wichtigste Regel betrifft die Anzahl der zurückgegebenen Bytes. Sie muss streng größer oder gleich Null und kleiner oder gleich der Länge des gesendeten Slice sein. Warum ist es wichtig? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1k/kp/xh/1kkpxhahoiicme8z8vbdbq5ajbm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da dies ein ziemlich strenger Vertrag ist, kann der Kunde dem Betrag vertrauen, der aus der Implementierung stammt. In der Standardbibliothek befinden sich Wrapper (z. B. bytes.Buffer und bufio). Es gibt einen solchen Moment in der Standardbibliothek: Einige Implementierungen vertrauen verpackten Lesern, andere vertrauen nicht (wir werden später darüber sprechen).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bufio vertraut überhaupt nichts - es überprüft absolut alles. </font><font style="vertical-align: inherit;">Bytes.Buffer vertraut absolut allem, was zu ihm kommt. </font><font style="vertical-align: inherit;">Jetzt werde ich zeigen, was im Zusammenhang damit passiert ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden nun drei mögliche Fälle betrachten - dies sind drei implementierte Leser. </font><font style="vertical-align: inherit;">Sie sind ziemlich synthetisch und nützlich für das Verständnis. </font><font style="vertical-align: inherit;">Wir werden alle diese Leser mit dem ReadAll-Helfer lesen. </font><font style="vertical-align: inherit;">Seine Unterschrift befindet sich oben auf der Folie:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ib/c1/7b/ibc17bdqyrimk3xce2khqwera4w.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader # 1. </font><font style="vertical-align: inherit;">Beispiel 1</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ReadAll ist ein Helfer, der eine Art Implementierung der Reader-Schnittstelle übernimmt, alles liest und die gelesenen Daten sowie einen Fehler zurückgibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser erstes Beispiel ist Reader, der immer -1 und nil als Fehler zurückgibt, d. H. Einen solchen NegativeReader. Lassen Sie es uns laufen und sehen, was passiert: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7n/3h/l-/7n3hl-2vdvmgvmw80eljlorapiw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie wissen, ist Panik ohne Grund ein Zeichen von Dummheit. Aber wer in diesem Fall Dummkopf ist - ich oder Byte. Puffer - hängt vom Standpunkt ab. Diejenigen, die dieses Paket schreiben und es befolgen, haben unterschiedliche Sichtweisen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist hier passiert? Bytes.Buffer akzeptierte eine negative Anzahl von Bytes, überprüfte nicht, ob es negativ war, und versuchte, den internen Puffer entlang der oberen Grenze, den er erhielt, abzuschneiden - und wir kamen aus den Slice-Grenzen heraus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel gibt es zwei Probleme. Das erste ist, dass die Signatur nicht verboten ist, negative Zahlen zurückzugeben, und die Dokumentation ist verboten. Wenn die Signatur Uint hätte, würden wir einen klassischen Überlauf bekommen (wenn eine signierte Nummer als nicht signiert interpretiert wird). Und dies ist ein sehr kniffliger Fehler, der sicherlich am Freitagabend auftreten wird, wenn Sie bereits zu Hause versammelt sind. Daher ist Panik in diesem Fall die bevorzugte Option.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite „Punkt“ ist, dass der Stack-Trace überhaupt nicht versteht, was passiert ist. Es ist klar, dass wir die Grenzen der Scheibe überschritten haben - na und? Wenn Sie eine solche mehrschichtige Pipe haben und ein solcher Fehler auftritt, ist nicht sofort klar, was passiert ist. Das Bufio der Standardbibliothek gerät in dieser Situation ebenfalls in Panik, macht es aber schöner. Er schreibt sofort: „Ich habe eine negative Anzahl von Bytes abgezogen. Ich werde nichts anderes tun - ich weiß nicht, was ich damit anfangen soll. "</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und Bytes. Puffer gerät in Panik, so gut er kann. </font><font style="vertical-align: inherit;">Ich habe ein Problem in Golang gepostet und mich gebeten, einen menschlichen Fehler hinzuzufügen. </font><font style="vertical-align: inherit;">Am dritten Tag diskutierten wir die Aussichten dieser Entscheidung. </font><font style="vertical-align: inherit;">Der Grund ist folgender: Historisch gesehen haben verschiedene Menschen zu unterschiedlichen Zeiten unterschiedliche unkoordinierte Entscheidungen getroffen. </font><font style="vertical-align: inherit;">Und jetzt haben wir Folgendes: In einem Fall vertrauen wir der Implementierung überhaupt nicht (wir überprüfen alles), und im anderen Fall vertrauen wir voll und ganz, wir bekommen nicht, was von dort kommt. </font><font style="vertical-align: inherit;">Dies ist ein ungelöstes Problem, und wir werden mehr darüber sprechen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader # 1. </font><font style="vertical-align: inherit;">Beispiel 2</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgende Situation: Unser Reader gibt immer 0 und Null als Ergebnis zurück. </font><font style="vertical-align: inherit;">Aus vertraglicher Sicht ist hier alles legal - es gibt keine Probleme. </font><font style="vertical-align: inherit;">Die einzige Einschränkung: In der Dokumentation heißt es, dass Implementierungen nicht empfohlen werden, zusätzlich zu dem Fall, in dem die Länge des gesendeten Slice Null ist, die Werte 0 und Null zurückzugeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im wirklichen Leben kann ein solcher Leser viel Ärger verursachen. </font><font style="vertical-align: inherit;">Wir kehren also zu der Frage zurück, ob wir Reader vertrauen sollen. </font><font style="vertical-align: inherit;">Zum Beispiel ist eine Prüfung in bufio integriert: Sie liest Reader genau 100 Mal nacheinander. Wenn ein solches Wertepaar 100 Mal zurückgegeben wird, gibt es einfach NoProgress zurück. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt nichts Vergleichbares in Bytes. Puffer. </font><font style="vertical-align: inherit;">Wenn wir dieses Beispiel ausführen, erhalten wir nur eine Endlosschleife (ReadAll verwendet Bytes. Puffer unter der Haube, nicht Reader selbst):</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xh/br/zu/xhbrzuvnof4dxubt2d26i6q4l_q.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader # 1. </font><font style="vertical-align: inherit;">Beispiel 2</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Noch ein Beispiel. </font><font style="vertical-align: inherit;">Es ist auch ziemlich synthetisch, aber nützlich für das Verständnis: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ga/pe/xp/gapexpzfyhd6za09ss_uuwbrmlk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier geben wir immer 1 und Null zurück. </font><font style="vertical-align: inherit;">Auch hier scheint es keine Probleme zu geben - aus vertraglicher Sicht ist alles legal. </font><font style="vertical-align: inherit;">Es gibt eine Nuance: Wenn ich dieses Beispiel auf meinem Computer ausführe, friert es nach 30 Sekunden ein ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies liegt daran, dass der Client, der diesen Reader liest (dh bytes.Buffer), niemals ein Zeichen für das Ende der Daten erhält - er liest, subtrahiert ... Außerdem erhält er jedes Mal ein subtrahiertes Byte. </font><font style="vertical-align: inherit;">Für ihn bedeutet dies, dass der neu positionierte Puffer irgendwann endet, immer noch läuft - die Situation wiederholt sich und er läuft bis ins Unendliche, bis er platzt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader # 2. </font><font style="vertical-align: inherit;">Fehlerrückgabe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir kommen zu der zweiten wichtigen Regel für die Implementierung der Reader-Schnittstelle - dies ist eine Fehlerrückgabe. </font><font style="vertical-align: inherit;">Die Dokumentation enthält drei Fehler, die die Implementierung zurückgeben sollte. </font><font style="vertical-align: inherit;">Der wichtigste von ihnen ist EOF. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EOF ist das eigentliche Zeichen für das Ende der Daten, das die Implementierung zurückgeben sollte, wenn die Daten ausgehen. </font><font style="vertical-align: inherit;">Konzeptionell ist dies im Allgemeinen kein Fehler, sondern ein Fehler. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt einen weiteren Fehler namens UnexpectedEOF. </font><font style="vertical-align: inherit;">Wenn der Reader beim Lesen plötzlich die Daten nicht mehr lesen kann, wurde angenommen, dass er UnexpectedEOF zurückgeben würde. </font><font style="vertical-align: inherit;">Tatsächlich wird dieser Fehler jedoch nur an einer Stelle der Standardbibliothek verwendet - in der ReadAtLeast-Funktion.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-c/og/la/-coglawtrylyakbq0kxlc0ob9rs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer Fehler ist NoProgress, über den wir bereits gesprochen haben. </font><font style="vertical-align: inherit;">Die Dokumentation sagt es so: Dies ist ein Zeichen dafür, dass die Schnittstelle implementiert ist, ist zum Kotzen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Io.Reader # 3</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Dokumentation enthält eine Reihe von Fällen, wie der Fehler korrekt zurückgegeben werden kann. </font><font style="vertical-align: inherit;">Unten sehen Sie drei mögliche Fälle: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m1/ef/si/m1efsipabh8oypgch-7_ni2syc8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können einen Fehler sowohl mit abgezogener Anzahl von Bytes als auch separat zurückgeben. </font><font style="vertical-align: inherit;">Wenn Ihre Daten jedoch plötzlich in Ihrem Reader aufgebraucht sind und Sie das EOF [Endzeichen] momentan nicht zurückgeben können (viele Implementierungen der Standardbibliothek funktionieren einfach so), wird davon ausgegangen, dass Sie EOF zum nächsten aufeinander folgenden Aufruf zurückgeben (dh Sie müssen loslassen Kunde). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für den Kunden bedeutet dies, dass es keine Daten mehr gibt - kommen Sie nicht mehr zu mir. </font><font style="vertical-align: inherit;">Wenn Sie null zurückgeben und der Kunde Daten benötigt, sollte er erneut zu Ihnen kommen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader. </font><font style="vertical-align: inherit;">Fehler</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen waren dies laut Reader die wichtigsten Regeln. </font><font style="vertical-align: inherit;">Es gibt immer noch eine Reihe kleinerer, aber sie sind nicht so wichtig und führen nicht zu einer solchen Situation: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xv/iu/az/xviuazv5segzzd5ganrbinp8xli.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir alles im Zusammenhang mit Reader durchgehen, müssen wir die Frage beantworten: Ist es wichtig, dass bei benutzerdefinierten Implementierungen häufig Fehler auftreten? </font><font style="vertical-align: inherit;">Um diese Frage zu beantworten, habe ich mich an meine Spool für 1000 Repositorys gewandt (und dort haben wir ungefähr 550 benutzerdefinierte Implementierungen). </font><font style="vertical-align: inherit;">Ich schaute mit meinen Augen durch die ersten hundert. </font><font style="vertical-align: inherit;">Natürlich ist dies keine Superanalyse, aber was es ist ... Ich habe </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
die beiden beliebtesten Fehler identifiziert:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt niemals EOF zurück;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu viel Vertrauen in den verpackten Reader.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auch dies ist aus meiner Sicht ein Problem. </font><font style="vertical-align: inherit;">Und für diejenigen, die sich das io-Paket ansehen, ist dies kein Problem. </font><font style="vertical-align: inherit;">Wir werden noch einmal darüber sprechen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich möchte auf eine Nuance zurückkommen. </font><font style="vertical-align: inherit;">Siehe: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/te/3h/9q/te3h9q46okeg22rijrfyxrmi4da.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Client sollte das Paar 0 und Null niemals als EOF interpretieren. </font><font style="vertical-align: inherit;">Das ist ein Fehler! </font><font style="vertical-align: inherit;">Für Reader ist dieser Wert nur eine Gelegenheit, den Client loszulassen. </font><font style="vertical-align: inherit;">Die beiden Fehler, die ich erwähnt habe, scheinen unbedeutend zu sein, aber es reicht aus, sich vorzustellen, dass Sie eine mehrschichtige Pipeline in der Prod und einen kleinen, schlauen "Bagul" in der Mitte haben, dann wird das "unterirdische Klopfen" nicht lange dauern - garantiert! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Laut Reader im Grunde alles. </font><font style="vertical-align: inherit;">Dies waren die grundlegenden Implementierungsregeln.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Writer</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am anderen Ende der Pipelines haben wir io.Writer, wo wir normalerweise Daten schreiben. </font><font style="vertical-align: inherit;">Eine sehr ähnliche Schnittstelle: Sie besteht ebenfalls aus einer Methode (Write), deren Signatur ähnlich ist. </font><font style="vertical-align: inherit;">Aus semantischer Sicht ist die Writer-Oberfläche verständlicher: Ich würde sagen, dass sie, wie sie gehört wird, geschrieben ist. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fq/ya/ls/fqyalshoz2lwp48cs5u8oa9ymdk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Write-Methode nimmt ein Slice-Byte und schreibt es vollständig. </font><font style="vertical-align: inherit;">Er hat auch eine Reihe von Regeln, die befolgt werden müssen.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste betrifft die zurückgegebene Anzahl der geschriebenen Bytes. </font><font style="vertical-align: inherit;">Ich würde sagen, dass es nicht so streng ist, weil ich kein einziges Beispiel gefunden habe, das zu einigen kritischen Konsequenzen führen würde - zum Beispiel zu Panik. </font><font style="vertical-align: inherit;">Dies ist nicht sehr streng, da es die folgende Regel gibt ...</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Writer-Implementierung muss einen Fehler zurückgeben, wenn die geschriebene Datenmenge geringer ist als die gesendete. </font><font style="vertical-align: inherit;">Das heißt, eine teilweise Aufzeichnung wird nicht unterstützt. </font><font style="vertical-align: inherit;">Dies bedeutet, dass es nicht sehr wichtig ist, wie viele Bytes geschrieben wurden.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Noch eine Regel: Writer sollte das gesendete Slice auf keinen Fall ändern, da der Client weiterhin mit diesem Slice arbeitet.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Writer sollte dieses Slice nicht halten (Reader hat die gleiche Regel). </font><font style="vertical-align: inherit;">Wenn Sie für einige Vorgänge Daten in Ihrer Implementierung benötigen, müssen Sie nur diese Folie kopieren.</font></font></li>
</ol><br>
<img src="https://habrastorage.org/webt/iy/tx/qe/iytxqemg1nabcwxyfzxtgszmjxy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von Reader und Writer, das war's.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dendrogramm</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Speziell für diesen Bericht habe ich ein Implementierungsdiagramm erstellt und es in Form eines Dendrogramms entworfen. </font><font style="vertical-align: inherit;">Diejenigen, die jetzt wollen, können diesem QR-Code folgen: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/r2/zp/pq/r2zppqu-0snqu80oqyxxpxakkpc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Dendrogramm enthält alle Implementierungen aller Schnittstellen des io-Pakets. </font><font style="vertical-align: inherit;">Dieses Dendrogramm wird benötigt, um einfach zu verstehen: Was und mit was können Sie in den Pipelines zusammenhalten, wo und was können Sie lesen, wo können Sie schreiben. </font><font style="vertical-align: inherit;">Ich werde im Verlauf meines Berichts weiterhin darauf verweisen. Bitte beziehen Sie sich daher auf den QR-Code.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pipelines</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben darüber gesprochen, was Reader, io.Writer ist. Lassen Sie uns nun über die API sprechen, die in der Standardbibliothek zum Erstellen von Pipelines vorhanden ist. Beginnen wir mit den Grundlagen. Vielleicht wird es für niemanden interessant sein. Dies ist jedoch sehr wichtig. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden die Daten aus dem Standardeingabestream (von Stdin) lesen: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zq/tq/4m/zqtq4mfocqntafmpk5m_scirhcm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stdin wird in Go durch eine globale Variable vom Typ Datei aus dem Betriebssystempaket dargestellt. Wenn Sie sich das Dendrogramm ansehen, werden Sie feststellen, dass der Dateityp auch die Reader- und Writer-Schnittstellen implementiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Moment interessieren wir uns für Reader. Wir werden Stdin mit demselben ReadAll-Helfer vorlesen, den wir bereits verwendet haben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Nuance in Bezug auf diesen Helfer ist erwähnenswert: ReadAll liest den Reader bis zum Ende, bestimmt jedoch das Ende durch EOF, durch das Zeichen des Endes, über das wir gesprochen haben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden jetzt die Datenmenge begrenzen, die wir von Stdin lesen. Zu diesem Zweck gibt es eine Implementierung von LimitedReader in der Standardbibliothek: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qq/dm/hn/qqdmhnj73dfyxpdlrpoffwzimgq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich möchte, dass Sie darauf achten, wie LimitedReader die Anzahl der zu lesenden Bytes begrenzt. Man würde denken, dass diese Implementierung, dieser Wrapper, alles, was sich im Reader befindet, subtrahiert, was er umschließt, und dann so viel gibt, wie wir wollen. Aber alles funktioniert ein bisschen anders ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LimitedReader schneidet das ihm gegebene Slice als Argument entlang der oberen Grenze ab. </font><font style="vertical-align: inherit;">Und er gibt diese beschnittene Scheibe an Reader weiter, der sie einwickelt. </font><font style="vertical-align: inherit;">Dies ist eine klare Demonstration, wie die Länge der gelesenen Daten in den Implementierungen der io.Reader-Schnittstelle reguliert wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehler beim Zurückgeben des Dateiende</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer interessanter Punkt: Beachten Sie, wie diese Implementierung einen EOF-Fehler zurückgibt! </font><font style="vertical-align: inherit;">Die zurückgegebenen benannten Werte werden hier verwendet und durch die Werte zugewiesen, die wir vom umschlossenen Reader erhalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wenn sich im umschlossenen Reader mehr Daten befinden, als wir benötigen, weisen wir die Werte des umschlossenen Readers zu - beispielsweise 10 Byte und Null -, da sich noch Daten im umschlossenen Reader befinden. </font><font style="vertical-align: inherit;">Aber die Variable n, die abnimmt (in der vorletzten Zeile), sagt, dass wir den „Boden“ erreicht haben - das Ende dessen, was wir brauchen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der nächsten Iteration sollte der Client erneut kommen - unter der ersten Bedingung erhält er EOF. </font><font style="vertical-align: inherit;">Dies ist der Fall, den ich erwähnt habe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wird sehr bald fortgesetzt ...</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/kuyjuGk1USY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein bisschen Werbung :)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielen Dank für Ihren Aufenthalt bei uns. Gefällt dir unser Artikel? Möchten Sie weitere interessante Materialien sehen? Unterstützen Sie uns, indem Sie eine Bestellung </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">aufgeben</font></a><font style="vertical-align: inherit;"> oder Ihren Freunden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloud-basiertes VPS für Entwickler ab 4,99 US-Dollar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> empfehlen </font><font style="vertical-align: inherit;">, ein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einzigartiges Analogon von Einstiegsservern, das von uns für Sie erfunden wurde: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die ganze Wahrheit über VPS (KVM) E5-2697 v3 (6 Kerne) 10 GB DDR4 480 GB SSD 1 Gbit / s ab 19 $ oder wie teilt man den Server?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Optionen sind mit RAID1 und RAID10, bis zu 24 Kernen und bis zu 40 GB DDR4 verfügbar). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xd 2-mal günstiger im Equinix Tier IV-Rechenzentrum in Amsterdam?</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nur wir haben </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2,6 GHz 14C 64 GB DDR4 4 x 960 GB SSD 1 Gbit / s 100 TV von 199 US-Dollar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in den Niederlanden!</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R420 - 2x E5-2430 2,2 GHz 6C 128 GB DDR3 2x960 GB SSD 1 Gbit / s 100 TB - ab 99 US-Dollar! </font></font></b></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr über</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den Aufbau eines Infrastrukturgebäudes. </font><font style="vertical-align: inherit;">Klasse C mit Dell R730xd E5-2650 v4-Servern für 9.000 Euro für einen Cent?</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de491462/index.html">Wochenendlesung: 12 Podcasts, UKW-Radiosender aus der Sonnenuntergangszeit und Meditations-Apps</a></li>
<li><a href="../de491476/index.html">MEMS-Beschleunigungsmesser, Magnetometer und Orientierungswinkel</a></li>
<li><a href="../de491478/index.html">Ein neues Implantat für Blinde verbindet sich direkt mit dem Gehirn</a></li>
<li><a href="../de491480/index.html">CoVirus MVP-Projekt - eine Online-Karte der Coronavirus-Infektion oder ein „roter Knopf“ in Ihrer Hand</a></li>
<li><a href="../de491482/index.html">Einführung in PowerShell 7.0</a></li>
<li><a href="../de491486/index.html">Benutzerdefiniertes Skript beim Schließen des Deckels des Laptops und Sperren des Bildschirms ohne Ruhezustand</a></li>
<li><a href="../de491488/index.html">Was bedeutet es, agil zu sein?</a></li>
<li><a href="../de491490/index.html">Wie erbt Gitlab-CI Umgebungsvariablen?</a></li>
<li><a href="../de491494/index.html">Der grandiose Betrug der sowjetischen Wissenschaft: Warum sich ein wiederverwendbares Orbitalschiff als einmalig herausstellte</a></li>
<li><a href="../de491496/index.html">Tipps und Tricks zu IntelliJ IDEA: 1. Vergleichen von Dateien und Ordnern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>