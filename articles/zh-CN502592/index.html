<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺🏽 🧝🏻 🙌🏾 使用SwiftUI的新态。第1部分 👩🏽‍🤝‍👨🏼 👩🏾‍🎤 ☠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="敬礼，哈布里沃派！预期将推出高级课程“ IOS Developer”，我们还准备了另一篇有趣的翻译。
 
 
 
 尽管实际上，Apple在WWDC18上就将其用作设计主题，但非变形设计也许是近几个月来最有趣的趋势。在本文中，我们将研究如何使用SwiftUI实现非变形设计，为什么要这样做，以及-最重...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>使用SwiftUI的新态。第1部分</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/502592/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敬礼，哈布里沃派！</font><font style="vertical-align: inherit;">预期将推出高级课程</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ IOS Developer”，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们还准备了另一篇有趣的翻译。</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/nr/7d/ml/nr7dmlj7ru0rbnazf8ce8wox3ra.png"><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管实际上，Apple在WWDC18上就将其用作设计主题，但非变形设计也许是近几个月来最有趣的趋势。</font><font style="vertical-align: inherit;">在本文中，我们将研究如何使用SwiftUI实现非变形设计，为什么要这样做，以及-最重要的是-我们如何优化该设计以增加其可访问性。</font></font><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要提示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：新态（有时也称为神经形态）会对可访问性产生严重影响，因此尽管有阅读本文第一部分的诱惑，但跳过了其余部分，但我还是恳请您阅读本文末尾，并检查优缺点，以便可以看到整个图片。 。</font></font><br>
</blockquote><a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/z3tJdxwlo_Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新形态学的基础</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在继续学习代码之前，我想简要概述一下设计方向的两个基本原理，因为在我们前进时它们将是相关的：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neomorphism使用眩光和阴影来确定屏幕上对象的形状。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对比度趋于降低；</font><font style="vertical-align: inherit;">不会使用完全白色或黑色，这样可以突出显示高光和阴影。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最终结果是使人联想到“挤压塑料”的外观-一种用户界面设计，看起来自然而有趣，而不会撞到您的眼睛。</font><font style="vertical-align: inherit;">我不得不再说一遍，降低对比度并使用阴影突出显示形状会严重影响可访问性，我们将在稍后再次讨论。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，我仍然认为花时间学习SwiftUI中的新事物是值得的-即使您不在自己的应用程序中使用新事物，这就像编写kata来帮助提高技能的代码一样。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好了，足够多的闲聊-让我们继续进行代码。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建立非形态图</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最简单的起点是创建一个非变形贴图：一个将包含一些信息的圆角矩形。接下来，我们将研究如何将这些原理转移到SwiftUI的其他部分。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们首先使用Single View应用程序模板创建一个新的iOS项目。确保将SwiftUI用于用户界面，然后将项目命名为Neumorphism。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
提示：如果您有权使用Xcode预览SwiftUI，建议您立即激活它-实验起来会容易得多。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将从定义代表乳白色调的颜色开始。</font><font style="vertical-align: inherit;">这不是纯灰色，而是非常微妙的阴影，为界面增加了些许温暖或凉爽。</font><font style="vertical-align: inherit;">您可以根据需要将其添加到资产目录，但是现在可以更轻松地在代码中进行操作。</font><font style="vertical-align: inherit;">在结构之外</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
添加</font><font style="vertical-align: inherit;">：</font></font><code>Color</code><font style="vertical-align: inherit;"></font><code>ContentView</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Color</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> offWhite = <span class="hljs-type">Color</span>(red: <span class="hljs-number">225</span> / <span class="hljs-number">255</span>, green: <span class="hljs-number">225</span> / <span class="hljs-number">255</span>, blue: <span class="hljs-number">235</span> / <span class="hljs-number">255</span>)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是的，它几乎是白色的，但是它足够深，可以在需要时使真实的白色看起来像是发光的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们可以</font></font><code>ContentView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供它</font><font style="vertical-align: inherit;">填充</font></font><code>ZStack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整个屏幕，并使用新的准白色填充整个空间：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ZStack</span> {
            <span class="hljs-type">Color</span>.offWhite<font></font>
        }<font></font>
        .edgesIgnoringSafeArea(.all)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了表示我们的地图，我们将使用300x300分辨率的圆角矩形使其在屏幕上清晰美观。</font><font style="vertical-align: inherit;">因此，将其添加到</font></font><code>ZStack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下方的颜色下：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">25</span>)<font></font>
    .frame(width: <span class="hljs-number">300</span>, height: <span class="hljs-number">300</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
默认情况下，它将是黑色，但是对于新变形的实现，我们希望大幅降低对比度，因此我们将其替换为与背景相同的颜色，实际上使形状不可见。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所以像这样改变它：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">25</span>)<font></font>
    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
    .frame(width: <span class="hljs-number">300</span>, height: <span class="hljs-number">300</span>)</code></pre><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要的一点是：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用阴影，一暗一灯来确定形状，就像光线从屏幕的左上角投射光线一样。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftUI允许我们多次应用修饰符，这有助于实现新态。</font><font style="vertical-align: inherit;">将以下两个修饰符添加到圆角矩形：</font></font><br>
<br>
<pre><code class="swift hljs">.shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
.shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它们代表右下角的暗影偏移和左上角的光影偏移。</font><font style="vertical-align: inherit;">之所以可以看到光影，是因为我们使用了准白色的背景，现在地图变得可见了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们只写了几行代码，但是我们已经有了一个非形态映射-我希望您同意SwiftUI出人意料地促进了这一过程！</font></font><br>
<br>
<img src="https://habrastorage.org/webt/he/_z/0h/he_z0hdu4zlhtftzxwsvxo5k9t8.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建一个简单的非变形按钮</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在用户界面的所有元素中，新变态对卡的风险相当低-如果卡内的用户界面清晰，则卡可能没有清晰的边框，并且不会影响可访问性。按钮是另一回事，因为它们被设计为可以交互的，所以降低对比度可能弊大于利。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们通过创建我们自己的按钮样式来解决此问题，因为这是SwiftUI允许按钮配置分布在许多地方的方式。这比向您创建的每个按钮添加许多修饰符要方便得多-我们只需定义一次样式即可在很多地方使用它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将定义一个实际上为空的按钮样式：SwiftUI将为我们提供按钮的标签，该标签可以是文本，图像或其他内容，我们将不做任何更改将其发送回去。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在外部添加此结构</font></font><code>ContentView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SimpleButtonStyle</span>: <span class="hljs-title">ButtonStyle</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeBody</span><span class="hljs-params">(configuration: <span class="hljs-keyword">Self</span>.Configuration)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        configuration.label<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这</font></font><code>configuration.label</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就是保存按钮内容的内容，很快我们将添加其他内容。</font><font style="vertical-align: inherit;">首先，让我们定义一个使用它的按钮，以便您可以查看设计的发展情况：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">Button</span>(action: {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Button tapped"</span>)<font></font>
}) {<font></font>
    <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">"heart.fill"</span>)<font></font>
        .foregroundColor(.gray)<font></font>
}<font></font>
.buttonStyle(<span class="hljs-type">SimpleButtonStyle</span>())</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您不会在屏幕上看到任何特别的东西，但是我们可以通过在按钮样式中添加非变形效果来修复它。这次我们将不使用圆角矩形，因为对于简单的图标来说，圆形会更好，但是我们需要添加一些缩进，以使按钮单击区域大而美观。</font><font style="vertical-align: inherit;">通过添加一些缩进来</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更改方法</font></font><code>makeBody()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后将非变形效果作为按钮的背景：</font></font><br>
<br>
<pre><code class="swift hljs">configuration.label<font></font>
    .padding(<span class="hljs-number">30</span>)<font></font>
    .background(<font></font>
        <span class="hljs-type">Circle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
            .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
            .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
    )</code></pre><br>
<img src="https://habrastorage.org/webt/nm/-x/yp/nm-xyp4klovncqtomhthav-za7y.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这使我们足够接近所需的效果，但是如果您运行该应用程序，您会发现实际上该行为仍然不是完美的-按下按钮时，该按钮没有视觉响应，这看起来很奇怪。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要解决此问题，我们需要</font></font><code>configuration.isPressed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在自定义按钮样式中</font><font style="vertical-align: inherit;">读取属性，该属性</font><font style="vertical-align: inherit;">指示按钮当前是否处于按下状态。我们可以使用它来改进样式，以直观地指示按钮是否被按下。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们从一个简单的例子开始：我们将使用</font></font><code>Group</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按钮作为背景，然后检查</font></font><code>configuration.isPressed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并返回（如果按下了按钮</font><font style="vertical-align: inherit;">，则</font><font style="vertical-align: inherit;">返回一个平坦的圆圈），否则返回当前的深色圆圈：</font></font><br>
<br>
<pre><code class="swift hljs">configuration.label<font></font>
    .padding(<span class="hljs-number">30</span>)<font></font>
    .background(<font></font>
        <span class="hljs-type">Group</span> {
            <span class="hljs-keyword">if</span> configuration.isPressed {
                <span class="hljs-type">Circle</span>()<font></font>
                    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-type">Circle</span>()<font></font>
                    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
                    .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
                    .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
            }<font></font>
        }<font></font>
    )</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于在状态下</font></font><code>isPressed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用了近似白色</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">圆圈，因此按下按钮时我们的效果不可见。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
警告：由于SwiftUI计算可点击区域的方式，我们无意中使按钮的点击区域很小-现在您需要点击图像本身，而不是其周围的非变形设计。</font><font style="vertical-align: inherit;">要解决此问题，请</font></font><code>.contentShape(Circle())</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在之后立即</font><font style="vertical-align: inherit;">添加修饰符</font></font><code>.padding(30)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以强制SwiftUI使用所有可用的分接空间。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们可以通过翻转阴影来创建人造凹面效果-通过复制</font></font><code>shadow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本效果中的</font><font style="vertical-align: inherit;">两个修改器</font><font style="vertical-align: inherit;">，将X和Y值交换为白色和黑色，如下所示：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">if</span> configuration.isPressed {
    <span class="hljs-type">Circle</span>()<font></font>
        .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-type">Circle</span>()<font></font>
        .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
估计结果。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bk/nz/gv/bknzgvars2r0e4anrdqngo12wr4.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为按钮单击创建内部阴影</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原则上，我们当前的代码已经可以使用，但是人们对效果的理解有所不同-有些人将其视为凹形按钮，而另一些人认为按钮仍未被按下，只是光线来自不同的角度。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
改进的想法是创建一个内部阴影，该阴影将模拟向内按下按钮的效果。这不是标准SwiftUI工具包的一部分，但是我们可以很容易地实现它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建一个内部阴影需要两个线性渐变，它们只是我们将在本文中使用的许多内部渐变中的第一个，因此我们将立即添加一个小的辅助扩展，</font></font><code>LinearGradient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以简化标准渐变的创建：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">LinearGradient</span> </span>{
    <span class="hljs-keyword">init</span>(<span class="hljs-number">_</span> colors: <span class="hljs-type">Color</span>...) {
        <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(gradient: <span class="hljs-type">Gradient</span>(colors: colors), startPoint: .topLeading, endPoint: .bottomTrailing)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样，我们可以简单地提供一个可变的颜色列表，以返回它们在对角线方向上的线性渐变。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，要点很重要：我们不会在已按下的圆上添加两个翻转的阴影，而是要使用模糊（描边）覆盖一个新圆，然后再应用一个渐变的圆作为蒙版。</font><font style="vertical-align: inherit;">这有点棘手，但让我零散地解释一下：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的基本圆是具有新变形效果的当前圆，其中填充了近似白色的颜色。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们在其顶部放一个圆，并用灰色框框起来，然后稍微模糊以柔化其边缘。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，我们将一个带有另一个圆的蒙版应用到叠加在顶部的该圆上，这次填充了线性渐变。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当您将一个视图用作另一个视图的遮罩时，SwiftUI会使用遮罩的Alpha通道来确定应在基本视图中显示的内容。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，如果我们绘制一个模糊的灰色笔触，然后用从黑色到透明的线性渐变对其进行遮罩，那么模糊的笔触将在一侧不可见，而在另一侧逐渐增大-我们将获得一个平滑的内部渐变。为了使效果更加明显，我们可以在两个方向上稍微移动阴影圆。经过一些实验，我发现绘制阴影较浅的阴影较浅的阴影有助于最大化效果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请记住，两个阴影用于在新态中创建深度感：一个亮和一个暗，因此我们将两次用不同的颜色添加内部阴影的这种效果。</font><font style="vertical-align: inherit;">如下</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更改圆</font></font><code>configuration.isPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">Circle</span>()<font></font>
    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
    .overlay(<font></font>
        <span class="hljs-type">Circle</span>()<font></font>
            .stroke(<span class="hljs-type">Color</span>.gray, lineWidth: <span class="hljs-number">4</span>)<font></font>
            .blur(radius: <span class="hljs-number">4</span>)<font></font>
            .offset(x: <span class="hljs-number">2</span>, y: <span class="hljs-number">2</span>)<font></font>
            .mask(<span class="hljs-type">Circle</span>().fill(<span class="hljs-type">LinearGradient</span>(<span class="hljs-type">Color</span>.black, <span class="hljs-type">Color</span>.clear)))<font></font>
    )<font></font>
    .overlay(<font></font>
        <span class="hljs-type">Circle</span>()<font></font>
            .stroke(<span class="hljs-type">Color</span>.white, lineWidth: <span class="hljs-number">8</span>)<font></font>
            .blur(radius: <span class="hljs-number">4</span>)<font></font>
            .offset(x: -<span class="hljs-number">2</span>, y: -<span class="hljs-number">2</span>)<font></font>
            .mask(<span class="hljs-type">Circle</span>().fill(<span class="hljs-type">LinearGradient</span>(<span class="hljs-type">Color</span>.clear, <span class="hljs-type">Color</span>.black)))<font></font>
    )</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果再次运行该应用程序，您将看到按按钮的效果更加明显并且看起来更好。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1r/f1/ha/1rf1hanjn-9zhj0xhglha6e4lr0.jpeg"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">至此，翻译的第一部分结束了。</font><font style="vertical-align: inherit;">在接下来的几天里，我们将发布续篇，现在，我们邀请您进一步</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解即将开始的课程</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN502576/index.html">Apple Watch价格便宜：他们如何在Avito和Yulia上“繁殖”我</a></li>
<li><a href="../zh-CN502578/index.html">关于雷达的革命，截止日期和进入第四维度</a></li>
<li><a href="../zh-CN502580/index.html">以开发人员的身份投入开源？我们处理权利（嗨，nginx）</a></li>
<li><a href="../zh-CN502584/index.html">制造商Mi Band将发布自消毒透明口罩，以防COVID-19</a></li>
<li><a href="../zh-CN502588/index.html">PowerPoint的精彩故事</a></li>
<li><a href="../zh-CN502594/index.html">Web项目未终止的7个原因以及如何处理</a></li>
<li><a href="../zh-CN502596/index.html">免费隔离教育课程：设计</a></li>
<li><a href="../zh-CN502598/index.html">安全周21：Windows打印服务漏洞</a></li>
<li><a href="../zh-CN502604/index.html">Patrik Patrick的TLS简介（第1部分）</a></li>
<li><a href="../zh-CN502608/index.html">我们如何在SaaS服务中启动应用程序市场</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>