<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕚 🌈 🥖 指定された間隔での有効な番号生成 🦂 🔄 ✋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="乱数生成に関する私の投稿の圧倒的多数は、主にさまざまな生成方式の特性を扱っていました。これは予期しない結果になる可能性がありますが、ランダム化アルゴリズムのパフォーマンスは、選択した生成スキームではなく、他の要因に依存する場合があります。この記事（Daniel Lemyrの優れた記事に触発されました...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>指定された間隔での有効な番号生成</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455702/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
乱数生成に関する私の投稿の圧倒的多数は、主にさまざまな生成方式の特性を扱っていました。これは予期しない結果になる可能性がありますが、ランダム化アルゴリズムのパフォーマンスは、選択した生成スキームではなく、他の要因に依存する場合があります。この記事（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daniel Lemyrの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">優れた</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">記事</font></a><font style="vertical-align: inherit;">に触発されました</font><font style="vertical-align: inherit;">）では、PRNエンジンのパフォーマンスを上回ることが多い、乱数生成のパフォーマンスが低下する主な理由を調べます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況を想像してみてください：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
宿題として、フアンとサーシャは同じランダム化アルゴリズムをC ++で実装します。これは、同じ大学のコンピューター上で1つのデータセットで実行されます。それらのコードはほとんど同じであり、乱数の生成のみが異なります。フアンは音楽レッスンを急いでいるので、メルセンヌの旋風を選びました。一方、サーシャはさらに数時間研究に費やしました。サーシャは最近ソーシャルネットワークから学んだ最速のPRNGのいくつかのベンチマークを実施し、最速を選択しました。ミーティングでは、サーシャは自慢するのが待ちきれず、ファンに「どのPRNGシステムを使用しましたか？」と尋ねました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「個人的に、私はメルセンヌの渦を取った-それは言語に組み込まれており、かなりうまく機能しているようだ」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「ハ！」サーシャは答えた。 「私は</font></font><code>jsf32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、古くて遅いメルセンヌの旋風よりもはるかに高速です！</font><font style="vertical-align: inherit;">私のプログラムは3分15秒で実行されます！」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「うーん、悪くないけど、私のものは1分もかからない」とフアンは言って肩をすくめる。</font><font style="vertical-align: inherit;">「それでは、私はコンサートに行かなければなりません。</font><font style="vertical-align: inherit;">私と一緒に行ってくれる？" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「いいえ」とサーシャは答えます。</font><font style="vertical-align: inherit;">「私は…ええと…私のコードをもう一度見る必要がある。」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このぎこちない架空の状況は</font><font style="vertical-align: inherit;">特に架空のもので</font><font style="vertical-align: inherit;">はあり</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ません</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">実際の結果に基づいています。</font><font style="vertical-align: inherit;">ランダム化されたアルゴリズムが思ったほど速く実行されず、ボトルネックが乱数の生成であると思われる場合、奇妙なことに、問題は乱数ジェネレータにあるとは限りません。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はじめに：実際の乱数</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最新の高品質の乱数ジェネレーターは、ランダムビットで満たされたマシンワードを作成します。つまり、通常、[0..2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）または[0..2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">の間隔で数値を生成します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">しかし、多くの場合、ユーザーは一定の間隔で数字を必要とします。たとえば、サイコロを振ったり、ランダムなトランプを選択したりする場合、数字は小さな一定の間隔で必要です。</font><font style="vertical-align: inherit;">ただし、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">混合</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リザーバーサンプリング</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランダム化されたバイナリサーチツリー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まで、多くのアルゴリズムでは</font><font style="vertical-align: inherit;">、他の間隔から取得した数値が必要です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの異なる方法を見ていきます。</font><font style="vertical-align: inherit;">議論を簡単にするために代わりに区間[の番号を生成する</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）又は[ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]、我々は、間隔の数字を生成する[0 ... </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">このようなスキームがあれば、たとえば、</font><em><font style="vertical-align: inherit;">k</font></em><font style="vertical-align: inherit;"> = </font><em><font style="vertical-align: inherit;">j</font></em><font style="vertical-align: inherit;"> - </font><em><font style="vertical-align: inherit;">iを</font></em><font style="vertical-align: inherit;">設定</font><font style="vertical-align: inherit;">し、区間[0 .. </font><em><font style="vertical-align: inherit;">k</font></em><font style="vertical-align: inherit;">）で</font><font style="vertical-align: inherit;">数値を生成し、</font><font style="vertical-align: inherit;">それに</font><em><font style="vertical-align: inherit;">i</font></em><font style="vertical-align: inherit;">を追加</font><font style="vertical-align: inherit;">することで、区間[ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）で</font><font style="vertical-align: inherit;">数値を生成でき</font><font style="vertical-align: inherit;">ます。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">組み込みC ++</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの言語には、指定された間隔で乱数を取得するための組み込みツールがあります。</font><font style="vertical-align: inherit;">たとえば、PerlやPythonなどのスクリプト言語で52枚のカードを使用してデッキからカードを削除するには</font></font><code>int(rand(52))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">それぞれ</font><font style="vertical-align: inherit;">とと</font><font style="vertical-align: inherit;">記述</font><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">ます</font></font><code>random.randint(0,52)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">[注意 </font><font style="vertical-align: inherit;">ユーザー</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暗号</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここではエラーのようです。Pythonでは、randint（a、b）がaからbまでの数値を生成します。</font><font style="vertical-align: inherit;">デッキには52枚のカードがあり、最初のカードは「0」なので、random.randint（0,51）になり</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。] C ++では、同じように使用できます</font></font><code>uniform_int_distribution</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチを実装するC ++コードは単純です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">bounded_rand</span><span class="hljs-params">(<span class="hljs-keyword">rng_t</span>&amp; rng, <span class="hljs-keyword">uint32_t</span> range)</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::uniform_int_distribution&lt;<span class="hljs-keyword">uint32_t</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(<span class="hljs-number">0</span>, range<span class="hljs-number">-1</span>)</span></span>;<font></font>
<font></font>
    <span class="hljs-keyword">return</span> dist(rng);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、以下の手法の1つが組み込みツールで使用されますが、ほとんどのユーザーはこれらのツールを使用し、「内部」で何が起こっているかを考えずに、これらのツールが正しく設計され、非常に効果的であると信じています。</font><font style="vertical-align: inherit;">C ++では、組み込みツールはかなり任意の生成エンジンで動作できるため、より複雑です。-3から17の範囲の値を生成するジェネレーターは非常に有効であり</font></font><code>std::uniform_int_distribution</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、たとえば[0。 .1000）。</font><font style="vertical-align: inherit;">つまり、C ++組み込みツールは、使用されるほとんどの場合、複雑すぎます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除算の古典的な残り（傾斜）</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純化しすぎたアプローチから単純化しすぎたアプローチに移りましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私がプログラミングを勉強したとき、剰余演算子を使用して（たとえば、52枚のカードのデッキでカードを選択するために）間隔で数値を生成しました。間隔[0..52）の数値を取得するために、と書きました</font></font><code>rand() % 52</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++では、このアプローチは次のように実装できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">bounded_rand</span><span class="hljs-params">(<span class="hljs-keyword">rng_t</span>&amp; rng, <span class="hljs-keyword">uint32_t</span> range)</span> </span>{
    <span class="hljs-keyword">return</span> rng() % range;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは単純ですが、目的の間隔で数値を取得するのが通常は遅いタスクである理由を示しています。除算が必要です（演算子によって取得された余りを計算するため</font></font><code>%</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。通常、除算は他の算術演算よりも少なくとも1桁遅いため、単一の算術演算は高速PRNGで実行されるすべての作業よりも時間がかかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、低速に加えて、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゆがんでい</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><code>rand() % 52</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">歪んだ数値を返す</font><font style="vertical-align: inherit;">理由を理解するため</font></font><code>rand()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、[0..2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">間隔で数値を作成する</font><font style="vertical-align: inherit;">とし</font><font style="vertical-align: inherit;">ます。52 </font><font style="vertical-align: inherit;">は2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32を</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全に</font><font style="vertical-align: inherit;">除算せず</font><font style="vertical-align: inherit;">、残りを48 595で82 595 524回除算することに</font><font style="vertical-align: inherit;">注意してください。</font></font><code>rand() % 52</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その後、デッキから最初の48枚のカードを選択するには82 595 525通りの方法があり、最後の4枚のカードを選択するには82 595 524通りの方法しかありません。つまり、これらの最後の4枚のカードに対してスキューは0.00000121％です（おそらくこれらはキングです）。学生時代、サイコロを投げたりカードを引いたりすることについて宿題を書いていたとき、通常はそのような小さな歪みを気にしませんでしたが、間隔を広げると歪みは直線的に大きくなります。 32ビットのPRNGの場合、2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未満の限られた間隔の</font><font style="vertical-align: inherit;">スキューは0.5％未満ですが、2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">31を</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">超えると</font><font style="vertical-align: inherit;">スキューは50％になります。一部の数値は他の数値の2倍の頻度で返されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、主に系統的エラーを排除するための戦略を使用する手法について検討しますが、64ビットのPRNGの場合、通常のアプリケーションのスキュー値は無視できる可能性が高いことは言うまでもありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の問題は、一部のジェネレータが弱い下位ビットを持っていることです。</font><font style="vertical-align: inherit;">たとえば、GPRSファミリXoroshiro +およびXoshiro +には、統計的検定に合格しない低ビットがあります。</font><font style="vertical-align: inherit;">実行すると</font></font><code>% 52</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（52が偶数であるため）、最下位ビットを直接出力に渡します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浮動小数点数の乗算（スキュー）</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の一般的な手法は、間隔[0..1）で浮動小数点数を生成するPRNGを使用して、これらの数値を必要な間隔に変換することです。このアプローチはPerlで使用され</font><font style="vertical-align: inherit;">ます。浮動小数点数を生成し、次に切り捨てて、インターバル[0..10）で整数を生成する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ために</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用すること</font></font><code>int(rand(10))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">お勧めし</font></a><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++では、このアプローチは次のように記述されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint32_t</span> <span class="hljs-title">bounded_rand</span><span class="hljs-params">(<span class="hljs-keyword">rng_t</span>&amp; rng, <span class="hljs-keyword">uint32_t</span> range)</span> </span>{
    <span class="hljs-keyword">double</span> zeroone = <span class="hljs-number">0x1</span><span class="hljs-number">.0</span>p<span class="hljs-number">-32</span> * rng();
    <span class="hljs-keyword">return</span> range * zeroone;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（</font></font><code>0x1.0p-32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-32の</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2進浮動小数点定数</font><font style="vertical-align: inherit;">であり、間隔[0..2 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">ランダムな整数を</font><font style="vertical-align: inherit;">単位間隔で2倍に</font><font style="vertical-align: inherit;">変換するために使用し</font><font style="vertical-align: inherit;">ます。代わりに、を使用してそのような変換を実行できますが、</font></font><code>ldexp(rng(), -32)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このアプローチをベンチマークしたところ、はるかに遅くなることが</font><font style="vertical-align: inherit;">わかりました</font><font style="vertical-align: inherit;">。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは、従来の除算の残り</font><font style="vertical-align: inherit;">と同じくらい</font><font style="vertical-align: inherit;">歪んでいますが、歪度は異なって見えます。たとえば、間隔[0..52）の数値を選択する場合、0、13、26、および39の数値は、他の数値よりも1回少ない頻度で発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このバージョンでは、64ビットに一般化すると、仮数が少なくとも64ビットの浮動小数点型が必要になるため、さらに不快になります。</font><font style="vertical-align: inherit;">LinuxとmacOSを備えたx86マシンで</font></font><code>long double</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、64ビットの仮数を持つ高精度のx86浮動小数点数を</font></font><code>long double</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">利用できますが、すべてのシステムに普遍的に移植することはできません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">一部のシステムでは</font></font><code>long double</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同等</font><font style="vertical-align: inherit;">です</font></font><code>double</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
良い面があります-このアプローチは、弱い低ビットのPRNGの残差解よりも高速です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整数乗算（スキュー）</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
乗算方法は、浮動小数点演算ではなく固定に適用できます。</font><font style="vertical-align: inherit;">実際、私たちは常に2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32を</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">掛けています</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">bounded_rand</span><span class="hljs-params">(<span class="hljs-keyword">rng_t</span>&amp; rng, <span class="hljs-keyword">uint32_t</span> range)</span> </span>{
    <span class="hljs-keyword">uint32_t</span> x = rng();
    <span class="hljs-keyword">uint64_t</span> m = <span class="hljs-keyword">uint64_t</span>(x) * <span class="hljs-keyword">uint64_t</span>(range);
    <span class="hljs-keyword">return</span> m &gt;&gt; <span class="hljs-number">32</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このバージョンは64ビット演算を必要とするように見えるかもしれませんが、x86プロセッサーでは、優れたコンパイラーがこのコードを32ビット命令にコンパイルします</font></font><code>mult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（2つの32ビット出力値を提供し、そのうちの1つは戻り値です）。</font><font style="vertical-align: inherit;">このバージョンは高速であることが期待できますが、浮動小数点数を乗算する方法とまったく同じようにスキューされます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドロップ分割（スキューなし）</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
浮動小数点乗算スキームを除算ベースのスキームに変更できます。乗算で</font></font><code>x * range / 2**32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">なく、</font><font style="vertical-align: inherit;">を計算し</font></font><code>x / (2**32 / range)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。整数演算を使用しているため、このバージョンでの丸めは異なる方法で実行され、必要な間隔外の値が生成される場合があります。これらの値を破棄する場合（たとえば、それらを削除して新しい値を生成する場合）、結果として、歪みのない手法が得られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例えば、32ビットのPRNGを用いてカードを引き出した場合に、我々は、32ビットの番号を生成することができ、2で割り</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カードを選択するために、/ 52 = 82595524。この手法は、32ビットのPRNGからのランダムな値が52×82595524 = 2 </font><sup><font style="vertical-align: inherit;">32</font></sup><font style="vertical-align: inherit;">未満の場合に機能します</font></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ 32-48. PRNGからのランダムな値がジェネレーターインターバルの上部の最後の48個の値の1つである場合、それを破棄し、別の値を探す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このバージョンの我々のコードは、2つの部門とトリック使用</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって</font></font><code>range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64ビット演算を使用せず。</font><font style="vertical-align: inherit;">直接計算</font></font><code>2**32 / range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するには、数値2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を表す必要があります</font><font style="vertical-align: inherit;">。これは、32ビット整数として表すには（ユニットあたり！）大きすぎます。</font><font style="vertical-align: inherit;">代わりに、私たちは、符号なし整数のために、単項否定演算をすることを考える</font></font><code>range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2の正の値を計算</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32を</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><code>range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この値を</font></font><code>range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">割ると</font><font style="vertical-align: inherit;">、1より小さい応答が得られ</font></font><code>2**32 / range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、除算と削除を使用して数値を生成するC ++コードは次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">bounded_rand</span><span class="hljs-params">(<span class="hljs-keyword">rng_t</span>&amp; rng, <span class="hljs-keyword">uint32_t</span> range)</span> </span>{
    <span class="hljs-comment">// calculates divisor = 2**32 / range</span>
    <span class="hljs-keyword">uint32_t</span> divisor = ((-range) / range) + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow, it's really 2**32</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (;;) {
        <span class="hljs-keyword">uint32_t</span> val = rng() / divisor;
        <span class="hljs-keyword">if</span> (val &lt; range)
            <span class="hljs-keyword">return</span> val;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、このアプローチには除算に基づく2つの遅い演算が必要です。これは通常、他の算術演算よりも遅いため、高速であるとは期待できません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">歪みのない除算の残りの部分（double）-OpenBSDテクニック</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、古典的な除算剰余法のスキューをなくすために、ドロップアプローチを使用することもできます。</font><font style="vertical-align: inherit;">トランプの例では、再び48個の値をドロップする必要があります。</font><font style="vertical-align: inherit;">このバージョンでは、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 48個の値</font><font style="vertical-align: inherit;">を破棄する代わりに</font><font style="vertical-align: inherit;">、（同等に）</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 48個の値を</font><font style="vertical-align: inherit;">破棄し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、C ++でのこのアプローチの実装です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">bounded_rand</span><span class="hljs-params">(<span class="hljs-keyword">rng_t</span>&amp; rng, <span class="hljs-keyword">uint32_t</span> range)</span> </span>{
    <span class="hljs-comment">// calculates 2**32 % range</span>
    <span class="hljs-keyword">uint32_t</span> t = (-range) % range;
    <span class="hljs-keyword">for</span> (;;) {
        <span class="hljs-keyword">uint32_t</span> r = rng();
        <span class="hljs-keyword">if</span> (r &gt;= t)
            <span class="hljs-keyword">return</span> r % range;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この手法はスキューを取り除きますが、各出力値の残りの部分で2つの時間のかかる除算演算が必要です（また、いくつかの数値を作成するために内部ジェネレーターが必要になる場合があります）。</font><font style="vertical-align: inherit;">したがって、この方法は従来のスキューアプローチよりも約2倍遅くなることが予想されます。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">OpenBSD</font></a><font style="vertical-align: inherit;">（また、OS XとIOSで使用されている）、この戦略を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><code> arc4random_uniform</code><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">残りの除算（単一）、スキューなし-Java方法論</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaは、結果を破棄する非常にまれなケースを除いて、1つの剰余除算演算のみを使用する間隔で数を生成するために別のアプローチを使用します。</font><font style="vertical-align: inherit;">コード：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> uint32_t <span class="hljs-title">bounded_rand</span><span class="hljs-params">(rng_t&amp; rng, uint32_t range)</span> </span>{<font></font>
    uint32_t x, r;<font></font>
    <span class="hljs-keyword">do</span> {<font></font>
        x = rng();<font></font>
        r = x % range;<font></font>
    } <span class="hljs-keyword">while</span> (x - r &gt; (-range));
    <span class="hljs-keyword">return</span> r;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このオプションが機能する理由を理解するには、少し考える必要があります。</font><font style="vertical-align: inherit;">内部生成エンジンから最低値の一部を削除することでバイアスを排除する、残差に基づく以前のバージョンとは異なり、このバージョンは、エンジン間隔の上部から値をフィルターで除外します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スキュー整数乗算-Lemiraメソッド</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除算の残りの部分からバイアスを取り除いたのとほぼ同じ方法で、整数乗算技法からバイアスを取り除くことができます。</font><font style="vertical-align: inherit;">この手法は、Lemyrによって発明されました。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">bounded_rand</span><span class="hljs-params">(<span class="hljs-keyword">rng_t</span>&amp; rng, <span class="hljs-keyword">uint32_t</span> range)</span> </span>{
    <span class="hljs-keyword">uint32_t</span> t = (-range) % range;
    <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">uint32_t</span> x = rng();
        <span class="hljs-keyword">uint64_t</span> m = <span class="hljs-keyword">uint64_t</span>(x) * <span class="hljs-keyword">uint64_t</span>(range);
        <span class="hljs-keyword">uint32_t</span> l = <span class="hljs-keyword">uint32_t</span>(m);<font></font>
    } <span class="hljs-keyword">while</span> (l &lt; t);
    <span class="hljs-keyword">return</span> m &gt;&gt; <span class="hljs-number">32</span>;<font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドロップビットマスク（スキューなし）-Appleテクニック</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後のアプローチでは、除算と残りの操作が完全に排除されます。</font><font style="vertical-align: inherit;">代わりに、単純なマスキング操作を使用して、間隔[0..2 </font></font><sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></em></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）で</font><font style="vertical-align: inherit;">乱数を取得します</font><font style="vertical-align: inherit;">。ここで、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は最小値であり、2 </font></font><sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kは</font></font></em></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">間隔より大きくなります。</font><font style="vertical-align: inherit;">値が間隔に対して大きすぎる場合は、その値を破棄して別の値を取得しようとします。</font><font style="vertical-align: inherit;">コードを以下に示します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">bounded_rand</span><span class="hljs-params">(<span class="hljs-keyword">rng_t</span>&amp; rng, <span class="hljs-keyword">uint32_t</span> range)</span> </span>{
    <span class="hljs-keyword">uint32_t</span> mask = ~<span class="hljs-keyword">uint32_t</span>(<span class="hljs-number">0</span>);<font></font>
    --range;<font></font>
    mask &gt;&gt;= __builtin_clz(range|<span class="hljs-number">1</span>);
    <span class="hljs-keyword">uint32_t</span> x;
    <span class="hljs-keyword">do</span> {<font></font>
        x = rng() &amp; mask;<font></font>
    } <span class="hljs-keyword">while</span> (x &gt; range);
    <span class="hljs-keyword">return</span> x;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは、（macOS Sierraリリースで）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独自の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">リビジョンを</font></a><font style="vertical-align: inherit;">実行したときにAppleによって採用されました</font></font><code>arc4random_uniform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本的な手法のベンチマーク</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、評価できるいくつかのアプローチがあります。</font><font style="vertical-align: inherit;">残念ながら、1つの除算操作のコストを懸念する場合、ベンチマークは重要なものになります。</font><font style="vertical-align: inherit;">アプリケーションの分野に影響を与えるすべての要因を考慮に入れることができるベンチマークはなく、アプリケーションに最適なオプションが確実に私のものに最適であるという保証はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つのベンチマークを使用して、さまざまなPRNGでテクニックをテストします。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベンチマークラージシャッフル</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく最も明白なベンチマークはミキシングです。このベンチマークでは、大規模な混合のシミュレーションを行います。サイズ</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列をソートするに</font><font style="vertical-align: inherit;">は、間隔[0 .. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、[0 ..（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -1））、...、[0..1）で</font><font style="vertical-align: inherit;">数値を生成する必要があり</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。このベンチマークでは、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が可能な最大数（</font></font><code>uint32_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この場合、2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -1）である</font><font style="vertical-align: inherit;">と想定し</font><font style="vertical-align: inherit;">ます。コード：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0xffffffff</span>; i &gt; <span class="hljs-number">0</span>; --i) {
    <span class="hljs-keyword">uint32_t</span> bval = bounded_rand(rng, i);<font></font>
    assert(bval &lt; i);<font></font>
    sum += bval;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それぞれの数値を「使用」して</font></font><code>sum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（最適化によって破棄されないように</font><font style="vertical-align: inherit;">）追加</font><font style="vertical-align: inherit;">しますが、数値の生成に焦点を合わせるための混合は行わないことに</font><font style="vertical-align: inherit;">注意してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
64ビットの生成を試験するため、我々は、同様のテストを持っているが、2のアレイ混合に対応する試験行うことは非現実的であろう</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 1 </font><font style="vertical-align: inherit;">大きさ</font><font style="vertical-align: inherit;">（それはこのより大きなベンチマークを完了するために何千年もかかりますので）。</font><font style="vertical-align: inherit;">代わりに、64ビット間隔全体を交差させますが、32ビットテストと同じ数の出力値を生成します。</font><font style="vertical-align: inherit;">コード：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0xffffffff</span>; i &gt; <span class="hljs-number">0</span>; --i) {
    <span class="hljs-keyword">uint64_t</span> bound = (<span class="hljs-keyword">uint64_t</span>(i)&lt;&lt;<span class="hljs-number">32</span>) | i;
    <span class="hljs-keyword">uint64_t</span> bval = bounded_rand(rng, bound );<font></font>
    assert(bval &lt; bound);<font></font>
    sum += bval;<font></font>
}</code></pre><br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メルセンヌ渦結果</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下に示す結果は、メルセンヌボルテックスを使用し、記事で検討されている32ビット（</font></font><code>std::mt19937</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from </font><font style="vertical-align: inherit;">を使用</font></font><code>libstdc++</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）および同様の64ビットコード（</font></font><code>std:mt19937_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from </font><font style="vertical-align: inherit;">を使用</font></font><code>libstdc++</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）で</font><font style="vertical-align: inherit;">テストしたときに調べた各メソッドに対するこのベンチマークのパフォーマンスを示しています</font><font style="vertical-align: inherit;">。結果は、シード値が異なる15回の実行の幾何平均であり、次に正規化されるため、古典的な除算剰余法は単一の実行時間を持ちます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9f/3eb/53f/b9f3eb53f894a14ac2698f44090b23a6.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パフォーマンスについて明確な答えがあるように思えるかもしれません。完璧を達成するための手法を構築し、開発者が</font></font><code>libstdc++</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32ビット数のこのようなひどい実装を書いたときに</font><font style="vertical-align: inherit;">何を考えてい</font><font style="vertical-align: inherit;">た</font><font style="vertical-align: inherit;">かを自問することができ</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">しかし、ベンチマークでよくあることですが、状況はこれらの結果よりも複雑です。</font><font style="vertical-align: inherit;">まず、結果がメルセンヌ渦に固有である可能性があるリスクがあるため、テストされた多くのPRNGを拡張します。</font><font style="vertical-align: inherit;">次に、ベンチマーク自体に微妙な問題がある可能性があります。</font><font style="vertical-align: inherit;">まず最初の質問について考えましょう。</font></font><br>
<br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまなPRNGの結果</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
32ビットのPRNGの我々の試験使用して</font></font><code>arc4_rand32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>chacha8r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>gjrand32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>jsf32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>mt19937</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>pcg32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>pcg32_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>sfc32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>splitmix32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>xoroshiro64+</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>xorshift*64/32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>xoshiro128+</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><code>xoshiro128**</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、64ビットのPRNGつつ-使用して</font></font><code>gjrand64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>jsf64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>mcg128</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>mcg128_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>mt19937_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>pcg64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>pcg64_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>sfc64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>splitmix64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>xoroshiro128+</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>xorshift*128/64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>xoshiro256+</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><code>xoshiro256*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これらのキットは、いくつかの遅いPRNと多くの非常に速いものを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果は次のとおりです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2dc/8c8/f1a/2dc8c8f1af9aa517a92260e7cbd3a73e.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メルセンヌ渦の結果との主な違いを確認できます。</font><font style="vertical-align: inherit;">より高速なPRSPは平衡を境界コードに向かってシフトするため、特に64ビットPRSPの場合、異なるアプローチ間の違いがより顕著になります。</font><font style="vertical-align: inherit;">幅広いPRNGセットにより、実装</font></font><code>libstc++</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はそれほどひどく</font><font style="vertical-align: inherit;">感じられなく</font><font style="vertical-align: inherit;">なりました。</font></font><br>
<br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このベンチマークでは、マージンがかなり大きいため、バイアスを使用した乗算に基づくアプローチが速度に勝っています。</font><font style="vertical-align: inherit;">PRNGのサイズに比べて境界が小さくなる状況は数多くあり、パフォーマンスは非常に重要です。</font><font style="vertical-align: inherit;">このような状況では、わずかなバイアスが顕著な影響を与えることはほとんどありませんが、PRNG速度は影響します。</font><font style="vertical-align: inherit;">そのような例の1つは、ランダムアンカーポイントを使用したクイックソートです。</font><font style="vertical-align: inherit;">歪んだ方法の中で、ビットマスク技術は有望に見えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、深刻な結論を下す前に、このベンチマークの大きな問題を指摘する必要があります。ほとんどの時間は、非常に高い境界に費やされます。</font><font style="vertical-align: inherit;">したがって、2番目のベンチマークに進む必要があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベンチマークスモールシャッフル</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このベンチマークは前のベンチマークに似ていますが、実行される「アレイミキシング」が非常に少なくなります（複数）。</font><font style="vertical-align: inherit;">コード：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">0xffff</span>; ++j) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0xffff</span>; i &gt; <span class="hljs-number">0</span>; --i) {
        <span class="hljs-keyword">uint32_t</span> bval = bounded_rand(rng, i);<font></font>
        assert(bval &lt; i);<font></font>
        sum += bval;<font></font>
    }<font></font>
}</code></pre><br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メルセンヌ渦結果</font></font></h5><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/d3b/4bd/6c5d3b4bdb5f2e45cd805a051d79ab9a.svg"></div><br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまなPRNGの結果</font></font></h5><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/9ae/8c0/45a9ae8c040cb4d297fe82f00fa06e3c.svg"></div><br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このベンチマークは、大きな境界を強調しすぎないようにし、実際の使用例をより正確に反映しますが、大きな境界は完全に破棄されます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての間隔のベンチマーク</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このベンチマークは、前の2つの欠点を回避することを目的としています。</font><font style="vertical-align: inherit;">彼は2の累乗の各サイズでテストを実行し、各サイズが存在するようにしますが、彼の影響は過大評価されていません。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> bit = <span class="hljs-number">1</span>; bit != <span class="hljs-number">0</span>; bit &lt;&lt;= <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0x1000000</span>; ++i) {
        <span class="hljs-keyword">uint32_t</span> bound = bit | (i &amp; (bit - <span class="hljs-number">1</span>));
        <span class="hljs-keyword">uint32_t</span> bval = bounded_rand(rng, bound);<font></font>
        assert(bval &lt; bound);<font></font>
        sum += bval;<font></font>
    }<font></font>
}</code></pre><br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メルセンヌ渦結果</font></font></h5><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f34/65c/447/f3465c447f9b19b430bb43533a655c2f.svg"></div><br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまなPRNGの結果</font></font></h5><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64b/c58/2a2/64bc582a2fde24fd0faedbeaabb9f64c.svg"></div><br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
調査結果の多くは変更されていません。</font><font style="vertical-align: inherit;">エラーに我慢できればスキュー法は速く、ビットマスク方式は平均化された良い選択のようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前に戻りたくない場合はこれを終了し、コードを批判的に調べて変更を加えることができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改善する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点まで、すべてのスキュー除去方法では、追加の除算剰余演算を使用する必要がありました。そのため、これらの方法は、スキュー方法よりもはるかに遅く実行されます。</font><font style="vertical-align: inherit;">この利点を減らすことができれば役に立ちます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">より速いしきい値ベースのドロップ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のアルゴリズムには、しきい値を使用するコードがあります。次に例を示します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">bounded_rand</span><span class="hljs-params">(<span class="hljs-keyword">rng_t</span>&amp; rng, <span class="hljs-keyword">uint32_t</span> range)</span> </span>{
    <span class="hljs-comment">// calculates 2**32 % range</span>
    <span class="hljs-keyword">uint32_t</span> t = (-range) % range;
    <span class="hljs-keyword">for</span> (;;) {
        <span class="hljs-keyword">uint32_t</span> r = rng();
        <span class="hljs-keyword">if</span> (r &gt;= t)
            <span class="hljs-keyword">return</span> r % range;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><code>range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PRNG出力間隔と比較して小さい</font><font style="vertical-align: inherit;">
場合</font><font style="vertical-align: inherit;">、ほとんどの場合、この数は</font><font style="vertical-align: inherit;">しきい値</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">よりはるかに大きくなり</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">つまり、しきい値の予備的な見積もりを追加できる場合、それはもう少し多いかもしれませんが、除算の残りを実行するという高価な操作を節約します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のコードはこのタスクを処理します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">bounded_rand</span><span class="hljs-params">(<span class="hljs-keyword">rng_t</span>&amp; rng, <span class="hljs-keyword">uint32_t</span> range)</span> </span>{
    <span class="hljs-keyword">uint32_t</span> r = rng();
    <span class="hljs-keyword">if</span> (r &lt; range) {
        <span class="hljs-keyword">uint32_t</span> t = (-range) % range;
        <span class="hljs-keyword">while</span> (r &lt; t)<font></font>
            r = rng();<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> r % range;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この変更は、「歪みのないdouble mod」（上記を参照）と「歪みのない整数乗算」の両方に適用できます。</font><font style="vertical-align: inherit;">アイデアは、2つ目の方法（ただし1つ目ではない）に適用したLemyrによって生まれました。</font></font><br>
<br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大規模なシャッフルベンチマーク結果</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この最適化により、64ビットベンチマーク（modはさらに遅い）の結果が大幅に改善されますが、実際には、32ビットベンチマークのパフォーマンスがわずかに低下します。</font><font style="vertical-align: inherit;">改善されたにもかかわらず、ビットマスク方式は依然として有効です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb4/61d/b52/bb461db52be4a7d983dd7f97844179c0.svg"></div><br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スモールシャッフルベンチマークの結果</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、この変更により、整数乗算の方法と除算の二重剰余の方法の両方で、小シャッフルのベンチマークが大幅に高速化されます。</font><font style="vertical-align: inherit;">どちらの場合も、それらのパフォーマンスは、歪みのないオプションの結果により近くシフトします。</font><font style="vertical-align: inherit;">二重剰余メソッド（OpenBSD）のパフォーマンスは、単一剰余メソッド（Java）のパフォーマンスとほぼ同じになりました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/2bd/fe2/f072bdfe2660cf0f8789b124a8f02646.svg"></div><br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての間隔のベンチマーク結果</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての間隔でベンチマークに同様の改善が見られます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/219/b1d/add/219b1daddfa6a55a2cb485b3ae774016.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しい普遍的な勝者を発表できるようです：歪めずにLemire整数を乗算するための最適化された方法。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除算剰余の最適化</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常</font></font><code>a % b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">計算に</font><font style="vertical-align: inherit;">は除算が必要ですが、</font></font><code>a &lt; b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果が単純</font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で除算が不要</font><font style="vertical-align: inherit;">な</font><font style="vertical-align: inherit;">状況では</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そして</font></font><code>a/2 &lt; b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、結果は単純</font></font><code>a - b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">したがって、計算する代わりに</font></font><br>
<br>
<pre><code class="cpp hljs">a %= b;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは満たすことができます</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span> (a &gt;= b) {<font></font>
    a -= b;<font></font>
    <span class="hljs-keyword">if</span> (a &gt;= b) <font></font>
        a %= b;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分割のコストは非常に大きいため、このより複雑なコードのコストを増やすと、分割がないために時間を節約でき、正当化できます。</font></font><br>
<br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大規模なシャッフルベンチマーク結果</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この最適化を追加すると、大規模なシャッフルベンチマーク結果が大幅に向上します。</font><font style="vertical-align: inherit;">これは64ビットのコードでより顕著になり、残りを取得する操作のコストが高くなります。</font><font style="vertical-align: inherit;">double-remainderメソッド（OpenBSDスタイル）は、1つの剰余演算のみと両方の最適化されたバージョンを示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/e1a/669/c56e1a669836477e46f870bd1bc7a6c9.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このベンチマークでは、ビットマスクが依然として優勢ですが、ビットマスクとLemiraのアプローチの境界は大幅に狭くなっています。</font></font><br>
<br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スモールシャッフルベンチマークの結果</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この最適化を追加しても、小規模シャッフルベンチマークのパフォーマンスは向上しません。そのため、かなりのコストがかかる場合にのみ問題が残ります。</font><font style="vertical-align: inherit;">場合によっては、ない場合もあれば、コストがわずかに増加する場合もあります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/4db/b65/6fa4dbb65b9a3f6c6f9e8ba4f7b455db.svg"></div><br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての間隔のベンチマーク結果</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての間隔のベンチマークでは、変化もわずかです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0e/ae7/758/e0eae77583cc457a9e923540ad954257.svg"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボーナス：PRSP比較結果</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
間隔で番号スキームをテストするために多くのPRNGを使用する主な理由は、個々のPRNGスキームの操作の特殊性による結果の不注意による歪みを回避するためでした。</font><font style="vertical-align: inherit;">しかし、内部テストの同じ結果を使用して、生成スキーム自体を比較できます。</font></font><br>
<br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32ビット出力のPRNG</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下のグラフは、32ビットメルセンヌボルテックスのパフォーマンスに正規化された、すべてのメソッドと15回の実行に対して平均化された、さまざまな32ビット生成スキームのパフォーマンスを示しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方で、私はそれ</font></font><code>pcg32_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が本当に速いことを知って</font><font style="vertical-align: inherit;">うれしい</font><font style="vertical-align: inherit;">です-それはXoroshiroの小さなバージョン（統計テストに合格しません）によってのみ打ち負かされました。</font><font style="vertical-align: inherit;">しかし、これはまた、現代の高性能汎用PRSPのパフォーマンスのためにめったに動揺しない理由を示しています-異なる方法の違いは非常に重要ではありません。</font><font style="vertical-align: inherit;">特に、最速の4つの回路のパフォーマンスの差は5％未満であり、これは単に「ノイズ」が原因であると思います。</font></font><br>
<br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64ビット出力のPRNG</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グラフは、すべての手法で平均化されたさまざまな64ビット生成スキームのパフォーマンスと、32ビットのメルセンヌボルテックスのパフォーマンスに正規化された15回の実行を示しています。 32ビットのメルセンヌボルテックスを使用して正規化が実行されるのは奇妙に思えるかもしれませんが、これにより、32ビットの生成で十分な場合に64ビットの生成を使用した場合の追加コストを確認できます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/928/16c/b24/92816cb249e7f76c4ed4e11c65f67475.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの結果は、それが</font></font><code>mcg128_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信じられないほど高速で</font><font style="vertical-align: inherit;">あることを確認しています</font><font style="vertical-align: inherit;">が、最後の4つのテクニックは約5％だけ異なるため、最速の方法から選択することは困難です。</font></font><code>pcg64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして</font></font><code>pcg64_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遅くでなければならない</font></font><code>mcg128_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本的な発電が合同ジェネレータ（LCG）と128ビットの乗法合同ジェネレータ（MCG、MCG）線形128ビットであるため、。</font><font style="vertical-align: inherit;">このセットの中で最速のテクニックではないという事実にもかかわらず、</font></font><code>pcg64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それは64ビットのメルセンヌ渦よりも20％高速です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、おそらくもっと重要なことに、これらの結果は、64ビット出力が必要ない場合、64ビットPRNGは通常32ビットよりも遅いことも示しています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ベンチマークから、標準的に使用されるPRNG（たとえば、32ビットメルセンヌボルテックス）からより高速なPRNPへの移行により、ベンチマークの実行時間が45％短縮されたことがわかります。</font><font style="vertical-align: inherit;">しかし、区間内の数値を検索する標準的な方法から最速の方法に移行することで、ベンチマーク時間を約66％短縮することができました。</font><font style="vertical-align: inherit;">つまり、元の時間の3分の1までです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最速の方法（歪みなし）は、Lemira法（追加の最適化あり）です。</font><font style="vertical-align: inherit;">そこで彼は：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">bounded_rand</span><span class="hljs-params">(<span class="hljs-keyword">rng_t</span>&amp; rng, <span class="hljs-keyword">uint32_t</span> range)</span> </span>{
    <span class="hljs-keyword">uint32_t</span> x = rng();
    <span class="hljs-keyword">uint64_t</span> m = <span class="hljs-keyword">uint64_t</span>(x) * <span class="hljs-keyword">uint64_t</span>(range);
    <span class="hljs-keyword">uint32_t</span> l = <span class="hljs-keyword">uint32_t</span>(m);
    <span class="hljs-keyword">if</span> (l &lt; range) {
        <span class="hljs-keyword">uint32_t</span> t = -range;
        <span class="hljs-keyword">if</span> (t &gt;= range) {<font></font>
            t -= range;<font></font>
            <span class="hljs-keyword">if</span> (t &gt;= range) <font></font>
                t %= range;<font></font>
        }<font></font>
        <span class="hljs-keyword">while</span> (l &lt; t) {<font></font>
            x = rng();<font></font>
            m = <span class="hljs-keyword">uint64_t</span>(x) * <span class="hljs-keyword">uint64_t</span>(range);<font></font>
            l = <span class="hljs-keyword">uint32_t</span>(m);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> m &gt;&gt; <span class="hljs-number">32</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lemiraメソッドを使用すると、ほとんどのランダム化アルゴリズムのパフォーマンスが、高速生成エンジンから高速アルゴリズムに移行するよりも向上します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">付録：テストノート</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのテストのコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHubに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投稿され</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ています</font></a><font style="vertical-align: inherit;">。合計で、</font></font><code>bounded_rand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つのコンパイラ（GCC 8とLLVM 6）で26の異なるPRN（13の32ビットPRNと13の64ビット）</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">するための23の方法をテストしました。</font><font style="vertical-align: inherit;">同じ15シードを使用して実行され、1196 * 15 = 17,940の一意のテスト実行が行われ、それぞれで3つのベンチマークが組み合わされます。基本的に、4つの2.1 GHz Xeon E7-4830v3プロセッサーを搭載した48コアマシンでテストを実行しました。完全なテストセットの実行には、1か月弱のプロセッサ時間がかかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に記事の紹介から戻ります。サーシャが使用</font></font><code>jsf32.STD-libc++</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">したと</font><font style="vertical-align: inherit;">想像してください</font><font style="vertical-align: inherit;">、そしてフアン-</font></font><code>mt19937.BIASED_FP_MULT_SCALE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ベンチマーク3では、後者の時間が69.6％短縮されます。</font><font style="vertical-align: inherit;">つまり、この架空の状況からの時間は、現実のデータに基づいています。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja455692/index.html">ASZP：改造または演劇はハンガーから始まります</a></li>
<li><a href="../ja455694/index.html">次世代の課金アーキテクチャ：Tarantoolへの移行</a></li>
<li><a href="../ja455696/index.html">未来の電子状態。パート2</a></li>
<li><a href="../ja455698/index.html">「JavaScriptのしくみ」という本</a></li>
<li><a href="../ja455700/index.html">フロントエンドの最適化に役立つ4つのトリック</a></li>
<li><a href="../ja455710/index.html">Leroy Merlinに200人のロシア人開発部門が必要な理由</a></li>
<li><a href="../ja455714/index.html">IFTTTとDjangoを使用してGoogleフォームをNotionに自動的にエクスポートする</a></li>
<li><a href="../ja455716/index.html">ビジネスインテリジェンスソフトウェアを展開するための15のベストプラクティス</a></li>
<li><a href="../ja455720/index.html">広告システムのUIを構築する方法</a></li>
<li><a href="../ja455722/index.html">Pythonは大量のメモリを消費しますか、それともオブジェクトのサイズを減らす方法は？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>