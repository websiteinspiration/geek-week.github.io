<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòæ ‚ú® ‚õπüèΩ Por qu√© las bases de datos NoSQL son una mala soluci√≥n para aplicaciones modernas ‚úã üë©üèº‚Äç‚öñÔ∏è üêò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr 
 
 Hoy traemos a su atenci√≥n una traducci√≥n de un art√≠culo del blog MemSQL, que originalmente es un anuncio (dedicado a las ventajas de Mem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Por qu√© las bases de datos NoSQL son una mala soluci√≥n para aplicaciones modernas</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/489660/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hola Habr </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hoy traemos a su atenci√≥n una traducci√≥n de un art√≠culo del blog MemSQL, que originalmente es un anuncio (dedicado a las ventajas de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MemSQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , actualizado a principios de enero de 2020). </font><font style="vertical-align: inherit;">Sin embargo, decidimos traducirlo de forma abreviada, ya que explica en detalle por qu√© a√∫n no hemos decidido publicar nada en MongoDB, Cassandra u otras bases de datos no relacionales. </font><font style="vertical-align: inherit;">Quiz√°s ten√≠amos raz√≥n, limit√°ndonos al exitoso libro " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MySQL al m√°ximo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ".</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ha llegado el momento de reconocer la verdad bien conocida: las bases de datos NoSQL no son adecuadas para resolver muchos problemas pr√°cticos que enfrentan las aplicaciones modernas, y el tiempo para estas bases de datos ha pasado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las bases de datos NoSQL aparecieron porque las bases de datos tradicionales que exist√≠an en el momento de su invenci√≥n no pod√≠an hacer frente a la escala de tareas requerida. Esta nueva generaci√≥n de servicios para trabajar con datos que aparecieron en circulaci√≥n hace m√°s de diez a√±os, permiti√≥ resolver muchos problemas relevantes en toda la Web, as√≠ como operar con conjuntos de datos en r√°pido crecimiento. NoSQL tambi√©n ofreci√≥ un nuevo m√©todo rentable de almacenamiento en fr√≠o / acceso por lotes epis√≥dico a vol√∫menes de datos de petabytes. Sin embargo, en los intentos apresurados de responder a los desaf√≠os de los grandes datos y apoyar a un gran n√∫mero de usuarios competidores, el paradigma NoSQL requiri√≥ abandonar algunas de las propiedades clave de las bases de datos tradicionales, lo que las hizo tan productivas y f√°ciles de usar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quiz√°s encontrar todas estas compensaciones con √©xito es la mayor contribuci√≥n de NoSQL al mundo de las bases de datos. Provocaron la evoluci√≥n al combinar las mejores caracter√≠sticas del manejo de big data con la estructura y flexibilidad de un modelo relacional probado y crear bases de datos relacionales escalables.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las bases de datos relacionales han evolucionado, dando lugar a una generaci√≥n completamente nueva de sistemas que pueden hacer frente a pr√°cticamente cualquier carga y satisfacer los requisitos de escalabilidad, confiabilidad y disponibilidad que se aplican a las aplicaciones modernas. Estamos hablando de diferentes cargas de trabajo, desde aplicaciones tradicionales, por ejemplo, aplicaciones transaccionales y an√°lisis de negocios, hasta otras m√°s innovadoras, como compartir software entre diferentes suscriptores (multi-tenance) y an√°lisis operativos. El surgimiento de nuevas bases de datos, en particular Google Spanner, Azure Data Warehouse y MemSQL, ha demostrado que en la mayor√≠a de los casos las bases de datos relacionales son m√°s f√°ciles de usar y, por regla general, muestran un mejor rendimiento que los sistemas NoSQL.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S√© que estos son temas controvertidos, y puede rechazar f√°cilmente mi punto de vista como parcial. </font><font style="vertical-align: inherit;">Sin embargo, perm√≠tame clasificar el componente de historia, arquitectura y aplicaci√≥n de estas bases de datos, y luego juzgar por usted mismo.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NoSQL Sunrise</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NoSQL se hizo propio a fines de la d√©cada de 2000, aunque su historia comenz√≥ mucho antes. </font><font style="vertical-align: inherit;">Su desarrollo se llev√≥ a cabo principalmente para resolver los problemas de escala inherentes a los sistemas de bases de datos existentes. </font><font style="vertical-align: inherit;">Era obvio que la escala horizontal era un modelo m√°s econ√≥mico al crear sistemas grandes. </font><font style="vertical-align: inherit;">Los sistemas m√°s grandes, como los motores de b√∫squeda y los servicios de correo electr√≥nico de Google, Facebook, Microsoft y Yahoo, solo pod√≠an escalar de esta manera. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Personalmente, apreci√© por primera vez el valor total de la escala horizontal cuando le√≠ el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">James Hamilton sobre el dise√±o y despliegue de servicios en Internet. Al principio, logr√© escalar el nivel de aplicaciones, ya que un sistema sin estado es m√°s f√°cil de escalar. El nivel de almacenamiento de datos es otra historia. Las bases de datos, por definici√≥n, funcionan con la preservaci√≥n del estado, y </font><font style="vertical-align: inherit;">es realmente dif√≠cil </font><font style="vertical-align: inherit;">dar garant√≠as (es decir, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ACID</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) sobre este estado en la escala de un sistema distribuido completo. Por lo tanto, se crearon nuevos niveles sobre los sistemas de bases de datos existentes (MySQL, SQL Server, etc.) para crear un nivel de almacenamiento de datos distribuidos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tuve que lidiar con algunas situaciones de este tipo cuando trabaj√© como gerente de producto en el equipo de SQL Server en Microsoft. El primer caso estaba relacionado con un producto interno de Microsoft; luego, la compa√±√≠a cre√≥ Webstore, una capa de fragmentaci√≥n construida en SQL Server y utilizada por Hotmail y sus servicios relacionados. De hecho, fue la tienda web la que sirvi√≥ de incentivo para crear el producto que sirvi√≥ como prototipo de la base de datos Azure SQL actual. La tienda web era un tanto torpe, carec√≠a de una parte importante de la funcionalidad clave, pero funcion√≥ y proporcion√≥ a Microsoft tanto escalamiento a la cantidad deseada de datos como alta disponibilidad. Pero para crear y seguir apoyando a la tienda web, se requer√≠a un equipo completo de ingenieros.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A mediados de la d√©cada de 2000, MySpace utiliz√≥ una gran cantidad de servidores SQL para administrar un sitio de r√°pido crecimiento. La audiencia de usuarios de la compa√±√≠a creci√≥ tan r√°pido que se necesita instalar diariamente nuevas instancias de servidores SQL. La explotaci√≥n de todos estos servidores SQL y la ejecuci√≥n de consultas en todos ellos result√≥ ser una cuesti√≥n de enorme complejidad que un ej√©rcito completo de ingenieros tambi√©n se involucr√≥ en ellos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se repitieron historias similares en Facebook y otras compa√±√≠as, ya que todos los gigantes de la tecnolog√≠a en r√°pido crecimiento se encontraron con el problema de la escala.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se hizo evidente que a tales tasas de crecimiento y explotaci√≥n, estos nuevos servicios digitales requieren una nueva soluci√≥n para la absorci√≥n de datos, la gesti√≥n y su salida a la superficie. Idealmente, se requer√≠a una soluci√≥n que pudiera proporcionar de forma nativa una interfaz √∫nica, pero escalar horizontalmente en muchas m√°quinas y al mismo tiempo tener herramientas integradas para garantizar una alta disponibilidad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, los servicios en la nube a gran escala (Google, Facebook, Yahoo, Microsoft y otros) construyeron sus propios sistemas especiales para satisfacer la necesidad de escalar. Estos sistemas eran diferentes, pero se establecieron ideas comunes en ellos. En la siguiente etapa, los sistemas de c√≥digo abierto que usaban las mismas ideas comenzaron a multiplicarse, por lo que surgi√≥ el movimiento NoSQL.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para resolver problemas a escala web, NoSQL se separ√≥ de las bases de datos tradicionales en varios indicadores clave. </font><font style="vertical-align: inherit;">Entonces, veamos por qu√© estas decisiones espec√≠ficas se tomaron aqu√≠.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendimiento y fallas conformacionales en √∫ltima instancia</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay dos enfoques arquitect√≥nicos, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ACID</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BASE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ACID significa "At√≥mico, Consistente, Aislamiento, Duradero" (At√≥mico, Consistente, Aislamiento, Durabilidad). Este paradigma cubre todas las garant√≠as que generalmente se brindan en bases de datos relacionales. ACID asegura que las operaciones de escritura tendr√°n que esperar hasta que los datos lleguen al disco, y solo despu√©s de eso, se informar√° al cliente que la operaci√≥n se complet√≥ con √©xito. Adem√°s, si realmente le preocupa la longevidad de los datos (es decir, intenta no perderlos), entonces configura la base de datos para que la operaci√≥n de escritura pueda seguir a trav√©s de la red a otra m√°quina, y los datos tambi√©n se escribir√°n en el disco y all√≠ . Por lo tanto, obtiene garant√≠as de que exactamente lo que anot√≥ siempre entra en los datos, sin embargo, en parte, sacrifica la velocidad de escritura.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La arquitectura BASE t√≠pica de los sistemas NoSQL significa "B√°sicamente disponible, estado suave, eventualmente coherente" ("disponibilidad b√°sica, estado inestable y, en √∫ltima instancia, coherencia"). La consistencia en √∫ltima instancia proporciona una velocidad de grabaci√≥n m√°s r√°pida porque la aplicaci√≥n no tiene que esperar la confirmaci√≥n de que la grabaci√≥n se ha guardado. Tan pronto como el almac√©n de datos haya aceptado la grabaci√≥n, pero incluso antes de que los datos se hayan almacenado permanentemente en su disco o en el disco de otra m√°quina, la base de datos puede informar a la aplicaci√≥n que la operaci√≥n de escritura fue exitosa, y la aplicaci√≥n puede continuar con la siguiente operaci√≥n. Por lo tanto, gana en rendimiento, sin embargo, corre el riesgo de no ver los datos que acaba de grabar, o los datos pueden perderse por completo debido a alg√∫n tipo de error.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La consistencia es, en √∫ltima instancia, un compromiso razonable que se puede alcanzar mientras se lucha por la longevidad y la disponibilidad de datos. Si su negocio involucra la participaci√≥n del consumidor, cualquier demora afecta directamente sus ganancias (y esto se aplica igualmente a cualquier contenido, comunidad y aplicaci√≥n comercial). Naturalmente, logra la mayor capacidad de respuesta posible de la interfaz de usuario. Si su tarea es escalar para servir a millones de usuarios que compiten con el sistema, entonces cualquier obst√°culo es inaceptable para usted. Cuando implementa la coherencia en la arquitectura de su base de datos, corre el riesgo de perder accidentalmente la publicaci√≥n o comentario de alguien, y este tipo de riesgo es aceptable en este tipo de aplicaci√≥n.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el otro extremo del espectro de oportunidades "longevidad versus riesgo" se encuentran las aplicaciones financieras. </font><font style="vertical-align: inherit;">Si realiza una transacci√≥n a trav√©s de un cajero autom√°tico, entonces, por supuesto, la consistencia finalmente no ser√° adecuada para usted. </font><font style="vertical-align: inherit;">Lo mismo se aplica al comercio en el intercambio. </font><font style="vertical-align: inherit;">En tales casos, todav√≠a habr√° usuarios que aceptar√°n solo retrasos m√≠nimos (o no estar√°n de acuerdo en absoluto), pero no est√°n listos para soportar el hecho de que la transacci√≥n no se escribir√° en el disco. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, tenemos d√≥nde aplicar la consistencia a largo plazo, pero, por supuesto, no es la √∫nica soluci√≥n. </font><font style="vertical-align: inherit;">Los arquitectos y los desarrolladores de sistemas de datos deben poder elegir qu√© nivel de consistencia necesitan. </font><font style="vertical-align: inherit;">Esta elecci√≥n deber√≠a depender de los detalles de uso y no de las capacidades de la plataforma.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tratando de sobrevivir sin un esquema</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No est√° del todo claro por qu√© en el movimiento NoSQL se decidi√≥ abandonar los esquemas. S√≠, en los albores de NoSQL, era dif√≠cil construir un administrador para administrar metadatos distribuidos, lo que proporcionar√≠a soporte para esquemas en todo el sistema distribuido y operaciones de soporte como agregar una columna. Por lo tanto, no es sorprendente que los esquemas desaparecieran en los primeros proyectos de tales bases de datos. Pero, en lugar de encontrar una manera de volver a agregar los esquemas posteriormente, se decidi√≥ abandonarlos por completo. El punto de vista de esos tipos que indican que si hay un esquema, la base de datos se vuelve menos flexible. Es dif√≠cil dise√±ar un buen esquema, para esto es necesario pensar cuidadosamente y de antemano todo. Cuando la situaci√≥n est√° cambiando r√°pidamente (como era entonces y ahora es as√≠), qui√©n quiere encerrarse en el esquema.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero esto es una falacia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, la falta de circuitos beneficia al ingeniero, cuya tarea es escribir datos en el sistema. Sin embargo, en este caso, los problemas se env√≠an a la parte de quienes leen los datos, y generalmente son un orden de magnitud mayor que los ingenieros, y a menudo no tienen informaci√≥n sobre el contexto en el que se encontraban los datos al momento de la grabaci√≥n. Son los usuarios quienes usualmente obtienen valor de los datos, y necesitan dejar la menor cantidad posible de obst√°culos para trabajar con la informaci√≥n.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√© una analog√≠a. Imagine que los bibliotecarios afirman que est√°n cansados ‚Äã‚Äãde trabajar con los cat√°logos decimales de Dewey, y ahora simplemente dejar√°n caer los libros en un gran agujero en el piso, porque el trabajo del bibliotecario se simplifica enormemente. A veces sucede que es apropiado usar datos parcialmente estructurados, porque a veces no imaginas la forma de algunos datos, o los datos en s√≠ mismos son demasiado escasos. Pero si realmente no comprende de d√≥nde vendr√°n estos o esos datos, o c√≥mo deber√≠a verse, ¬øde qu√© sirve?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La verdad es que siempre hay un circuito. Los datos siempre tienen alg√∫n significado para alguien. Pero alguien deber√≠a pasar tiempo e integrar su conocimiento de este significado en la plataforma para que otras personas puedan usar los datos despu√©s de ello. Si estamos tratando con datos, algunos de los cuales son comprensibles para nosotros, y la otra parte est√° cambiando r√°pidamente, entonces la segunda parte cae en una columna con informaci√≥n parcialmente estructurada, y luego decidimos qu√© columnas formaremos posteriormente a partir de esta informaci√≥n parcialmente estructurada. SQL Server y Oracle lograron hacer esto en XML hace 15 a√±os. En MemSQL y algunas otras bases de datos modernas de hoy, lo mismo se hace con datos JSON. El almacenamiento de datos de documentos (y el trabajo con pares clave-valor) deber√≠an ser caracter√≠sticas de las bases de datos modernas, pero no la √∫nica posibilidad de este o aquel producto.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La sintaxis de consulta no es como en SQL</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta decisi√≥n en el dise√±o de bases de datos NoSQL sigui√≥ al abandono del esquema. </font><font style="vertical-align: inherit;">Si no hay un esquema, entonces parece apropiado abandonar la sintaxis SQL. </font><font style="vertical-align: inherit;">Adem√°s, el procesador de consultas es dif√≠cil de escribir para una sola computadora, pero para un sistema distribuido es mucho m√°s complicado. </font><font style="vertical-align: inherit;">Lo m√°s notable es que si usted es un desarrollador que necesita lanzar r√°pidamente una nueva aplicaci√≥n, ese nuevo sistema parece m√°s f√°cil.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MongoDB ha perfeccionado el arte de una f√°cil instalaci√≥n y uso sin experiencia. Sin embargo, resulta que el modelo relacional es muy poderoso. Es bueno llevarse bien con las funciones get y put si nunca ha tenido que resolver problemas m√°s dif√≠ciles que "seleccionar un objeto con id 2". Pero la mayor√≠a de las aplicaciones existentes necesitan hacer mucho m√°s. Si desea leer un excelente art√≠culo del autor que lleg√≥ a esta conclusi√≥n (y al mismo tiempo no funciona en un producto para almacenar datos), resuelva dos proyectos separados usando MongoDB: lea </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Un gran ejemplo que muestra cu√°ndo las capacidades de la base de datos de documentos son limitadas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cualquier sistema, excepto el m√°s trivial, tarde o temprano deber√° solicitar datos con un principio diferente al que los guard√≥. Ir√≥nicamente, el modelo relacional se invent√≥ en la d√©cada de 1960 para resolver exactamente el mismo problema con los almacenes de datos que exist√≠an en ese momento (IMS y Codasyl). El modelo relacional que proporcionaba la capacidad de unirse parec√≠a la √∫nica forma sensata de extraer datos. S√≠, al principio es bastante dif√≠cil, pero mucho m√°s f√°cil que extraer todos los datos en su aplicaci√≥n y luego crear las asociaciones usted mismo. Vi a los clientes tratar de hacer esto una y otra vez usando bases de datos NoSQL, y esto siempre los llev√≥ a alg√∫n tipo de tonter√≠a.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muchos de estos sistemas NoSQL han logrado su objetivo principal. Proporcionaron una interfaz √∫nica para el almac√©n de datos, a trav√©s de la cual fue posible escalar a muchos sistemas, confiando en la alta disponibilidad incorporada. Sin embargo, aunque NoSQL siempre ha progresado, su implementaci√≥n se ha detenido constantemente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay varias razones diferentes. La raz√≥n clave es el rendimiento, en particular cuando se trata de realizar consultas anal√≠ticas de conformidad con un acuerdo de calidad de servicio. Otra raz√≥n es la capacidad de administraci√≥n, porque se sabe lo dif√≠cil que es administrar sistemas distribuidos. Sin embargo, nada ha impedido la adopci√≥n generalizada de NoSQL que la necesidad de volver a capacitar a las personas. Muchos especialistas estudiaron y formaron profesionalmente en el mundo de las bases de datos relacionales. NoSQL ha estado tratando de cambiar el mundo durante m√°s de una d√©cada, pero no ha logrado casi nada. Todas las empresas que trabajan con NoSQL, combinadas, ocupan solo un peque√±o porcentaje del mercado de bases de datos, cuyo volumen es de $ 50 mil millones.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si bien a los programadores de NoSQL les gust√≥ claramente, los especialistas en datos (DBA, arquitectos de datos, analistas) se mudaron de mala gana al mundo de NoSQL, porque parec√≠a que solo este paradigma podr√≠a resolver problemas reales con el escalado. </font><font style="vertical-align: inherit;">Sin embargo, esto significaba que tendr√≠an que volver a aprender a nuevas API, herramientas, desarrollar un nuevo ecosistema, descartando muchos a√±os dedicados a estudiar enfoques, patrones y recursos exitosos. </font><font style="vertical-align: inherit;">Quer√≠an hacer su trabajo de acuerdo con el modelo familiar, pero al mismo tiempo lograr la escalabilidad necesaria, sin abandonar la durabilidad, disponibilidad y confiabilidad del sistema.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adios NoSQL</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las bases de datos NoSQL surgieron para que los ingenieros pudieran hacer frente a los requisitos de escalabilidad que son relevantes en los tiempos modernos de las aplicaciones web y los servicios dise√±ados para diferentes suscriptores. Teniendo en cuenta lo dif√≠cil que fue resolver tales problemas, est√° claro que los primeros intentos de hacer frente a la escala en el nivel de almacenamiento de datos obligaron a los clientes a hacer compromisos dif√≠ciles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, las bases de datos relacionales han evolucionado. Hoy pueden hacer frente a casi cualquier carga de trabajo, cumpliendo todos los requisitos de escalabilidad, confiabilidad y disponibilidad que se presentan a las aplicaciones modernas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto implica, por ejemplo, cargas de trabajo tales como an√°lisis operativos. Como todas las empresas reconocen el valor de un enfoque basado en datos, se esfuerzan por proporcionar a sus empleados datos relevantes. Esto requiere una nueva generaci√≥n de sistemas anal√≠ticos que puedan escalar a cientos de consultas competitivas, emitir consultas r√°pidas sin agregaci√≥n previa y absorber datos al mismo ritmo que se generan. Adem√°s de todo esto, debe proporcionar datos a clientes y socios, y para ello debe seguir ciertos acuerdos sobre el nivel de calidad de servicio (SLA), garant√≠as de seguridad, rendimiento y capacidades de escalabilidad, que son dif√≠ciles para la mayor√≠a de los almacenes de datos modernos. Aqu√≠ hay un tipo de carga de trabajo que ninguna base de datos heredada heredada puede manejar.No hay sistemas NoSQL.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El modelo relacional ha resistido la prueba del tiempo y contin√∫a creciendo en innovaci√≥n, como SingleStore de MemSQL. Adem√°s, el viejo paradigma ha absorbido muchos tipos de datos nuevos (b√∫squeda, espacial, semiestructurada, etc.) y modelos coincidentes que permiten que todos estos tipos de datos coexistan en el mismo sistema. No hay obst√°culos insuperables para el modelo relacional y la sintaxis de las consultas SQL. Solo necesita una implementaci√≥n diferente del almac√©n de datos que le permita aprovechar al m√°ximo la arquitectura escalable verticalmente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las nuevas bases de datos, como MemSQL, demuestran que en la mayor√≠a de los casos pr√°cticos, las bases de datos relacionales son m√°s f√°ciles de usar y, en general, demuestran un mejor rendimiento que los sistemas NoSQL.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gracias NoSQL </font><font style="vertical-align: inherit;">Ha presionado la presi√≥n necesaria sobre la comunidad de desarrollo de bases de datos, lo que nos ha hecho dar una respuesta digna a los desaf√≠os del mundo de la nube. </font><font style="vertical-align: inherit;">Funcion√≥. </font><font style="vertical-align: inherit;">Las bases de datos relacionales comenzaron a evolucionar y comenzaron a cumplir con los requisitos modernos. </font><font style="vertical-align: inherit;">Gracias a ti.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es489640/index.html">Los cient√≠ficos del MIT lograron obtener electricidad del aire utilizando prote√≠nas bacterianas</a></li>
<li><a href="../es489642/index.html">Patentes divertidas de la industria automotriz</a></li>
<li><a href="../es489644/index.html">Part√≠culas blandas en WebGL y OpenGL ES</a></li>
<li><a href="../es489650/index.html">Automatizaci√≥n de un periodista. Parte 1: Tareas y Calendarios</a></li>
<li><a href="../es489652/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 403 (17-23 de febrero de 2020)</a></li>
<li><a href="../es489662/index.html">PHP Digest No. 174 (del 10 al 24 de febrero de 2020)</a></li>
<li><a href="../es489664/index.html">NPS, transportador, computaci√≥n autom√°tica y de nuevo ... corutinas</a></li>
<li><a href="../es489666/index.html">Sobrecarga en C ++. Parte II Sobrecarga del operador</a></li>
<li><a href="../es489668/index.html">L√≠mites de CPU y aceleraci√≥n agresiva en Kubernetes</a></li>
<li><a href="../es489672/index.html">Revivimos el hex√°podo. La segunda parte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>