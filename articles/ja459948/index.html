<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔖 👨‍✈️ 👩🏽‍🤝‍👨🏼 Horizo​​n Zero Dawnのように物理的に正しい体積雲を実装する ⚫️ 🥕 🐅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="以前は、ゲームの雲は常にカメラの方向に回転する通常の2Dスプライトで描画されていましたが、近年では、ビデオカードの新しいモデルを使用すると、パフォーマンスが著しく低下することなく、物理的に正しい雲を描画できます。ゲーム内の膨大な雲がスタジオゲリラゲームとゲームHorizo​​n Zero Dawnを...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Horizo​​n Zero Dawnのように物理的に正しい体積雲を実装する</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459948/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以前は、ゲームの雲は常にカメラの方向に回転する通常の2Dスプライトで描画されていましたが、近年では、ビデオカードの新しいモデルを使用すると、パフォーマンスが著しく低下することなく、物理的に正しい雲を描画できます。ゲーム内の膨大な雲がスタジオゲリラゲームとゲームHorizo​​n Zero Dawnをもたらしたと考えられています。もちろん、そのようなクラウドは以前にレンダリングできましたが、スタジオはソースリソースと使用されるアルゴリズムの業界標準のようなものを形成し、現在のところ、ボリュームクラウドの実装は何らかの形でこの標準に準拠しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v9/uq/em/v9uqemwtz5ty7x5uvpppsoonmdu.png"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラウドをレンダリングするプロセス全体は段階に非常によく分かれており、そのうちの1つでも不正確な実装は、エラーの場所と修正方法が明確にならないような結果につながる可能性があることに注意することが重要です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トーンマッピング、sRGB</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
照明を使用する前に、次の2つのことを行うことが重要です。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 画面に最終的な画像を表示する前に、少なくとも最も単純なトーンマッピングを適用します。</font></font><br>
<br>
<pre><code class="cpp hljs">tunedColor=color/(<span class="hljs-number">1</span>+color)</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
計算されたカラー値は1よりもはるかに大きくなるため、これは必要です。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描画して画面に表示する最後のフレームバッファーがsRGB形式であることを確認してください。</font><font style="vertical-align: inherit;">sRGBモードのアクティブ化に問題がある場合は、シェーダーで手動で変換を行うことができます。</font></font><br>
<br>
<pre><code class="cpp hljs">finalColor=<span class="hljs-built_in">pow</span>(color, vec3(<span class="hljs-number">1.0</span>/<span class="hljs-number">2.2</span>))</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この式はほとんどの場合に適していますが、モニターによっては100％ではありません。</font><font style="vertical-align: inherit;">sRGB変換は常に最後に行われることが重要です。</font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">照明モデル</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
密度の異なる部分的に透明な物質で満たされた空間を考えてみましょう。</font><font style="vertical-align: inherit;">光線がこのような物質を通過すると、吸収、散乱、増幅散乱、自己放射の4つの影響を受けます。</font><font style="vertical-align: inherit;">後者は、物質で発生する化学プロセスの場合に発生し、ここでは影響を受けません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
点Aから点Bまで物質を通過する光線があるとします。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/_1/1t/9w/_11t9wizftnmwilerlsi5fvcrm4.png"></div><br>
<b><font style="vertical-align: inherit;"></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
物質を通過する</font><b><font style="vertical-align: inherit;">吸収</font></b><font style="vertical-align: inherit;">光は、まさにこの物質によって吸収されます。</font><font style="vertical-align: inherit;">光の非吸収率は、次の式で求められます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/567/34c/ec6/56734cec6154e1fab8bb2d1538a8dffa.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/a3e/204/11f/a3e20411f145906908c5cd2b53a36dbe.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、吸収後のポイントに残っている光</font></font><img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">
-A </font><font style="vertical-align: inherit;">から</font></font><img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の距離にあるセグメントAB上の点</font></font><img src="https://habrastorage.org/getpro/habr/post_images/2a3/102/4ea/2a31024ea1803c34a47496e24a53a1ef.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">散乱</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物質の粒子の影響下にある光の一部が方向を変えます。</font><font style="vertical-align: inherit;">方向を変えていない光の割合は、次の式で求められます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04b/c17/2f5/04bc172f53fa572aebf0399275b5009f.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/5e3/0b7/bad/5e30b7badd64b9da62be750e48573c7d.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">点で散乱した後に方向を変更されていない光の割合です</font></font><img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
吸収と分散を組み合わせる必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d7/d5a/f1a/8d7d5af1a0506ee776c4c2f850e862a9.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能</font></font><img src="https://habrastorage.org/getpro/habr/post_images/33f/297/4e9/33f2974e9c84331f8b92d8b7ed5aca97.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は減衰または消滅と呼ばれます。そして、関数</font></font><img src="https://habrastorage.org/getpro/habr/post_images/eea/d4d/0d4/eead4d0d4f08873f9aa49b69a7c46fd8.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は伝達関数です。これは、点Aから点Bに渡すときにどのくらいの光跡を示し</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
として</font></font><img src="https://habrastorage.org/getpro/habr/post_images/610/ddb/ee8/610ddbee8d80f847b44fa75c9a136489.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">及び</font></font><img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><img src="https://habrastorage.org/getpro/habr/post_images/b76/ea9/fd5/b76ea9fd577eb1c2cee545caa4153bd3.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CはRGB各チャンネルごとに異なる値を有することができ、一定の定数であり、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/9ee/494/9d2/9ee4949d2897f56ac90e563db1eb96cd.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">点で培地の密度です</font></font><img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、タスクを複雑にします。光は点Aから点Bに移動し、移動中に消えます。点Xでは、光の一部がさまざまな方向に散乱します。方向の1つは点Oの観測者に対応します。次に、散乱光の一部が点Xから点Oに移動し、再び減衰します。私たちにとって興味深いAXOライトのパス。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zo/b_/tr/zob_troftvd8-ggp1ga7wesnrlk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AからXに移動するときの光の損失を知っています</font></font><img src="https://habrastorage.org/getpro/habr/post_images/25d/8c9/f76/25d8c9f76986f59eb045b801f19d4e0a.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。XからOへの光の損失を知っているのと同じ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/25b/3a9/8e3/25b3a98e370f0a95b734794b74bee57a.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です</font><font style="vertical-align: inherit;">-これ</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">しかし、観察者の方向に散乱される光の割合はどうですか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">散乱の強化</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
通常の散乱の場合、光強度が減少し、増幅散乱の場合、隣接する領域で発生した光の散乱により光強度が増加します。</font><font style="vertical-align: inherit;">隣接する領域からの光の総量は、次の式で求められます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e4/be1/bd9/7e4be1bd9a1d8f05b9d1d47e1bb27ecc.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで</font></font><img src="https://habrastorage.org/getpro/habr/post_images/e63/878/1e4/e638781e456c920d7864e85c8b14a746.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、球全体の積分を取ること、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/1ad/0bb/23e/1ad0bb23eb22871d78d2b5cc67d58292.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位相関数、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/da9/7bc/3c5/da97bc3c51ddad728182deecd39ba0d0.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方向からの光</font></font><img src="https://habrastorage.org/getpro/habr/post_images/9c6/a44/e8e/9c6a44e8ed4cb10046e00346c6b58b15.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての方向から光を計算することは非常に困難ですが、光の元の部分は元のABビームによって運ばれることがわかっています。</font><font style="vertical-align: inherit;">式は大幅に簡略化できます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef8/4aa/222/ef84aa22259c648ea9925502712250f6.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/2cb/bcb/347/2cbbcb347a44c276c1095ac5bb3f8242.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、は光ビームと観測者ビームの間の角度（つまり、角度AXO）で</font></font><img src="https://habrastorage.org/getpro/habr/post_images/309/1ee/38b/3091ee38b2de66a8aa89af86fe87eb65.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あり、光強度の初期値です。</font><font style="vertical-align: inherit;">上記のすべてを要約すると、次の式が得られます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/642/fb7/273/642fb727356c245fc6f053dbc9affde8.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/309/1ee/38b/3091ee38b2de66a8aa89af86fe87eb65.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入射光は、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/f7a/fbd/138/f7afbd138efabfc5bf5dad3e26e6c0fb.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">観察者に到達する光です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクをもう少し複雑にします。</font><font style="vertical-align: inherit;">光がディレクショナルライトによって放出されるとしましょう。</font><font style="vertical-align: inherit;">太陽：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/wz/r2/gg/wzr2ggl_1oshhmhn3kkqalhtkoo.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 すべては前のケースと同じですが、何度も起こります。</font><font style="vertical-align: inherit;">点A1からの光は点X1で点Oの観測者に向かって散乱され、点A2からの光は点X2で点Oの観測者に向かって散乱されます。</font><font style="vertical-align: inherit;">観察者に到達する光は合計に等しいことがわかります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/838/191/24f/83819124f0beb6bdd5adc3644a79653b.svg"></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、より正確な積分式：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/7b0/5d2/e017b05d2026f311f43bc53da48c130e.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここを理解することが重要です</font></font><img src="https://habrastorage.org/getpro/habr/post_images/e7b/3af/88e/e7b3af88eb6397d1f88774b011fe4cbb.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">セグメントは、長さがゼロの無数のセクションに分割されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少し単純化すると、大気を通過する太陽光線は散乱のみを受けます。</font></font><img src="https://habrastorage.org/getpro/habr/post_images/c79/ce0/055/c79ce005518e112e707da427d7231066.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/k0/mm/tz/k0mmtzjcir3wnqxbcjzsouln4yo.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、1種類の散乱ではなく、レイリー散乱とMi散乱の2つ全体です。</font><font style="vertical-align: inherit;">1つは空気分子が原因で、2つ目は水のエアロゾルが原因です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
点Aから点Bに移動する光線が通過する空気（またはエアロゾル）の総密度：</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0bc/d80/e5d/0bcd80e5d5b35e43fef8336e6c66cde0.svg"></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/14b/01a/bf0/14b01abf043545d56ac10d61e69792e8.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スケーリングの高さであり、hは現在の高さです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単な統合ソリューションは次のとおりです。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3f/b07/e75/d3fb07e750a91c2a253fdcf1de74de72.svg"></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、dhは、高さサンプルを取得する際のステップサイズです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、図を見て、「照明モデル」の前の部分で導出された式を使用します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gr/n0/fr/grn0fr0f-dly-jjpcjpg_pxof9a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブザーバーはOからO 'に見えます。</font><font style="vertical-align: inherit;">X1、X2、...、Xnの点に到達し、それらの中で散乱されて、オブザーバーに到達するすべての光を収集します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/c25/470/540c25470466173df2e5cf7880390ff9.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/c87/cb3/ca4/c87cb3ca4e0a0f0fc9d1a9d5c485c116.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">太陽から放出される光</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">強度は、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/6c3/b25/b5f/6c3b25b5f22b9a03c093ef2f25a06339.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ある点での高さ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/ee6/2f8/bed/ee62f8bed8d0d0e9b3d3cd2c81841ded.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">空の場合、関数にある定数Cは</font></font><img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と表され</font></font><img src="https://habrastorage.org/getpro/habr/post_images/cea/f36/742/ceaf36742def9a68dbd173a0ac9c9aeb.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
積分の解は次のようになります。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5be/44a/9fc/5be44a9fcdb92469fee29b924a957556.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この式は、レイリー散乱とミー散乱の両方に有効です。</font><font style="vertical-align: inherit;">その結果、各散乱のライト値は単純に合計されます：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34f/cb4/a91/34fcb4a9100e4b9c60a7c7eca2c489ec.svg"></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイリー散乱</font></font></b><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/71e/a55/e80/71ea55e8043a70776eb70f29eb84d877.svg"><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/679/03f/8e9/67903f8e987346a525fb22e02e718aad.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（各RGBチャネルの値を含む）</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4c9/02f/384/4c902f3848ae3cb24347ee0b367132d6.svg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nk/xs/8z/nkxs8zt8hyh909tjilktrkrrvri.png"></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mi散乱</font></font></b><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/72b/94b/cc1/72b94bcc19f99b0e164c6a48e4408b44.svg"><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c9a/52e/00c/c9a52e00c5e6169a8ad778f902e49595.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（すべてのRGBチャネルの値は同じです）</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/208/fcf/3bf/208fcf3bf216540af2bfa93a186a3a19.svg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/jv/sb/fujvsbtduq-il-1reylizx1kosa.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セグメントごと</font></font><img src="https://habrastorage.org/getpro/habr/post_images/2a1/abf/7c3/2a1abf7c35ec6c9a9d35514977d15981.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">およびセグメント</font><font style="vertical-align: inherit;">ごとのサンプル数は、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/392/559/f75/392559f75e1c271b8bbfbc6255e70d4d.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32以上で取得できます。</font><font style="vertical-align: inherit;">地球の半径の値は6371000 m、大気の厚さは100000 mです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これをどうするか：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画面の各ピクセルで、観察者の方向Vを計算します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブザーバーOの位置を{0、6371000、0}とします</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我々見つける</font></font><img src="https://habrastorage.org/getpro/habr/post_images/28d/cc9/fe7/28dcc9fe786e9216afc4ab3ae2196ebe.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線、点Oでの発信、およびVと球の方向の交点の結果は点{0,0,0}と半径6471000を中心として</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セグメントは</font></font><img src="https://habrastorage.org/getpro/habr/post_images/392/559/f75/392559f75e1c271b8bbfbc6255e70d4d.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、同じ長さの32セクションに分割されています</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セクションごとに、レイリー散乱とミー散乱を計算し、すべてを追加します。</font><font style="vertical-align: inherit;">さらに、計算のために、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/2a1/abf/7c3/2a1abf7c35ec6c9a9d35514977d15981.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セグメント</font></font><img src="https://habrastorage.org/getpro/habr/post_images/0e6/fb0/4e8/0e6fb04e8525f5a3448df984993ab3c4.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をそれぞれ32の等しいセクションに</font><font style="vertical-align: inherit;">分割する必要もあり</font><font style="vertical-align: inherit;">ます。</font></font><img src="https://habrastorage.org/getpro/habr/post_images/60e/970/a20/60e970a20b30f36e7c21fe71c3d4dadb.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数から読み取ることができ、その値はサイクルの各ステップで増加します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最終結果：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/no/gb/tl/nogbtlqbuzffixmq7xmt1w4j_ja.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラウドモデル</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3Dにはいくつかのタイプのノイズが必要です。</font><font style="vertical-align: inherit;">1つ目は、Perlinの潜在的なフラクタルブラウン運動（fBm）ノイズです</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。2Dスライスの結果：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ld/h6/v6/ldh6v6zglre4jhon_n8qu193o8k.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つ目は、ボロノイのクローキングfBmノイズです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2Dスライスの結果：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/aa/rc/s2/aarcs2hvles3h89jqfc1lfrufjk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VorleyのクローキングfBmノイズを取得するには、ボロノイクローキングfBmノイズを反転させる必要があります。</font><font style="vertical-align: inherit;">ただし、値の範囲をわずかに変更しました：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">fbmTiledWorley3</span><span class="hljs-params">(...)</span>
</span>{
    <span class="hljs-keyword">return</span> clamp((<span class="hljs-number">1.0</span>-fbmTiledVoronoi3(...))*<span class="hljs-number">1.5</span><span class="hljs-number">-0.25</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果はすぐに雲の構造に似ています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ha/pf/em/hapfemxrqrxuqfpckajp53j4zxc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
雲の場合、2つの特別なテクスチャを取得する必要があります。 1つ目は128x128x128のサイズで低周波ノイズの原因となり、2つ目は32x32x32のサイズで高周波ノイズの原因となります。各テクスチャは、R8形式のチャネルを1つだけ使用します。一部の例では、R8G8B8A8の4つのチャネルが最初のテクスチャに使用され、2番目のテクスチャにR8G8B8の3つのチャネルが使用され、シェーダーでチャネルが混合されます。ミキシングは事前に行うことができ、それによってキャッシュコヒーレンスのヒットが大きくなるため、ポイントはわかりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
混合のために、またいくつかの場所では、値をある範囲から別の範囲にスケーリングするremap（）関数が使用されます：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">remap</span><span class="hljs-params">(<span class="hljs-keyword">float</span> value, <span class="hljs-keyword">float</span> minValue, <span class="hljs-keyword">float</span> maxValue, <span class="hljs-keyword">float</span> newMinValue, <span class="hljs-keyword">float</span> newMaxValue)</span>
</span>{
    <span class="hljs-keyword">return</span> newMinValue+(value-minValue)/(maxValue-minValue)*(newMaxValue-newMinValue);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
低周波ノイズのあるテクスチャの準備を始めましょう：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rチャネル</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-fBm </font><font style="vertical-align: inherit;">パーリンノイズを分泌する</font><font style="vertical-align: inherit;">Gチャネル</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-fBmボレーノイズを分泌するAチャネル-fBmボレーノイズを小さいスケールで</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分泌するAチャネル-fBmボレーノイズをさらに小さいスケールで分泌する</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/_9/z-/ms_9z-hofvyvya5-zuh6vpi6da0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
混合はこのように行われます：</font></font><br>
<br>
<pre><code class="cpp hljs">finalValue=remap(noise.x, (noise.y * <span class="hljs-number">0.625</span> + noise.z*<span class="hljs-number">0.25</span> + noise.w * <span class="hljs-number">0.125</span>)<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2Dスライスの結果：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/64/qh/rl/64qhrl3wl2vrsbedao4fk9zr3xg.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、高周波ノイズのあるテクスチャを準備しています</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。Rチャネルは、fBm Vorleyの分泌ノイズであり、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gチャネルは、fBm Vorleyの分泌ノイズが小さいスケールです</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。Bチャネルは、fBm Vorleyの分泌ノイズで、さらに小さいスケールです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ox/m6/in/oxm6inosejxwrkx2kdz7zv17eea.png"></div><br>
<pre><code class="cpp hljs">finalValue=noise.x * <span class="hljs-number">0.625</span> + noise.y*<span class="hljs-number">0.25</span> + noise.z * <span class="hljs-number">0.125</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2Dスライスの結果：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/lg/mr/mc/lgmrmc2ohi3ayicwbji49fdhqb4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、空間の座標に応じて、雲の存在、密度、形状を決定する2Dテクスチャウェザーマップも必要です。</font><font style="vertical-align: inherit;">雲のカバーを微調整するためにアーティストによって描かれています。</font><font style="vertical-align: inherit;">ウェザーマップのカラーチャネルの解釈は異なる場合があります。私が貸したバージョンでは、次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/oi/m8/fuoim8wbtdzgqoc2lma8g6gb0ow.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rチャネル-低高度で雲を覆う</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gチャネル-高高度で雲を覆う</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bチャネル-最大雲高</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aチャネル-雲密度</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、座標に応じて雲の密度を返す関数を作成する準備ができました3D空間。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入り口には、空間のポイントがあり、座標はkmです</font></font><br>
<br>
<pre><code class="cpp hljs">vec3 position</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
風にオフセットをすぐに追加します</font></font><br>
<br>
<pre><code class="cpp hljs">position.xz+=vec2(<span class="hljs-number">0.2f</span>)*ufmParams.time;</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
天気図の値を取得する</font></font><br>
<br>
<pre><code class="cpp hljs">vec4 weather=textureLod(ufmWeatherMap, position.xz/<span class="hljs-number">4096.0f</span>, <span class="hljs-number">0</span>);</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 高さのパーセンテージを取得します（0から1まで）</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> height=cloudGetHeight(position);</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の雲の小さな丸みを追加します。 </font></font><pre><code class="cpp hljs"><span class="hljs-keyword">float</span> SRb=clamp(remap(height, <span class="hljs-number">0</span>, <span class="hljs-number">0.07</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ウェザーマップのBチャネルに従って、高さの増加に伴って密度を0に直線的に減少させます。 </font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> SRt=clamp(remap(height, weather.b*<span class="hljs-number">0.2</span>, weather.b, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 結果を組み合わせる：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> SA=SRb*SRt;</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一度、下の雲の丸みを追加します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> DRb=height*clamp(remap(height, <span class="hljs-number">0</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、雲の丸みを上に追加します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> DRt=height*clamp(remap(height, <span class="hljs-number">0.9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 結果を結合します。ここでは、天気図からの密度の影響と、GUIで設定された密度の影響を追加します。 </font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> DA=DRb*DRt*weather.a*<span class="hljs-number">2</span>*ufmProperties.density;</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テクスチャからの低周波ノイズと高周波ノイズを組み合わせる： </font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> SNsample=textureLod(ufmLowFreqNoiseTexture, position/<span class="hljs-number">48.0f</span>, <span class="hljs-number">0</span>).x*<span class="hljs-number">0.85f</span>+textureLod(ufmHighFreqNoiseTexture, position/<span class="hljs-number">4.8f</span>, <span class="hljs-number">0</span>).x*<span class="hljs-number">0.15f</span>; </code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が読んだすべてのドキュメントで、マージは別の方法で行われましたが、このオプションが好きでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カバレッジの量（雲が占める空の割合）を決定します。これはguiを介して設定され、ウェザーマップのR-、G-チャネルも使用されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> WMc=max(weather.r, clamp(ufmProperties.coverage<span class="hljs-number">-0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)*weather.g*<span class="hljs-number">2</span>);</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最終密度を計算します。 </font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> d=clamp(remap(SNsample*SA, <span class="hljs-number">1</span>-ufmProperties.coverage*WMc, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)*DA;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能全体：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">cloudSampleDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{<font></font>
	position.xz+=vec2(<span class="hljs-number">0.2f</span>)*ufmParams.time;<font></font>
<font></font>
	vec4 weather=textureLod(ufmWeatherMap, position.xz/<span class="hljs-number">4096.0f</span>+vec2(<span class="hljs-number">0.2</span>, <span class="hljs-number">0.1</span>), <span class="hljs-number">0</span>);
	<span class="hljs-keyword">float</span> height=cloudGetHeight(position);<font></font>
	<font></font>
	<span class="hljs-keyword">float</span> SRb=clamp(remap(height, <span class="hljs-number">0</span>, <span class="hljs-number">0.07</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
	<span class="hljs-keyword">float</span> SRt=clamp(remap(height, weather.b*<span class="hljs-number">0.2</span>, weather.b, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
	<span class="hljs-keyword">float</span> SA=SRb*SRt;<font></font>
	<font></font>
	<span class="hljs-keyword">float</span> DRb=height*clamp(remap(height, <span class="hljs-number">0</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
	<span class="hljs-keyword">float</span> DRt=height*clamp(remap(height, <span class="hljs-number">0.9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
	<span class="hljs-keyword">float</span> DA=DRb*DRt*weather.a*<span class="hljs-number">2</span>*ufmProperties.density;<font></font>
	<font></font>
	<span class="hljs-keyword">float</span> SNsample=textureLod(ufmLowFreqNoiseTexture, position/<span class="hljs-number">48.0f</span>, <span class="hljs-number">0</span>).x*<span class="hljs-number">0.85f</span>+textureLod(ufmHighFreqNoiseTexture, position/<span class="hljs-number">4.8f</span>, <span class="hljs-number">0</span>).x*<span class="hljs-number">0.15f</span>; <font></font>
	<font></font>
	<span class="hljs-keyword">float</span> WMc=max(weather.r, clamp(ufmProperties.coverage<span class="hljs-number">-0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)*weather.g*<span class="hljs-number">2</span>);
	<span class="hljs-keyword">float</span> d=clamp(remap(SNsample*SA, <span class="hljs-number">1</span>-ufmProperties.coverage*WMc, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)*DA;<font></font>
	<font></font>
	<span class="hljs-keyword">return</span> d;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラメータを設定するときに雲が従う法則を無視すると、非常に異常で美しい結果が得られるため、この関数が正確にどうあるべきかは未解決の問題です。</font><font style="vertical-align: inherit;">それはすべてアプリケーションに依存します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tf/nz/bz/tfnzbzvd2oucw2h_oed9pbm_8ku.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">統合</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
地球の大気は内部と外部の2つの層に分かれており、その間に雲を配置できます。</font><font style="vertical-align: inherit;">これらのレイヤーは、球によって表現できますが、平面によっても表現できます。</font><font style="vertical-align: inherit;">私は球に落ち着きました。</font><font style="vertical-align: inherit;">最初のレイヤーでは球の半径6415 km、2番目のレイヤーでは半径6435 kmを使用しました。</font><font style="vertical-align: inherit;">地球の半径は6400 kmに丸められました。</font><font style="vertical-align: inherit;">一部のパラメータは、大気の「曇った」部分の条件付きの厚さ（20 km）に依存します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/0z/ir/8r/0zir8r9qtvwlh9xk85i-hznhqa0.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
空とは異なり、雲は不透明であり、統合には色を取得するだけでなく、アルファチャネルの値も取得する必要があります。</font><font style="vertical-align: inherit;">まず、太陽からの光線が通過する雲の総密度を返す関数が必要です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/5k/ne/lj/5kneljw4unaofsxxgbq12ealebw.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰もこれに注意を向けませんが、実際にはビームの全経路を考慮する必要はまったくなく、最も極端なギャップのみが必要であることが示されています。</font><font style="vertical-align: inherit;">切り捨てられたセグメントの上の雲はまったく存在しないと想定しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/sr/ly/edsrlyis3-2or1nztj6q-osmats.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、パフォーマンスを低下させることなく実行できる密度サンプルの数は非常に限られています。</font><font style="vertical-align: inherit;">ゲリラゲームは6。さらに、プレゼンテーションの1つで、開発者はこれらのサンプルをコーン内に散らし、最後のサンプルは特別に他のサンプルから非常に離れて、できるだけ多くのスペースをカバーすると述べています。</font><font style="vertical-align: inherit;">結果として生じる不正確さとノイズは、隣接するサンプルのバックグラウンドに対して平滑化され、これは逆に、精度の向上につながります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/rr/df/5prrdfocofvzsjobvawnairijp0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結局、同じ線上にある4つのサンプルに落ち着きましたが、後者は6倍のステップで取得されます。</font><font style="vertical-align: inherit;">ステップサイズは20 km * 0.01、つまり200 mです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数は非常に単純です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">cloudSampleDirectDensity</span><span class="hljs-params">(vec3 position, vec3 sunDir)</span>
</span>{
	<span class="hljs-comment">//  </span>
	<span class="hljs-keyword">float</span> avrStep=(<span class="hljs-number">6435.0</span><span class="hljs-number">-6415.0</span>)*<span class="hljs-number">0.01</span>;
	<span class="hljs-keyword">float</span> sumDensity=<span class="hljs-number">0.0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<font></font>
	{<font></font>
		<span class="hljs-keyword">float</span> step=avrStep;
		<span class="hljs-comment">//      6</span>
		<span class="hljs-keyword">if</span>(i==<span class="hljs-number">3</span>)<font></font>
			step=step*<span class="hljs-number">6.0</span>;
		<span class="hljs-comment">// </span><font></font>
		position+=sunDir*step;<font></font>
		<span class="hljs-comment">//  ,  ,   </span>
                <span class="hljs-comment">// </span>
		<span class="hljs-keyword">float</span> density=cloudSampleDensity(position)*step;<font></font>
		sumDensity+=density;<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> sumDensity;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、より難しい部分に進むことができます。</font><font style="vertical-align: inherit;">地球表面の観測者を{0、6400,0}の地点で決定し、観測ビームと半径6415 kmの球体および中心{0,0,0}の交点を見つけます-始点Sを取得します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/25/je/zj/25jezjeea4j3bl51jneypfjetsi.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、関数の基本バージョンです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">vec4 <span class="hljs-title">mainMarching</span><span class="hljs-params">(vec3 viewDir, vec3 sunDir)</span>
</span>{<font></font>
	vec3 position;<font></font>
	crossRaySphereOutFar(vec3(<span class="hljs-number">0.0</span>, <span class="hljs-number">6400.0</span>, <span class="hljs-number">0.0</span>), viewDir, vec3(<span class="hljs-number">0.0</span>), <span class="hljs-number">6415.0</span>, position);<font></font>
	<font></font>
	<span class="hljs-keyword">float</span> avrStep=(<span class="hljs-number">6435.0</span><span class="hljs-number">-6415.0</span>)/<span class="hljs-number">64.0</span>;<font></font>
	<font></font>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">128</span>;i++)<font></font>
	{<font></font>
		position+=viewDir*step;<font></font>
		<span class="hljs-keyword">if</span>(length(position)&gt;<span class="hljs-number">6435.0</span>)
			<span class="hljs-keyword">break</span>;<font></font>
	}<font></font>
	<font></font>
	<span class="hljs-keyword">return</span> vec4(<span class="hljs-number">0.0</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ステップサイズは20 km / 64と定義されています。</font><font style="vertical-align: inherit;">観測者のビームが厳密に垂直方向の場合は、64個のサンプルを作成します。</font><font style="vertical-align: inherit;">ただし、この方向がより水平である場合、サンプルはわずかに大きくなるため、サイクルには64ステップではなく、128のマージンがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は、最終的な色は黒で、透明度は1であると想定しています。</font><font style="vertical-align: inherit;">各ステップで、色の値を増やし、透明度の値を減らします。</font><font style="vertical-align: inherit;">透明度が0に近い場合は、ループを事前終了できます。</font></font><br>
<br>
<pre><code class="cpp hljs">vec3 color=vec3(<span class="hljs-number">0.0</span>);
<span class="hljs-keyword">float</span> transmittance=<span class="hljs-number">1.0</span>;<font></font>
<font></font>
…<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-comment">//     </span>
<span class="hljs-keyword">float</span> density=cloudSampleDensity(position)*avrStep;
<span class="hljs-comment">//   ,  </span>
<span class="hljs-comment">//  </span>
<span class="hljs-keyword">float</span> sunDensity=cloudSampleDirectDensity(position, sunDir);<font></font>
<font></font>
<span class="hljs-comment">//     				</span>
<span class="hljs-keyword">float</span> m2=<span class="hljs-built_in">exp</span>(-ufmProperties.attenuation*sunDensity);
<span class="hljs-keyword">float</span> m3=ufmProperties.attenuation2*density;
<span class="hljs-keyword">float</span> light=ufmProperties.sunIntensity*m2*m3;<font></font>
<font></font>
<span class="hljs-comment">//      </span><font></font>
color+=sunColor*light*transmittance;<font></font>
transmittance*=<span class="hljs-built_in">exp</span>(-ufmProperties.attenuation*density);<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-keyword">return</span> vec4(color, <span class="hljs-number">1.0</span>-transmittance);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ufmProperties.attenuation-C inのようなものはありません</font></font><img src="https://habrastorage.org/getpro/habr/post_images/610/ddb/ee8/610ddbee8d80f847b44fa75c9a136489.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、ufmProperties.attenuation2-C in </font><font style="vertical-align: inherit;">はありません</font></font><img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ufmProperties.sunIntensity-太陽放射強度。</font><font style="vertical-align: inherit;">sunColor-太陽の色。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vc/ft/z9/vcftz9vsswkxpqoggirezpfpygm.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
欠陥はすぐに明らかになります-深刻な陰影。</font><font style="vertical-align: inherit;">しかし、今度は、太陽の近くに増幅された照明がないことを修正します。</font><font style="vertical-align: inherit;">これは、位相関数を追加しなかったために起こりました。</font><font style="vertical-align: inherit;">雲を通過する光の散乱を計算するために、ヘンジーグリーンスタインの位相関数が使用されます。これは、1941年に空間のガスクラスターにおける同様の計算のために開きました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b0/b2e/33f/4b0b2e33fbd07036b14317d40cb1eac0.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
余談はここで行う必要があります。</font><font style="vertical-align: inherit;">正規照明モデルによれば、位相関数は1でなければなりません。</font><font style="vertical-align: inherit;">ただし、実際には、得られた結果は誰にも当てはまりませんし、誰もが2つの位相関数を使用し、さらにそれらの値を特別な方法で組み合わせます。</font><font style="vertical-align: inherit;">2つのフェーズ関数にも焦点を当てましたが、それらの値を単純に合計します。</font><font style="vertical-align: inherit;">第1フェーズ関数はgが1に近く、太陽の近くで明るい照明を作成できます。</font><font style="vertical-align: inherit;">2番目の位相関数のgは0.5に近く、天球全体の照明を徐々に減少させることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更新されたコード：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// cos(theta)</span>
<span class="hljs-keyword">float</span> mu=max(<span class="hljs-number">0</span>, dot(viewDir, sunDir));<font></font>
				<font></font>
<span class="hljs-keyword">float</span> m11=ufmProperties.phaseInfluence*cloudPhaseFunction(mu, ufmProperties.eccentrisy);
<span class="hljs-keyword">float</span> m12=ufmProperties.phaseInfluence2*cloudPhaseFunction(mu, ufmProperties.eccentrisy2);
<span class="hljs-keyword">float</span> m2=<span class="hljs-built_in">exp</span>(-ufmProperties.attenuation*sunDensity);
<span class="hljs-keyword">float</span> m3=ufmProperties.attenuation2*density;
<span class="hljs-keyword">float</span> light=ufmProperties.sunIntensity*(m11+m12)*m2*m3;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ufmProperties.eccentrisy、ufmProperties.eccentrisy2はg値です</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ip/qr/fi/ipqrfivyafyxnmdswnn_nbpvfdk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、陰影を付けすぎて戦闘を開始できます。</font><font style="vertical-align: inherit;">周囲の雲や空の光を考慮に入れていなかったため、存在しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はこの問題を次のように解決しました：</font></font><br>
 <br>
<pre><code class="cpp hljs"><span class="hljs-keyword">return</span> vec4(color+ambientColor*ufmProperties.ambient, <span class="hljs-number">1.0</span>-transmittance);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ambientColorは観測ビームの方向の空の色であり、ufmProperties.ambientは調整パラメーターです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ct/8h/ji/ct8hjiyk7brz5pv8vuwjeji33bc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後の問題を解決するために残っています。</font><font style="vertical-align: inherit;">実際には、ビューを水平に保つほど、遠くのオブジェクトを見ることができない特定の霧や霞が見えます。</font><font style="vertical-align: inherit;">これもコードに反映する必要があります。</font><font style="vertical-align: inherit;">視線角と指数関数の通常の余弦をとった。</font><font style="vertical-align: inherit;">これに基づいて、特定のブレンド係数が計算され、結果の色と背景色の間の線形補間が可能になります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> blending=<span class="hljs-number">1.0</span>-<span class="hljs-built_in">exp</span>(-max(<span class="hljs-number">0.0</span>, dot(viewDir, vec3(<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">0.0</span>)))*ufmProperties.fog);<font></font>
blending=blending*blending*blending;<font></font>
<span class="hljs-keyword">return</span> vec4(mix(ambientColor, color+ambientColor*ufmProperties.ambient, blending), <span class="hljs-number">1.0</span>-transmittance);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ufmProperties.fog-手動構成用。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/02/td/9h/02td9ho6kelgum68wldvcf-zymu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
集計機能：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">vec4 <span class="hljs-title">mainMarching</span><span class="hljs-params">(vec3 viewDir, vec3 sunDir, vec3 sunColor, vec3 ambientColor)</span>
</span>{<font></font>
	vec3 position;<font></font>
	crossRaySphereOutFar(vec3(<span class="hljs-number">0.0</span>, <span class="hljs-number">6400.0</span>, <span class="hljs-number">0.0</span>), viewDir, vec3(<span class="hljs-number">0.0</span>), <span class="hljs-number">6415.0</span>, position);<font></font>
	<font></font>
	<span class="hljs-keyword">float</span> avrStep=(<span class="hljs-number">6435.0</span><span class="hljs-number">-6415.0</span>)/<span class="hljs-number">64.0</span>;<font></font>
	<font></font>
	vec3 color=vec3(<span class="hljs-number">0.0</span>);
	<span class="hljs-keyword">float</span> transmittance=<span class="hljs-number">1.0</span>;<font></font>
	<font></font>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">128</span>;i++)<font></font>
	{<font></font>
		<span class="hljs-keyword">float</span> density=cloudSampleDensity(position)*avrStep;
		<span class="hljs-keyword">if</span>(density&gt;<span class="hljs-number">0.0</span>)<font></font>
		{<font></font>
			<span class="hljs-keyword">float</span> sunDensity=cloudSampleDirectDensity(position, sunDir);
			<span class="hljs-keyword">float</span> mu=max(<span class="hljs-number">0.0</span>, dot(viewDir, sunDir));<font></font>
				<font></font>
			<span class="hljs-keyword">float</span> m11=ufmProperties.phaseInfluence*cloudPhaseFunction(mu, ufmProperties.eccentrisy);
			<span class="hljs-keyword">float</span> m12=ufmProperties.phaseInfluence2*cloudPhaseFunction(mu, ufmProperties.eccentrisy2);
			<span class="hljs-keyword">float</span> m2=<span class="hljs-built_in">exp</span>(-ufmProperties.attenuation*sunDensity);
			<span class="hljs-keyword">float</span> m3=ufmProperties.attenuation2*density;
			<span class="hljs-keyword">float</span> light=ufmProperties.sunIntensity*(m11+m12)*m2*m3;<font></font>
		<font></font>
			color+=sunColor*light*transmittance;<font></font>
			transmittance*=<span class="hljs-built_in">exp</span>(-ufmProperties.attenuation*density);<font></font>
		}<font></font>
		position+=viewDir*avrStep;<font></font>
<font></font>
		<span class="hljs-keyword">if</span>(transmittance&lt;<span class="hljs-number">0.05</span> || length(position)&gt;<span class="hljs-number">6435.0</span>)
			<span class="hljs-keyword">break</span>;<font></font>
	}<font></font>
	<font></font>
	<span class="hljs-keyword">float</span> blending=<span class="hljs-number">1.0</span>-<span class="hljs-built_in">exp</span>(-max(<span class="hljs-number">0.0</span>, dot(viewDir, vec3(<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">0.0</span>)))*ufmProperties.fog);<font></font>
	blending=blending*blending*blending;<font></font>
	<span class="hljs-keyword">return</span> vec4(mix(ambientColor, color+ambientColor*ufmProperties.ambient, blending), <span class="hljs-number">1.0</span>-transmittance);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デモビデオ：</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/uPxVgbwThmI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適化と可能な改善</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本的なレンダリングアルゴリズムを実装した後の次の問題は、動作が遅すぎることです。</font><font style="vertical-align: inherit;">私のバージョンは、radeon rx 480でフルhdで25 fpsを生成しました。問題を解決するための次の2つのアプローチは、ゲリラゲーム自体によって提案されました。</font><font style="vertical-align: inherit;">
画面</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は実際に見えるものを描画し</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます画面は16x16ピクセルのサイズのタイルに分割されています。</font><font style="vertical-align: inherit;">まず、通常の3D環境を描画します。</font><font style="vertical-align: inherit;">空のほとんどが山や大きな物体で覆われていることがわかります。</font><font style="vertical-align: inherit;">したがって、雲が何も遮られていないタイルでのみ計算を実行する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再投影</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カメラが静止している場合、雲は一般に更新できないことがわかります。ただし、カメラが移動した場合でも、画面全体を更新する必要があるわけではありません。すべてがすでに描かれているので、新しい座標に従って画像を並べ替えるだけです。現在のフレームと前のフレームの射影行列とビュー行列を介して、新しい座標で古い座標を見つけることを、射影と呼びます。したがって、カメラシフトの場合は、新しい座標に従って色を転送するだけです。これらの座標が画面外を示している場合、雲は正直に再描画する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分更新</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再投影のアイデアは好きではありません。カメラを鋭く回転させると、画面の3分の1で雲をレンダリングする必要が生じ、遅延が発生する可能性があるためです。ゲリラゲームでこれがどのように処理されたかはわかりませんが、少なくともHorizo​​n Zero Dawnでは、ジョイスティックを制御すると、カメラがスムーズに動き、急激なジャンプの問題はありません。そこで、実験として自分なりのアプローチを考えました。雲は5つの面で3次マップに描かれています。底は私たちに興味がありません。キュービックマップの側面は、画面の高さのtoに等しい解像度が低くなっています。キュービックマップの各面は、8x8のタイルに分割されています。各面の各フレームは、各タイルの64ピクセルの1つだけで更新されます。これにより、突然の変化の際に顕著なアーティファクトが発生しますが、雲は非常に静的であり、そのようなトリックは目に見えません。その結果、radeon rx 480は、火山ではフルHDで500 fps、openglでは330 fpsを生成します。 Radeon hd 5700シリーズは、openglでフルHDで109 fpsを生成します（vulkanはサポートしていません）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ミップレベルの使用</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ノイズのあるテクスチャにアクセスする場合、最初のサンプルでのみゼロミップレベルからデータを取得できます。その後、サンプルを遠くに作成するほど、高いミップレベルを取得できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高高度の雲</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
統合中にゲリラゲームの巻雲と巻積雲の存在をシミュレートするために、最新のサンプルは、先ほどお話しした3Dテクスチャではなく、特別な2Dテクスチャから作成されています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/f2/vj/udf2vjpfht0hhpbf9zptwfmadhg.jpeg"></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カールノイズカールノイズの</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
いくつかの追加のテクスチャを使用して、風が吹く雲の効果を作成します。</font><font style="vertical-align: inherit;">これらのテクスチャは、元の座標をオフセットするために必要です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/-n/qq/pg/-nqqpgmixyogyjxqrdyhm4oxlpc.png"></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">神の光線</font></font></b><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qd/wq/xv/qdwqxvzveiwuxgu2v84aw5fhjwo.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドラマに引っかかるような光線は後処理で実現されます。</font><font style="vertical-align: inherit;">まず、明るい照明が太陽の周りに描かれ、雲に遮られません。</font><font style="vertical-align: inherit;">次に、このバックライトを太陽から放射状にオフセットする必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ap/vj/-a/apvj-assr02-vaov3o1k5frfawk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、放射状平滑​​化を適用する必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/lg/1h/jdlg1hp7jajzhlbom4ocmn3vl70.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、もっと多くの改善と微妙な点がありますが、すべてをチェックしなかったため、自信を持って伝えることはできません。</font><font style="vertical-align: inherit;">ただし、自分自身に慣れることができます。</font><font style="vertical-align: inherit;">私が考える最も強力なのは、Frostbiteエンジンからのクラウドドキュメントです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">役立つリンク</font></font></h2><br>
<b> Guerrilla Games</b><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">d1z4o56rleaq4j.cloudfront.net/downloads/assets/Nubis-Authoring-Realtime-Volumetric-Cloudscapes-with-the-Decima-Engine-Final.pdf?mtime=20170807141817</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">killzone.dl.playstation.net/killzone/horizonzerodawn/presentations/Siggraph15_Schneider_Real-Time_Volumetric_Cloudscapes_of_Horizon_Zero_Dawn.pdf</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">www.youtube.com/watch?v=-d8qT5-1LOI</a><br>
<br>
<b>  GPU Pro 7</b><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">vk.com/doc179245989_437393482?hash=a9af5f665eda4edf58&amp;dl=806d4dbdac0f7a761c</a><br>
<br>
<b></b><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky</a><br>
<br>
<b> Frostbite</b><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">www.shadertoy.com/view/XlBSRz</a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja459924/index.html">Reactアプリケーションのテストの全サイクル。Auto.ruを報告する</a></li>
<li><a href="../ja459928/index.html">学生のモバイルアプリ開発への道のり</a></li>
<li><a href="../ja459930/index.html">Pythonインポートの自動化</a></li>
<li><a href="../ja459934/index.html">モバイル＃306開発者向けの興味深い資料のダイジェスト（7月8〜14日）</a></li>
<li><a href="../ja459936/index.html">Visual Studioを操作するための9つのトリック</a></li>
<li><a href="../ja459952/index.html">バックアップとストレージに関する少しの経験</a></li>
<li><a href="../ja459954/index.html">最大のIT企業の1つがCNCFに参加した理由-クラウドインフラストラクチャを開発するファンド</a></li>
<li><a href="../ja459956/index.html">歯科医への早すぎる訪問の結果としての、完全な歯のない状態での埋め込み</a></li>
<li><a href="../ja459958/index.html">Hydra会議からのタスクの解析-ロードバランシングとメモリ内ストレージ</a></li>
<li><a href="../ja459960/index.html">アイデアからリリースまで。詳細な市場フロントエンドエクスペリエンス</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>