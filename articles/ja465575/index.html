<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⭐️ 🎽 🥐 C ++ 20での比較演算 👨🏿‍🤝‍👨🏻 🍝 👨🏼‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ケルンでの会議は通過し、C ++ 20標準は多かれ少なかれ完成した見た目になりました（少なくとも特別なメモが現れるまで）、そして今後の革新の1つについてお話ししたいと思います。これは通常演算子<=>と呼ばれるメカニズムです（標準ではこれを「3者間比較演算子」と定義していますが、非公式のニックネームは...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C ++ 20での比較演算</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/465575/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ケルンでの会議は通過し、C ++ 20標準は多かれ少なかれ完成した見た目になりました（少なくとも特別なメモが現れるまで）、そして今後の革新の1つについてお話ししたいと思います。</font><font style="vertical-align: inherit;">これは通常</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子&lt;=&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれるメカニズムです</font><font style="vertical-align: inherit;">（標準ではこれを「3者間比較演算子」と定義していますが、非公式のニックネームは「宇宙船」です）、その範囲ははるかに広いと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しい演算子だけではなく、比較のセマンティクスが言語自体のレベルで大幅に変更されます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事から他に何も得られない場合でも、次の表を覚えておいてください。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平等</font></font></b><br>
</td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合理化</font></font></b><br>
</td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベーシック</font></font></b><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">==</font></font></i><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;=&gt;</font></font></i><br>
</td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デリバティブ</font></font></b><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！=</font></font></i><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;=</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; =</font></font></i><br>
</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで新しい演算子</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;=&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ができましたが、さらに重要なことは、演算子が体系化されていることです。基本的な演算子と派生的な演算子があります-各グループには独自の機能があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はじめにこれらの機能について簡単に説明し、次のセクションでさらに詳しく説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本的な演算子は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逆に</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">することができます</font><font style="vertical-align: inherit;">（つまり、パラメーターの逆の順序で書き換えられます）。派生ステートメントは</font><font style="vertical-align: inherit;">、対応する基本ステートメントを使用して</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">書き換える</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことができます</font><font style="vertical-align: inherit;">。変換された候補も書き換えられた候補も新しい関数を生成することはありません。これらは単にソースコードレベルでの置き換えであり、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拡張された候補のセット</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から選択され</font><font style="vertical-align: inherit;">ます。たとえば、式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a &lt;9</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今では次のように計算することができる</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A.OPERATOR &lt;=&gt;（9）&lt;0 </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">及び式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 = B！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -様</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！演算子==（B、10） </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">つまり、同じ動作を実現するために、2つ、4つ、6つ、さらには12の演算子を手動で記述する必要がある1つまたは2つの演算子を使用することが可能になります。</font><font style="vertical-align: inherit;">ルールの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単な</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要を、考えられるすべての変換の表とともに以下に示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本演算子と微分演算子の両方を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトの</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子として定義でき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><b><font style="vertical-align: inherit;">ます</font></b></a><font style="vertical-align: inherit;">。基本的な演算子の場合、これは、演算子が宣言順に各メンバーに適用されることを意味します。派生演算子の場合、書き換えられた候補が使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ある種類の演算子（つまり、等式または順序付け）が別の種類の演算子を介して表現できるような変換は存在しないことに注意してください。つまり、テーブルの列は互いに依存しているわけではありません。式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a == b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><i><font style="vertical-align: inherit;">演算子&lt;=&gt; </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（a、b）== 0として</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暗黙的に</font><font style="vertical-align: inherit;">評価されることは決してありません</font><font style="vertical-align: inherit;">（ただし、</font><font style="vertical-align: inherit;">必要に応じ</font><font style="vertical-align: inherit;">て</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子&lt;=&gt;で</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定義することを妨げるものはあり</font><font style="vertical-align: inherit;">ません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しい機能を適用する前後のコードがどのように見えるかを示す小さな例を考えてみましょう。大文字と小文字を区別しない文字列型である</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CIStringを記述します</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。そのオブジェクトは、相互に比較したり、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char const *</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と比較したりできます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 17では、このタスクでは18の比較関数を作成する必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CIString</span> {</span>
  <span class="hljs-built_in">string</span> s;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> CIString&amp; a, <span class="hljs-keyword">const</span> CIString&amp; b) {
    <span class="hljs-keyword">return</span> a.s.size() == b.s.size() &amp;&amp;<font></font>
      ci_compare(a.s.c_str(), b.s.c_str()) == <span class="hljs-number">0</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> CIString&amp; a, <span class="hljs-keyword">const</span> CIString&amp; b) {
    <span class="hljs-keyword">return</span> ci_compare(a.s.c_str(), b.s.c_str()) &lt;  <span class="hljs-number">0</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> CIString&amp; a, <span class="hljs-keyword">const</span> CIString&amp; b) {
    <span class="hljs-keyword">return</span> !(a == b);<font></font>
  }<font></font>
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt; (<span class="hljs-keyword">const</span> CIString&amp; a, <span class="hljs-keyword">const</span> CIString&amp; b) {
    <span class="hljs-keyword">return</span> b &lt; a;<font></font>
  }<font></font>
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-keyword">const</span> CIString&amp; a, <span class="hljs-keyword">const</span> CIString&amp; b) {
    <span class="hljs-keyword">return</span> !(a &lt; b);<font></font>
  }<font></font>
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-keyword">const</span> CIString&amp; a, <span class="hljs-keyword">const</span> CIString&amp; b) {
    <span class="hljs-keyword">return</span> !(b &lt; a);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> CIString&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b) {
    <span class="hljs-keyword">return</span> ci_compare(a.s.c_str(), b) == <span class="hljs-number">0</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> CIString&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b) {
    <span class="hljs-keyword">return</span> ci_compare(a.s.c_str(), b) &lt;  <span class="hljs-number">0</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> CIString&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b) {
    <span class="hljs-keyword">return</span> !(a == b);<font></font>
  }<font></font>
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt; (<span class="hljs-keyword">const</span> CIString&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b) {
    <span class="hljs-keyword">return</span> b &lt; a;<font></font>
  }<font></font>
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-keyword">const</span> CIString&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b) {
    <span class="hljs-keyword">return</span> !(a &lt; b);<font></font>
  }<font></font>
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-keyword">const</span> CIString&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b) {
    <span class="hljs-keyword">return</span> !(b &lt; a);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* a, <span class="hljs-keyword">const</span> CIString&amp; b) {
    <span class="hljs-keyword">return</span> ci_compare(a, b.s.c_str()) == <span class="hljs-number">0</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* a, <span class="hljs-keyword">const</span> CIString&amp; b) {
    <span class="hljs-keyword">return</span> ci_compare(a, b.s.c_str()) &lt;  <span class="hljs-number">0</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* a, <span class="hljs-keyword">const</span> CIString&amp; b) {
    <span class="hljs-keyword">return</span> !(a == b);<font></font>
  }<font></font>
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt; (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* a, <span class="hljs-keyword">const</span> CIString&amp; b) {
    <span class="hljs-keyword">return</span> b &lt; a;<font></font>
  }<font></font>
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* a, <span class="hljs-keyword">const</span> CIString&amp; b) {
    <span class="hljs-keyword">return</span> !(a &lt; b);<font></font>
  }<font></font>
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* a, <span class="hljs-keyword">const</span> CIString&amp; b) {
    <span class="hljs-keyword">return</span> !(b &lt; a);<font></font>
  }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 20では、4つの関数しか実行できません。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CIString</span> {</span>
  <span class="hljs-built_in">string</span> s;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> CIString&amp; b) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> s.size() == b.s.size() &amp;&amp;<font></font>
      ci_compare(s.c_str(), b.s.c_str()) == <span class="hljs-number">0</span>;<font></font>
  }<font></font>
  <span class="hljs-built_in">std</span>::weak_ordering <span class="hljs-keyword">operator</span>&lt;=&gt;(<span class="hljs-keyword">const</span> CIString&amp; b) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> ci_compare(s.c_str(), b.s.c_str()) &lt;=&gt; <span class="hljs-number">0</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span>* b) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> ci_compare(s.c_str(), b) == <span class="hljs-number">0</span>;<font></font>
  }<font></font>
  <span class="hljs-built_in">std</span>::weak_ordering <span class="hljs-keyword">operator</span>&lt;=&gt;(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> ci_compare(s.c_str(), b) &lt;=&gt; <span class="hljs-number">0</span>;<font></font>
  }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それが何を意味するかを詳しく説明しますが、最初に少し戻って、比較がC ++ 20標準までどのように機能したかを思い出しましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 98からC ++ 17への標準の比較</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語の作成以来、比較演算はほとんど変わっていません。 6つの演算子</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！=</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;=</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; =がありました</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。標準では、組み込み型に対してそれらをそれぞれ定義していますが、一般的には同じ規則に従います。任意の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a @ b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">式</font><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は6つの比較演算子の1つ）を</font><font style="vertical-align: inherit;">評価するとき</font><font style="vertical-align: inherit;">、コンパイラーは、メンバー関数、フリー関数、および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子@</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">という名前の組み込み候補を探し</font><font style="vertical-align: inherit;">ます。これらは、指定された順序</font><font style="vertical-align: inherit;">でタイプ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">呼び出すことができます</font><font style="vertical-align: inherit;">。それらの中から最適な候補者を選びます。それで全部です。基本的に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべて</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子は同じように機能しました。操作</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;&lt;と変わり</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ませんでした</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような単純なルールのセットは簡単に習得できます。すべての演算子は完全に独立しており、同等です。操作</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！=の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">間の基本的な関係について私たち人間が知っていることは問題ではありません</font><font style="vertical-align: inherit;">。言語に関しては、これはまったく同じです。イディオムを使用します。たとえば、演算子</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！=</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Through Through </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を定義します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(A <span class="hljs-keyword">const</span>&amp;, A <span class="hljs-keyword">const</span>&amp;);<font></font>
<font></font>
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(A <span class="hljs-keyword">const</span>&amp; lhs, A <span class="hljs-keyword">const</span>&amp; rhs) {
  <span class="hljs-keyword">return</span> !(lhs == rhs);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、演算子</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して、他のすべての関係演算子を定義します。言語の規則にも関わらず、実際には6つの演算子すべてが同等であるとは考えていないため、これらのイディオムを使用しています。それらのうちの2つが基本（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）であり、それらを通じて他のすべてがすでに表現され</font><font style="vertical-align: inherit;">ていることを受け入れ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、標準テンプレートライブラリは完全にこれら2つの演算子に基づいて構築されており、悪用されたコードの膨大な数の型には、一方または両方の定義が含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子は</font><font style="vertical-align: inherit;">、2つの理由から、基本ロールにはあま​​り適していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、他の関係演算子はそれを介して表現することを保証できません。はい、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a&gt; b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b &lt; </font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とまったく同じことを意味し</font><font style="vertical-align: inherit;">ますが</font><i><font style="vertical-align: inherit;">、a &lt;= bが</font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！（b &lt;a）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とまったく同じことを意味する</font><font style="vertical-align: inherit;">とは限りません</font><font style="vertical-align: inherit;">。トリコトミーのプロパティがある場合、最後の2つの式は同等になります。この場合、2つの値について、3つのステートメントのうち1つだけがtrueになります：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a &lt;b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a == b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a&gt; b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。三分法が存在する場合、式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a &lt;= b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、最初のケースまたは2番目のケースのいずれかを処理することを意味します。これは、3番目のケースを処理しないというステートメントと同等です。したがって、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（a &lt;= b）==！（A&gt; b）==！（B &lt;a）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、態度が三分法の特性を持たない場合はどうなりますか？これは半順序関係の特徴です。古典的な例では、操作の対象の任意の点の数フローティングさ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.F &lt;はNaNを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.F ==のNaN</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.F&gt; NaNが</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">得られる</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">偽</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。したがって、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.f &lt;= NaN</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">嘘をつきます</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、同時に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！（NaN &lt;1.f）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><i><font style="vertical-align: inherit;">&lt;=</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
演算子</font><font style="vertical-align: inherit;">を基本演算子を通じて一般的な用語で</font><font style="vertical-align: inherit;">実装する唯一の方法</font><font style="vertical-align: inherit;">は、両方の演算を</font><i><font style="vertical-align: inherit;">（a == b）||</font></i><font style="vertical-align: inherit;">として描画することです。</font><i><font style="vertical-align: inherit;">（a &lt;b）</font></i><font style="vertical-align: inherit;">、これは私たちが</font><i><font style="vertical-align: inherit;">まだ</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形順序を処理する必要があります。1つの関数が呼び出されるのではなく、2つが呼び出されるためです（たとえば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「abc..xyz9」&lt;=「abc..xyz1」</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">という式</font><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（「abc..xyz9」==「abc。 .xyz1 "）||（" abc..xyz9 "&lt;" abc..xyz1 "）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と行全体を2回比較します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第2に、演算子</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;は</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">辞書式比較での使用の特殊性のため、基本</font><font style="vertical-align: inherit;">演算子</font><font style="vertical-align: inherit;">の役割にはあまり適していません。プログラマーはしばしばこの間違いを犯します：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> {</span><font></font>
  T t;<font></font>
  U u;<font></font>
  <font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(A <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> t == rhs.t &amp;&amp;<font></font>
      u == rhs.u;<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (A <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> t &lt; rhs.t &amp;&amp;<font></font>
      u &lt; rhs.u;<font></font>
  }  <font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要素のコレクションに==演算子を定義するには、</font><font style="vertical-align: inherit;">各メンバーに</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を1 </font><font style="vertical-align: inherit;">回適用するだけで十分です</font><font style="vertical-align: inherit;">が、</font><font style="vertical-align: inherit;">これは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子で</font><font style="vertical-align: inherit;">は機能</font><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">ません。この実装の観点からは、セット</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A {1、2}</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A {2、1}</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は同等であると見なされます（それらのどれも他のものよりも小さいわけではないため）。これを修正するに</font><font style="vertical-align: inherit;">は、最後のメンバーを除く各メンバーに</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子を</font><font style="vertical-align: inherit;">2回</font><font style="vertical-align: inherit;">適用します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (A <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">if</span> (t &lt; rhs.t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">if</span> (rhs.t &lt; t) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">return</span> u &lt; rhs.u;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、異種オブジェクトの比較の正しい操作を保証するために-つまり式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a == 10</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 == a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が同じことを意味</font><font style="vertical-align: inherit;">することを確認するために</font><font style="vertical-align: inherit;">-彼らは通常、自由関数として比較を書くことを勧めます。実際、これは通常、このような比較を実装する唯一の方法です。これは、最初にこの推奨事項への準拠を監視する必要があり、2番目に、より便利な実装（つまり、クラス本体内）のために、通常はこのような関数を非表示のフレンドとして宣言する必要があるため、不便です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
異なるタイプのオブジェクトを比較する場合、必ずしも</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operator ==（X、int）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と書く必要はありません</font><font style="vertical-align: inherit;">。また、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に対して暗黙的に呼び出される</font><font style="vertical-align: inherit;">場合もあり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
規則をC ++ 20標準に要約します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのステートメントは同じ方法で処理されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装を容易にするためにイディオムを使用しています。</font><font style="vertical-align: inherit;">演算子</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、基本的なイディオムを表し、残りの関係演算子をそれらを介して表現します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それは単なる演算子です</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベースの役割にはあまり適していません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なるタイプのオブジェクトの比較をフリー関数として記述することが重要です（推奨されています）。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい基本的な順序付け演算子：&lt;=&gt;</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 20での比較作業における最も重要で目立つ変更は、</font><font style="vertical-align: inherit;">3者間比較演算子</font><font style="vertical-align: inherit;">である新しい演算子- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子&lt;=&gt;の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加です</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは、機能によって、すでに3ウェイの比較に精通している</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数strcmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cでと</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）のbasic_string ::比較を（</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C ++で。これらはすべて</font><font style="vertical-align: inherit;">、最初の引数が2番目の引数より大きい場合は任意の正の数、</font><font style="vertical-align: inherit;">等しい場合</font><font style="vertical-align: inherit;">は</font><i><font style="vertical-align: inherit;">0</font></i><font style="vertical-align: inherit;">、それ以外の場合は任意の負の数で</font><font style="vertical-align: inherit;">表される</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値を返し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">
宇宙船演算子は</font><i><font style="vertical-align: inherit;">int</font></i><font style="vertical-align: inherit;">型の値を返しません</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、および比較カテゴリの1つに属するオブジェクト。その値は、比較されたオブジェクト間の関係のタイプを反映しています。 3つの主なカテゴリがあります。</font></font><br>
<br>
<ul>
<li><i>strong_ordering</i>:   ,       (.. <i>(a &lt;=&gt; b) == strong_ordering::equal </i> ,      <i>f </i>   <i>f(a) == f(b)</i>.  « »     ,      ,       <i>capacity() </i>   ..    «» ,    ,    ,     <i></i> .   —     ,      ..).       : <i>strong_ordering::greater</i>, <i>strong_ordering::equal </i>  <i>strong_ordering::less</i>.</li>
<li><i>weak_ordering</i>:   ,        .   —     ,      <i>weak_ordering::equivalent</i>,       (    <i>equal </i> <i>equivalent</i>   ).</li>
<li><i>partial_ordering</i>:   .      <i>greater</i>, <i>equivalent </i>  <i>less</i> (  <i>weak_ordering</i>)    — <i>unordered</i> («»).           : <i>1.f &lt;=&gt; NaN </i>   <i>partial_ordering::unordered</i>.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strong_ordering</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カテゴリーを</font><i><font style="vertical-align: inherit;">操作し</font></i><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。これは、デフォルトで使用するのにも最適なカテゴリです。たとえば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 &lt;=&gt; 4</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strong_ordering :: lessを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返し</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 -1 &lt;=&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strong_ordering :: greatを返します</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より高い次数のカテゴリは、より弱い次数のカテゴリに暗黙的に削減できます（つまり、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strong_orderingはweak_orderingに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">還元可能</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。この場合、現在の関係タイプ（すなわち、保存され</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strong_ordering ::同じ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">になる</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weak_ordering ::相当します</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比較カテゴリの値は、リテラル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と比較できます</font><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><i><font style="vertical-align: inherit;">0</font></i><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">等しい</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ではなく、リテラル</font><i><font style="vertical-align: inherit;">0</font></i><font style="vertical-align: inherit;">）の場合6つの比較演算子の1つを使用：</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cpp hljs">strong_ordering::less &lt; <span class="hljs-number">0</span>     <span class="hljs-comment">// true</span>
strong_ordering::less == <span class="hljs-number">0</span>    <span class="hljs-comment">// false</span>
strong_ordering::less != <span class="hljs-number">0</span>    <span class="hljs-comment">// true</span>
strong_ordering::greater &gt;= <span class="hljs-number">0</span> <span class="hljs-comment">// true</span><font></font>
<font></font>
partial_ordering::less &lt; <span class="hljs-number">0</span>    <span class="hljs-comment">// true</span>
partial_ordering::greater &gt; <span class="hljs-number">0</span> <span class="hljs-comment">// true</span><font></font>
<font></font>
<span class="hljs-comment">// unordered -  ,  </span>
<span class="hljs-comment">//      </span>
partial_ordering::unordered &lt; <span class="hljs-number">0</span>  <span class="hljs-comment">// false</span>
partial_ordering::unordered == <span class="hljs-number">0</span> <span class="hljs-comment">// false</span>
partial_ordering::unordered &gt; <span class="hljs-number">0</span>  <span class="hljs-comment">// false</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関係演算子を実装できるの</font><font style="vertical-align: inherit;">
は、リテラル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">との比較のおかげです</font><font style="vertical-align: inherit;">。これらの演算子のそれぞれについて</font><i><font style="vertical-align: inherit;">、</font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a @ bは</font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（a &lt;=&gt; b）@ 0 </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">と</font></i><font style="vertical-align: inherit;">同等</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 &lt;4</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（2 &lt;=&gt; 4）&lt;0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として計算でき</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strong_ordering :: less &lt;0に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なり、値が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trueになります</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">&lt;=&gt;</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
演算子</font><font style="vertical-align: inherit;">は、</font><i><font style="vertical-align: inherit;">&lt;</font></i><font style="vertical-align: inherit;">演算子よりも</font><font style="vertical-align: inherit;">基本要素の役割に</font><font style="vertical-align: inherit;">適してい</font><font style="vertical-align: inherit;">ます。これは、後者の両方の問題を排除するためです。</font><font style="vertical-align: inherit;">
まず、式</font><i><font style="vertical-align: inherit;">a &lt;= bは</font></i><i><font style="vertical-align: inherit;">（a &lt;=&gt; b）&lt;= 0</font></i><font style="vertical-align: inherit;">と同等であること</font><i><font style="vertical-align: inherit;">が</font></i><font style="vertical-align: inherit;">保証されています</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">半順序でも。 2つの順序付けられていない値の場合、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a &lt;=&gt; b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は値</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partial_ordered :: unordered</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を提供し、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partial_ordered :: unordered &lt;= 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を提供し</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。これが必要なものです。これが可能なのは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;=&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がより多くの種類の値を返す</font><font style="vertical-align: inherit;">可能性があるため</font><font style="vertical-align: inherit;">です。たとえば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partial_ordering</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カテゴリに</font><font style="vertical-align: inherit;">は4つの可能な値が含まれます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型の</font><i><font style="vertical-align: inherit;">値</font></i><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のみで</font><i><font style="vertical-align: inherit;">ある</font></i><font style="vertical-align: inherit;">可能性があるため、以前は順序付けされた値と順序付けされていない値の比較を区別できませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明確にするために、浮動小数点数に関連しない部分的な順序関係の例を考えてみます。</font><font style="vertical-align: inherit;">NaN状態</font><font style="vertical-align: inherit;">を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型に追加する</font><font style="vertical-align: inherit;">とします。ここで、NaNは、関係する値と順序付けられたペアを形成しない単なる値です。</font><font style="vertical-align: inherit;">これを行うには、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std ::オプション</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で保存し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IntNan</span> {</span>
  <span class="hljs-built_in">std</span>::optional&lt;<span class="hljs-keyword">int</span>&gt; val = <span class="hljs-built_in">std</span>::nullopt;<font></font>
  <font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(IntNan <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">if</span> (!val || !rhs.val) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> *val == *rhs.val;<font></font>
  }<font></font>
  <font></font>
  partial_ordering <span class="hljs-keyword">operator</span>&lt;=&gt;(IntNan <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">if</span> (!val || !rhs.val) {
      <span class="hljs-comment">//  unordered  </span>
      <span class="hljs-comment">//    </span>
      <span class="hljs-keyword">return</span> partial_ordering::unordered;<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// &lt;=&gt;   strong_ordering  int,</span>
    <span class="hljs-comment">//        partial_ordering</span>
    <span class="hljs-keyword">return</span> *val &lt;=&gt; *rhs.val;<font></font>
  }<font></font>
};<font></font>
<font></font>
IntNan{<span class="hljs-number">2</span>} &lt;=&gt; IntNan{<span class="hljs-number">4</span>}; <span class="hljs-comment">// partial_ordering::less</span>
IntNan{<span class="hljs-number">2</span>} &lt;=&gt; IntNan{};  <span class="hljs-comment">// partial_ordering::unordered</span><font></font>
<font></font>
<span class="hljs-comment">//     .   </span>
IntNan{<span class="hljs-number">2</span>} &lt; IntNan{<span class="hljs-number">4</span>};   <span class="hljs-comment">// true</span>
IntNan{<span class="hljs-number">2</span>} &lt; IntNan{};    <span class="hljs-comment">// false</span>
IntNan{<span class="hljs-number">2</span>} == IntNan{};   <span class="hljs-comment">// false</span>
IntNan{<span class="hljs-number">2</span>} &lt;= IntNan{};   <span class="hljs-comment">// false</span></code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;=</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
演算子</font><font style="vertical-align: inherit;">は正しい値を返します。これで、言語自体のレベルでより多くの情報を表現できるようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、必要な情報をすべて取得するには、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;=&gt;を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1回適用するだけで十分です</font><font style="vertical-align: inherit;">。これにより、辞書式比較の実装が容易になります。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> {</span><font></font>
  T t;<font></font>
  U u;<font></font>
  <font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(A <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> t == rhs.t &amp;&amp;<font></font>
      u == rhs.u;<font></font>
  }<font></font>
  <font></font>
  strong_ordering <span class="hljs-keyword">operator</span>&lt;=&gt;(A <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-comment">//    </span>
    <span class="hljs-comment">//  t.   != 0 (..  t</span>
    <span class="hljs-comment">// ),   </span>
    <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> c = t &lt;=&gt; rhs.t; c != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> c;<font></font>
    <font></font>
    <span class="hljs-comment">//    </span>
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">return</span> u &lt;=&gt; rhs.u;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
詳細</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font><i><font style="vertical-align: inherit;">演算子&lt;=&gt;</font></i><font style="vertical-align: inherit;">を追加するための元の文である</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">P0515を</font></a><font style="vertical-align: inherit;">参照してください</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいオペレーター機能</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいオペレーターを自由に選べるだけではありません。</font><font style="vertical-align: inherit;">最後に、構造</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の宣言を含む上記の例</font><font style="vertical-align: inherit;">で、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x &lt;yの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代わりに</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（x &lt;=&gt; y）&lt;0を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">毎回書き込む必要がある</font><font style="vertical-align: inherit;">と言っ</font><i><font style="vertical-align: inherit;">た</font></i><font style="vertical-align: inherit;">だけの</font><font style="vertical-align: inherit;">場合、誰もそれを望みません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 20で比較を解決するメカニズムは、古いアプローチとは著しく異なりますが、この変更は、2つの基本的な比較演算子の新しい概念に直接関連しています：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;=&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">以前はイディオム（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を介した記録</font><font style="vertical-align: inherit;">）でしたが、これは使用しましたが、コンパイラーが知らなかったものでしたが、今では彼はこの違いを理解しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一度、記事の冒頭ですでに見た表を挙げます。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平等</font></font></b><br>
</td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合理化</font></font></b><br>
</td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベーシック</font></font></b><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">==</font></font></i><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;=&gt;</font></font></i><br>
</td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デリバティブ</font></font></b><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！=</font></font></i><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;=</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; =</font></font></i><br>
</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本演算子と派生演算子のそれぞれに新しい能力が追加されました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本的な演算子の反転</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例として、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とのみ比較できるタイプを考えます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> {</span>
  <span class="hljs-keyword">int</span> i;
  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> : <span class="hljs-title">i</span><span class="hljs-params">(i)</span> </span>{ }<font></font>
  <font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">int</span> j) <span class="hljs-keyword">const</span> { 
    <span class="hljs-keyword">return</span> i == j;<font></font>
  }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
古いルールの観点からは、式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a == 10が</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能し、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a.operator ==（10）に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">評価される</font><font style="vertical-align: inherit;">ことは当然のこと</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 == aは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どうですか？ C ++ 17では、この式は明確な構文エラーと見なされます。そのような演算子はありません。このコードが機能するためには、</font><font style="vertical-align: inherit;">最初に</font><i><font style="vertical-align: inherit;">int</font></i><font style="vertical-align: inherit;">の値を取り、</font><font style="vertical-align: inherit;">次に</font><i><font style="vertical-align: inherit;">A</font></i><font style="vertical-align: inherit;"> ...を</font><font style="vertical-align: inherit;">とる</font><font style="vertical-align: inherit;">対称</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を記述する必要があります</font><font style="vertical-align: inherit;">。これを実装するには、フリー関数の形式にする必要があります。</font><font style="vertical-align: inherit;">
C ++ 20では、基本的な演算子を逆にすることができます。</font><i><font style="vertical-align: inherit;">== 10、</font></i><font style="vertical-align: inherit;">コンパイラは候補でしょう</font><i><font style="vertical-align: inherit;">==演算子を（A、INT）</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（実際には、これはメンバー関数ですが、明確にするために、ここではフリー関数としてここに記述しています）、そしてさらに-パラメーターの逆順のバリアント、つまり</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子==（int、A）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この2番目の候補は、式（および理想的には）と一致するため、それを選択します。</font><font style="vertical-align: inherit;">C ++ 20 </font><font style="vertical-align: inherit;">の式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 == a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a.operator ==（10）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として評価され</font><font style="vertical-align: inherit;">ます。コンパイラは、等価性が対称であることを理解しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、型を拡張し</font><font style="vertical-align: inherit;">て、等価演算子だけでなく順序演算子でも</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と比較できるようにします</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> {</span>
  <span class="hljs-keyword">int</span> i;
  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> : <span class="hljs-title">i</span><span class="hljs-params">(i)</span> </span>{ }<font></font>
  <font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">int</span> j) <span class="hljs-keyword">const</span> { 
    <span class="hljs-keyword">return</span> i == j;<font></font>
  }<font></font>
  <font></font>
  strong_ordering <span class="hljs-keyword">operator</span>&lt;=&gt;(<span class="hljs-keyword">int</span> j) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> i &lt;=&gt; j;<font></font>
  }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しになります</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、式</font><i><font style="vertical-align: inherit;">a &lt;=&gt; 42</font></i><font style="vertical-align: inherit;">は正常に機能し、古い規則に従って</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a.operator &lt;=&gt;（42）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として計算されます</font><font style="vertical-align: inherit;">が、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">42 &lt;=&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aは、演算子</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt; =&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">既にその言語で存在しています。ただし、C ++ 20では、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子</font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">同様</font><font style="vertical-align: inherit;">に</font><i><font style="vertical-align: inherit;">演算子&lt;=&gt;</font></i><font style="vertical-align: inherit;">は対称的です。</font><i><font style="vertical-align: inherit;">つまり</font></i><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">反転候補を認識します。以下のために</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">42 &lt;=&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、メンバ関数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレータ</font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">&lt;=&gt; </font></i><i><font style="vertical-align: inherit;">（A、int）が</font></i><font style="vertical-align: inherit;">発見される</font><font style="vertical-align: inherit;">（再び、私はより明確にするためのフリー機能として、ここでそれを書いています）、並びに合成候補</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレータ</font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">&lt;=&gt; </font></i><i><font style="vertical-align: inherit;">（int型、A）</font></i><font style="vertical-align: inherit;">。この逆バージョンは、式と完全に一致します-私たちはそれを選択します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかしながら</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">42 &lt;=&gt; </font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aは</font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a.operator </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">&lt;=&gt; </font></i><i><font style="vertical-align: inherit;">（42）</font></i><font style="vertical-align: inherit;">として計算されません</font><font style="vertical-align: inherit;">。それは間違っているでしょう。この式は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 &lt;=&gt; a.operator &lt;=&gt;（42）に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">評価され</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。このエントリが正しい理由を理解してみてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラが新しい関数を作成しないことに注意することが重要です。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 == aを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算</font><i><font style="vertical-align: inherit;">する</font></i><font style="vertical-align: inherit;">場合、新しい演算子</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operator ==（int、A）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は表示されませんでした</font><font style="vertical-align: inherit;">。また、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">42 &lt;=&gt; aを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算する場合</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子</font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">&lt;=&gt; </font></i><i><font style="vertical-align: inherit;">（int、A）</font></i><font style="vertical-align: inherit;">は表示されませんでした</font><font style="vertical-align: inherit;">。たった2つの式が反転候補を介して書き換えられます。繰り返しますが、新しい関数は作成されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、パラメータの順序が逆のレコードは、基本的な演算子でのみ使用できますが、導関数では使用できません。つまり：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span> {</span>
   <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">const</span>;<font></font>
};<font></font>
<font></font>
b != <span class="hljs-number">42</span>; <span class="hljs-comment">// ok   C++17,   C++20</span>
<span class="hljs-number">42</span> != b; <span class="hljs-comment">//    C++17,   C++20</span></code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">派生演算子の書き換え</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例に戻りましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> {</span>
  <span class="hljs-keyword">int</span> i;
  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> : <span class="hljs-title">i</span><span class="hljs-params">(i)</span> </span>{ }<font></font>
  <font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">int</span> j) <span class="hljs-keyword">const</span> { 
    <span class="hljs-keyword">return</span> i == j;<font></font>
  }<font></font>
  <font></font>
  strong_ordering <span class="hljs-keyword">operator</span>&lt;=&gt;(<span class="hljs-keyword">int</span> j) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> i &lt;=&gt; j;<font></font>
  }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a！= 17を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取り</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">C ++ 17では、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operator！=</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Operatorが存在しないため、これは構文エラー</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">ただし、C ++ 20では、微分比較演算子を含む式の場合、コンパイラーは対応する基本演算子も検索し、それらを介して微分比較を表現します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数学では、演算</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！=</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本的にNOT </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">==を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">意味し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これはコンパイラに知られています。</font><font style="vertical-align: inherit;">式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a！= 17の場合</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子！= Operatorsだけ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でなく、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も</font><font style="vertical-align: inherit;">検索します</font><font style="vertical-align: inherit;">（前の例と同様に、反転</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）この例では、ほぼ適した等価演算子が見つかりました-必要なセマンティクスに従ってそれを書き換えるだけです：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a！= 17</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！（A == 17）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として計算され</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17！=</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！A.operator ==（17）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として計算され</font><font style="vertical-align: inherit;">、これは書き換えられたバージョンと反転されたバージョンの両方です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様の変換は、順序付け演算子でも実行されます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;9</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を記述し</font><i><font style="vertical-align: inherit;">た</font></i><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">、（失敗して）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子&lt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を見つけよう</font><font style="vertical-align: inherit;">とし、基本的な候補である</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子&lt;=&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も検討し</font><font style="vertical-align: inherit;">ます。関係演算子に対応する交換がある：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@のB</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ここで</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-関係演算子の1つ）は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（a &lt;=&gt; b）@ 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として計算され</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。この例では、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a.operator &lt;=&gt;（9）&lt;0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。同様に、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9 &lt;= aは</font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 &lt;= a.operator &lt;=&gt;（9）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として計算され</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
呼び出しの場合と同様に、コンパイラーは、書き換えられた候補に対して新しい関数を作成しないことに注意してください。それらは単純に異なる方法で計算され、すべての変換はソースコードレベルでのみ実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のアドバイスに上記リード私を</font></font><br>
<br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ONLY BASIC OPERATORS</font></font></i></b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：あなたのタイプにのみ、基本的な演算子（==とを&lt;=&gt;）を定義します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本的な演算子は比較のセット全体を提供するため、それらのみを定義するだけで十分です。つまり、同じタイプのオブジェクトを比較するために必要な演算子は2つだけ（現在のところ6ではなく）であり、異なるタイプのオブジェクトを比較するために必要な演算子は12だけです。等値演算のみが必要な場合は、同じタイプのオブジェクトを比較する（2ではなく）1つの関数と、異なるタイプのオブジェクトを比較する（4ではなく）1つの関数を記述します。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: sub_matchクラスには、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">極端なケースである：C ++ 17で、それは42個の比較演算子を使用し、機能はどのような方法で苦しむことはありませんがC ++ 20には、わずか8を使用しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーは反転候補も考慮するため、これらの演算子はすべてメンバー関数として実装できます。</font><font style="vertical-align: inherit;">異なるタイプのオブジェクトを比較するためだけに、無料の関数を作成する必要がなくなりました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">候補者を見つけるための特別なルール</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに述べたように、</font><font style="vertical-align: inherit;">C ++ 17での</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a @ bの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">候補の検索は</font><font style="vertical-align: inherit;">、次の原則に従って実行さ</font><font style="vertical-align: inherit;">れました。</font><font style="vertical-align: inherit;">すべての</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子@演算子</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を見つけ</font><font style="vertical-align: inherit;">、それらから最適な</font><i><font style="vertical-align: inherit;">演算子</font></i><font style="vertical-align: inherit;">を選択します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 20では、候補の拡張セットが使用されます。次に、すべての</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子@</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を検索します</font><font style="vertical-align: inherit;">。してみましょう</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@@</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のための基本演算子も</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、@</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（それは同じ演算することができます）。また、すべての</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子@@</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">検索し</font><font style="vertical-align: inherit;">、それぞれに反転バージョンを追加します。見つかったこれらすべての候補の中から、最適なものを選択します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
演算子のオーバーロードは</font><b><font style="vertical-align: inherit;">単一で</font></b><font style="vertical-align: inherit;">許可され</font><b><font style="vertical-align: inherit;">て</font></b><font style="vertical-align: inherit;">いることに注意してください</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パス。私たちは別の候補者を代理しようとはしていません。最初にそれらをすべて収集し、次にそれらから最適なものを選択します。これが存在しない場合、以前と同様に検索は失敗します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今、私たちははるかに多くの潜在的な候補者を抱えているため、より多くの不確実性があります。次の例を考えてみます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">C</span> {</span>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(C <span class="hljs-keyword">const</span>&amp;) <span class="hljs-keyword">const</span>;
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(C <span class="hljs-keyword">const</span>&amp;) <span class="hljs-keyword">const</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(C x, C y)</span> </span>{
  <span class="hljs-keyword">return</span> x != y;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 17では、我々は1つだけ候補を持っていた</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！X = Y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：、そして今3がある</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= x.operator（Y）！ </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X.operator ==（Y）！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y.operator ==（X）！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。何を選ぶ？それらはすべて同じです！ （注：候補となる</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y.operator！=（X）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は存在しません。これは、</font><i><font style="vertical-align: inherit;">反転</font></i><font style="vertical-align: inherit;">できるのは基本的な演算子のみです。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この不確実性を取り除くために、2つのルールが追加されました。未変換の候補は、変換よりも望ましいです。書き直された候補者は、書き直された候補者よりも好ましい。次に、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x.operator！=（Y）が</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">より重要である</font><font style="vertical-align: inherit;">ことが</font><i><font style="vertical-align: inherit;">わかります</font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！X.operator ==（y）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そしてそれがより重要</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です！Y.operator ==（x）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この原則は、最も正確なオプションが「勝つ」標準ルールと一致しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つ注意してください。検索段階では、候補</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子@@の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">戻り値の型には興味がありません</font><font style="vertical-align: inherit;">。私たちはそれらを見つけるだけです。それらが最良の選択であるかどうかにのみ関心があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
失敗した検索結果も異なるように見えます。最適な候補が書き換えられたり変換されたりした場合（たとえば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x &lt;y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">書き</font><font style="vertical-align: inherit;">、最適な候補は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（x &lt;=&gt; y）&lt;0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）であるが、比較を正しく書き換えたり逆にしたりできない場合（たとえば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x &lt;=&gt; y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><i><font style="vertical-align: inherit;">voidを</font></i><font style="vertical-align: inherit;">返す</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または他のタイプ。通常はDSLで記述されるため）、プログラムは正しくないと見なされます。戻って別の適切なオプションを探すことはしません。等価演算の場合、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以外の戻り</font><i><font style="vertical-align: inherit;">値の</font></i><font style="vertical-align: inherit;">型</font><font style="vertical-align: inherit;">は書き換えられた候補と互換性</font><font style="vertical-align: inherit;">がないことを受け入れ</font><font style="vertical-align: inherit;">ます（ここでのロジックはこれです：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boolを</font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">返さ</font></i><font style="vertical-align: inherit;">ない</font><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">、そのような演算は等価演算と見なすことができますか？）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span> {</span> 
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Base&amp;, <span class="hljs-keyword">const</span> Base&amp;);  <span class="hljs-comment">// #1</span>
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> Base&amp;, <span class="hljs-keyword">const</span> Base&amp;); <font></font>
}; <font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Derived</span> :</span> Base { 
  <span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>&lt;=&gt;(<span class="hljs-keyword">const</span> Derived&amp;, <span class="hljs-keyword">const</span> Derived&amp;); <span class="hljs-comment">// #2</span><font></font>
}; <font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">f</span><span class="hljs-params">(Derived d1, Derived d2)</span> </span>{
  <span class="hljs-keyword">return</span> d1 &lt; d2;<font></font>
} </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d1 &lt;d2の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2つの候補が見つかります：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">完全一致なので、</font><font style="vertical-align: inherit;">最適なオプションは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。つまり、これを選択します。</font><font style="vertical-align: inherit;">これは書き換えられた候補であるため、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d1 &lt;d2は</font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（d1 &lt;=&gt; d2）&lt;0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として計算され</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、これは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と比較できないため、正しくない式です</font><font style="vertical-align: inherit;">。つまり、比較全体が正しくありません。</font><font style="vertical-align: inherit;">この失敗の後、候補</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を選択するためのアクションは行われなくなります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルールのクイックツアー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、これらのルールはC ++ 17のルールよりも複雑ですが、この小さなセクションで完全に説明します。</font><font style="vertical-align: inherit;">特別なケースや例外に特化した脚注はありません。</font><font style="vertical-align: inherit;">最も重要な原則を覚えておいてください。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通話は基本的なオペレーターのみが利用できます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（対応する基本演算子を介して）対応できるのは微分演算子だけです</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのパスで候補を検索する場合、指定された名前を持つすべての演算子が検索され、それらのすべての反転されたバージョンと書き換えられたバージョン</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適な候補が書き直されたバージョンまたは反転されたバージョンであり、同時にそのような置き換えが受け入れられない場合、プログラムは正しくないと見なされます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアドバイスに従って</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本的な演算子のみ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を決定すれば</font><font style="vertical-align: inherit;">、これらすべてについて心配する必要はありません。</font><font style="vertical-align: inherit;">すべての比較が機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
わかりやすくするために、ソースコードレベルで可能なすべての変換を表に示します。</font><font style="vertical-align: inherit;">どちらの場合も、最初の列の式は2番目の列の式よりも優先度が高く、3番目の列の式（ceteris paribus）よりも優先度が高くなります。</font><font style="vertical-align: inherit;">2番目と3番目の列には、基本的な演算子のみが含まれています。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース操作</font></font></b><br>
</td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプション1</font></font></b><br>
</td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプション2</font></font></b><br>
</td>
</tr>
<tr>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a == b</font></font></i><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b == a</font></font></i><br>
</td>
<td><br>
</td>
</tr>
<tr>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a！= b</font></font></i><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！（a == b）</font></font></i><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！（b == a）</font></font></i><br>
</td>
</tr>
<tr>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a &lt;=&gt; b</font></font></i><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 &lt;=&gt;（b &lt;=&gt; a）</font></font></i><br>
</td>
<td><br>
</td>
</tr>
<tr>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a &lt;b</font></font></i><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（a &lt;=&gt; b）&lt;0</font></font></i><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（b &lt;=&gt; a）&gt; 0</font></font></i><br>
</td>
</tr>
<tr>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a &lt;= b</font></font></i><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（a &lt;=&gt; b）&lt;= 0</font></font></i><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（b &lt;=&gt; a）&gt; = 0</font></font></i><br>
</td>
</tr>
<tr>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a&gt; b</font></font></i><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（a &lt;=&gt; b）&gt; 0</font></font></i><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（b &lt;=&gt; a）&lt;0</font></font></i><br>
</td>
</tr>
<tr>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a&gt; = b</font></font></i><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（a &lt;=&gt; b）&gt; = 0</font></font></i><br>
</td>
<td><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（b &lt;=&gt; a）&lt;= 0</font></font></i><br>
</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
右側の列に「宇宙船」があるバリアントは、通常、元のバージョンと同じ演算子で記述されます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a &lt;b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 &lt;（b &lt;=&gt; a）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と書かれてい</font><font style="vertical-align: inherit;">ますが、書き直したバージョンで記号がどのように変化するかをより明確に示すために、反対の記号を付けて書きました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトの比較の定義</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とりわけ、C ++ 17は、要素ごとの辞書編集の比較を詳細に説明する必要があることに悩まされています。</font><font style="vertical-align: inherit;">このアクティビティは疲れて、エラーが山積しています。</font><font style="vertical-align: inherit;">3つのメンバーを持つ線形順序型の完全な演算子のセットを記述します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> {</span><font></font>
  T t;<font></font>
  U u;<font></font>
  V v;<font></font>
  <font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(A <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> t == rhs.t &amp;&amp;<font></font>
      u == rhs.u &amp;&amp;<font></font>
      v == rhs.v;<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(A <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == rhs);<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (A <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-comment">//    ,     ,</span>
    <span class="hljs-comment">//     ?:  &amp;&amp;/||</span>
    <span class="hljs-keyword">if</span> (t &lt; rhs.t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (rhs.t &lt; t) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (u &lt; rhs.u) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (rhs.u &lt; u) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> v &lt; rhs.v;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt; (A <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> rhs &lt; *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;=(A <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> !(rhs &lt; *<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt;=(A <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> &lt; rhs);<font></font>
  }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なんらかの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: tie（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用するのがさらに良いでしょうが</font><font style="vertical-align: inherit;">、それでも面倒です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、私のアドバイスに従って、同じ構造を記述してみましょう。基本的な演算子のみを定義します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> {</span><font></font>
  T t;<font></font>
  U u;<font></font>
  V v;<font></font>
  <font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(A <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> t == rhs.t &amp;&amp;<font></font>
      u == rhs.u &amp;&amp;<font></font>
      v == rhs.v;<font></font>
  }<font></font>
  <font></font>
  strong_ordering <span class="hljs-keyword">operator</span>&lt;=&gt;(A <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> {
    <span class="hljs-comment">//   T</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> c = t &lt;=&gt; rhs.t; c != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> c;
    <span class="hljs-comment">// ...  U</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> c = u &lt;=&gt; rhs.u; c != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> c;
    <span class="hljs-comment">// ...  V</span>
    <span class="hljs-keyword">return</span> v &lt;=&gt; rhs.v;<font></font>
  }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単なるコードの削減だけではありません。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;=&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装自体は</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装よりもはるかに理解しやすい</font><font style="vertical-align: inherit;">です。完全な比較を1つのパスで実行できるため、より明白です。チェックし</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cが！= 0は、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちが等しくない値のペアを見つけた場合、私たちは継続することができません。また、どのような比率この不等式は（表現された</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それ以上</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、これは比較の最終結果となります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトで</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常の要素ごとの辞書式比較</font><i><font style="vertical-align: inherit;">です</font></i><font style="vertical-align: inherit;">。そしてC ++ 20では、コンパイラーに必要なことを単純に伝えるだけで十分です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> {</span><font></font>
  T t;<font></font>
  U u;<font></font>
  V v;<font></font>
  <font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(A <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> = <span class="hljs-keyword">default</span>;<font></font>
  strong_ordering <span class="hljs-keyword">operator</span>&lt;=&gt;(A <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> = <span class="hljs-keyword">default</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デフォルトのコンパイラが生成する比較演算子を明示的に指定する必要があります。</font><font style="vertical-align: inherit;">比較カテゴリが自動的に決定される場合、コードをさらに簡略化できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> {</span><font></font>
  T t;<font></font>
  U u;<font></font>
  V v;<font></font>
  <font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(A <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> = <span class="hljs-keyword">default</span>;
  <span class="hljs-keyword">auto</span> <span class="hljs-keyword">operator</span>&lt;=&gt;(A <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> = <span class="hljs-keyword">default</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに先に進むことができます。</font><font style="vertical-align: inherit;">典型的なシナリオでは、等価性と関係性に関する通常の要素ごとの比較が必要な場合、演算子を1つだけ定義するだけで十分です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> {</span><font></font>
  T t;<font></font>
  U u;<font></font>
  V v;<font></font>
  <font></font>
  <span class="hljs-keyword">auto</span> <span class="hljs-keyword">operator</span>&lt;=&gt;(A <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> = <span class="hljs-keyword">default</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、コンパイラーが自分で記述していない比較演算子を生成する唯一のケースです。</font><font style="vertical-align: inherit;">最後の2つのオプションはまったく同じです。デフォルトの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とデフォルトの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子&lt;=&gt;の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">両方があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今後の記事のトピック</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、C ++ 20での比較の基本を調べました。合成候補のしくみと配置方法です。</font><font style="vertical-align: inherit;">また、3者間比較とその実装の機能についても簡単に検討しました。</font><font style="vertical-align: inherit;">まだカバーすべき興味深いトピックがいくつかありますが、あまり長くない記事を書きたいので、新しい投稿を待ちます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳者メモ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PVS-Studioチームはこの記事に興味を示しました。近い将来、アナライザーに新しい演算子&lt;=&gt;のサポートを実装する必要があるためです。そして、記事は非常に有用であり、すべてをうまく説明しているので、habrコミュニティのために翻訳することにしました。私たちの意見では、これは言語の非常に必要な革新です。なぜなら、私たちの経験では、比較演算子にはエラーが含まれていることが非常に多いからです（「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比較関数における悪の命</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」を参照</font><font style="vertical-align: inherit;">）。これでC ++は、プログラマーの生活を楽にし、このタイプのエラーを減らします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、PVS-Studioで、記事に記載されている、正しく記述されていない&lt;ステートメントを検索するための新しい診断を作成するというアイデアが生まれました。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (A <span class="hljs-keyword">const</span>&amp; rhs) <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">return</span> t &lt; rhs.t &amp;&amp; u &lt; rhs.u;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様のコードが古い大規模プロジェクトに存在する可能性があります。</font><font style="vertical-align: inherit;">おそらく、さらに診断を行うでしょう。</font><font style="vertical-align: inherit;">考える必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出典：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 20での比較</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja465557/index.html">製品開発期限</a></li>
<li><a href="../ja465561/index.html">一流のプログラマーから学んだこと</a></li>
<li><a href="../ja465569/index.html">モバイル開発者開発マップ</a></li>
<li><a href="../ja465571/index.html">男性のたばこを女性に売って野蛮人に身を守らせる方法：できるコピーライター</a></li>
<li><a href="../ja465573/index.html">1つの言語の例におけるIntelliJ IDEAのすべての能力（写真）</a></li>
<li><a href="../ja465577/index.html">高度なインタラクティブスニペット用の新しいタイプのマイクロマーキング</a></li>
<li><a href="../ja465579/index.html">Zextrasチームとの企業チャットとビデオ会議の作成</a></li>
<li><a href="../ja465583/index.html">iPhoneユーザーのための悪意のあるキャンペーンの詳細が明らかに</a></li>
<li><a href="../ja465585/index.html">Reduxを介してReact Data Gridを管理する方法</a></li>
<li><a href="../ja465587/index.html">分析：OTC市場とは何か、そこで行われる取引</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>