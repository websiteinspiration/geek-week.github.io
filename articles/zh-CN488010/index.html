<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍞 💝 ♾ 域驱动设计工具 🏊 💹 👨🏿‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="蓝鲸是一个复杂项目的设计出错的很好的例子。鲸鱼看起来像鱼，但它是哺乳动物：它用牛奶喂养小熊，有毛，而且前臂的骨头和用手指的手指（像陆地上的手指一样）仍保留在鳍中。他生活在海洋中，但无法在水下呼吸，因此即使他在睡觉，他也定期升到水面吞咽空气。鲸鱼是世界上最大的动物，有一个九层楼的房子，重达75辆大众途...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>域驱动设计工具</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/488010/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蓝鲸是一个复杂项目的设计出错的很好的例子。鲸鱼看起来像鱼，但它是哺乳动物：它用牛奶喂养小熊，有毛，而且前臂的骨头和用手指的手指（像陆地上的手指一样）仍保留在鳍中。他生活在海洋中，但无法在水下呼吸，因此即使他在睡觉，他也定期升到水面吞咽空气。鲸鱼是世界上最大的动物，有一个九层楼的房子，重达75辆大众途锐汽车，但不是捕食者，而是以浮游生物为食。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当开发人员研究鲸鱼时，他们并没有从头开始编写所有内容，而是使用了旧项目中的经验。它似乎是由未经测试的代码的不兼容部分拼凑而成的，所有设计都归结为选择框架和已经投入生产的紧急“循环”。结果，该项目看上去很漂亮，但里面有许多密集的遗留物和拐杖。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/to/9e/qb/to9eqb8yxhrfep8tl32q9augiv4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了创建项目来帮助企业赚钱，而不是看起来像不能在水下呼吸的海洋动物，这里有DDD。这种方法的重点不在于工具或代码，而在于对主题领域，单个业务流程以及代码或工具如何用于业务逻辑的研究。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
什么是DDD以及其中包含哪些工具，我们将根据报告在一篇文章中讲述</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阿尔乔姆Malyshev</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Python中的DDD方法，工具，陷阱，合同编程以及围绕要解决的问题（而不是所使用的框架）的产品设计都已被削减。</font></font><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/LqTPRCLZffE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">报告的完整介绍</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></i><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artem Malyshev</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">证明404</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）-使用Python编写了5年的独立开发人员，在Django Channels 1.0方面提供了积极的帮助。</font><font style="vertical-align: inherit;">后来他专注于架构方法：他研究了Python架构师缺少的工具，并开始了一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">干Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Drylabs的联合创始人。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复杂</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
什么是编程？</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编程人员一直在与开发人员尝试解决问题时创建的复杂性作斗争。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复杂度分为两种：引入的和自然的。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引入的内容</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与编程语言，框架，OS，异步模型一起扩展。</font><font style="vertical-align: inherit;">这是一项</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术挑战</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，不适用于企业。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自然的</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复杂性隐藏在产品中，并简化了用户的生活-为此，人们需要花钱。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好的工程师应该减少增加的复杂性并增加自然性以增加产品的实用性。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是我们程序员是复杂的人，我们喜欢为项目增加技术复杂性。例如，我们不用担心编码标准，没有使用linter，模块化设计实践，并且在项目中收到了很多样式代码</font></font><code>if c==1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如何使用这样的代码？阅读大量文件，了解变量，条件以及何时以及如何工作。很难记住此代码-绝对是技术上的复杂性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
增加复杂性的另一个例子是我最喜欢的“回调地狱”。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/1h/s5/pa1hs5z7giwwav8wxyvbllgqdaw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我们在面向事件的体系结构（EDA）的框架中编写并选择一个不太好的现代框架时，我们得到的代码不清楚何时发生什么。很难阅读这样的代码-这又是增加的复杂性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
程序员不仅喜欢技术上的困难，而且还争论哪一个更好：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AsyncIO或Gevent；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQL或MongoDB;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python或Go；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Emacs或Vim；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制表符或空格；</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个好的程序员对所有这些问题的正确答案是：“没关系！” </font><font style="vertical-align: inherit;">好的开发人员不会在真空中争论球形的马，而是要解决业务问题并致力于产品的实用性。</font><font style="vertical-align: inherit;">他们中的一些人已经建立了一套实践，可以减少引入的复杂性并帮助您更多地考虑业务。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其中之一是</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">埃里克·埃文斯</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><strong><font style="vertical-align: inherit;">Eric Evans）</font></strong><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">2004年，他撰写了《域驱动设计》一书。</font><font style="vertical-align: inherit;">她“开枪”并一时冲动，想更多地考虑业务，并将技术细节推向后台。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v6/4p/kr/v64pkrz6lrqylss53fxhvojvock.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么是DDD？</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先是解决问题的方法，然后是工具</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。首先，埃文斯投资了DDD的概念，这不是技术，而是一种哲学。在哲学上，您首先需要考虑如何解决问题，然后才需要借助哪些工具。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与主题专家和软件开发人员一起建立模型。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们必须与企业界人士进行沟通：寻找一种通用语言，建立一个世界模型，我们的产品将在其中发挥作用并解决问题。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编写明确表达模型的软件</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">DDD与团队中的简单协作之间最重要的区别在于，我们应该以与领域专家交流的风格来编写软件。</font><font style="vertical-align: inherit;">所有的术语，讨论和决策方法都应存储在源代码中，这样即使是非技术人员也可以理解那里发生的事情。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与商业交流</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">DDD是一种关于如何与特定领域的业务专家说同一语言并将术语应用于该领域的哲学。</font><font style="vertical-align: inherit;">在绑定的上下文中，我们有一种共同的语言或方言，我们认为这是真的。</font><font style="vertical-align: inherit;">我们围绕架构解决方案创建边界。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DDD与技术无关。</font></font></blockquote><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先是技术部分，然后是DDD。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从石头上雕刻雕像的雕刻家没有阅读有关如何握住锤子和凿子的手册-他已经知道如何使用它们。要将DDD引入您的项目，请精通技术部分：学习Django到最后，阅读教程并停止争论是否使用PostgreSQL或MongoDB。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大多数设计模式和模式都是技术噪声。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们知道和使用的大多数模式都是技术性的。他们说了如何重用代码，如何构造代码，但没有说如何将代码用于用户，企业和为外部世界建模。因此，工厂或抽象类被松散地绑定到DDD。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一本“蓝皮书”大约在20年前问世。人们试图以这种风格写作，走了耙，意识到这种哲学是好的，但实际上却难以理解。因此，出现了第二本书-“红色”，关于程序员如何在DDD中进行思考和编写。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/j3/nf/dd/j3nfdd-vnh3shjuuxvxrh7ogwj8.jpeg"><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“红色”和“蓝色”书是所有DDD站立的支柱。</font></font></em><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意。红色和蓝色的书是有关DDD的唯一信息来源，但是它们很繁琐。书籍不易阅读：由于语言和术语复杂，一本为原始书，而由于翻译不善，一本为俄文。因此，从一本</font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绿</font></font></em></a><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">皮</font></em><em><font style="vertical-align: inherit;">书</font></em><em><font style="vertical-align: inherit;">开始学习DDD </font></em></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这是前两个版本的简化版本，带有更简单的示例和一般说明。但这要比红色和蓝色的书胜过您学习和应用DDD的愿望要好。最好阅读原著。</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
红皮书跳过了如何最好地将DDD引入项目，如何围绕这种方法来组织工作的想法。</font><font style="vertical-align: inherit;">出现了一个新术语-“模型驱动设计”，其中我们的外部模型放在第一位。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bq/oj/65/bqoj653kebtxlaj7fkvbcx8xhq8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
选择的唯一技术是智能UI。</font><font style="vertical-align: inherit;">这是外部世界，用户和我们之间的一层（对Robert Martin及其干净的体系结构的引用）。</font><font style="vertical-align: inherit;">如您所见，一切都归于模型。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么是模特？</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是任何建筑师的幻影之痛。</font><font style="vertical-align: inherit;">每个人都认为这是UML，但事实并非如此。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模型是一组类，方法以及它们之间的链接，它们反映程序中的业务场景。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该模型反映了具有所有必要属性和功能的真实对象。</font><font style="vertical-align: inherit;">这是从业务案例的角度进行决策的高级工具包。</font><font style="vertical-align: inherit;">但是，方法和类是用于体系结构解决方案的低级工具包。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">干蟒蛇</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了填补模型的空白，我开始了一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">干Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">项目</font><font style="vertical-align: inherit;">已成长为</font><font style="vertical-align: inherit;">用于构建模型驱动设计</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的高级体系结构库</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><strong><font style="vertical-align: inherit;">集合</font></strong><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">每个库都试图缩小体系结构中的一个圆圈，并且不干扰另一个圆圈。</font><font style="vertical-align: inherit;">可以单独使用库，也可以根据需要一起使用。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/un/kb/am/unkbampyzrvkbwwjwd4amsiahuw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
叙述的顺序对应于DDD向项目中最佳添加的时间顺序（逐层）。</font><font style="vertical-align: inherit;">第一层是</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这是我们系统中业务场景（流程）的描述。</font><font style="vertical-align: inherit;">故事库负责此层。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">故事</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
业务场景分为三个部分：</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规范</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -业务流程的描述；</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">国家</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在其中的业务场景可能存在</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">脚本</font><strong><font style="vertical-align: inherit;">的</font></strong><font style="vertical-align: inherit;">每个步骤。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些部分不得混用。</font><font style="vertical-align: inherit;">Stories库将这些部分分开，并在它们之间划清了界限。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑使用示例介绍DDD和故事。</font><font style="vertical-align: inherit;">例如，我们在Django上有一个项目，其中包含Django信号的混搭和模糊的“厚”模型。</font><font style="vertical-align: inherit;">向其中添加一个空的服务包。</font><font style="vertical-align: inherit;">局部使用Stories库，我们将此哈希重写为项目中一组清晰易懂的脚本。</font></font><br>
<img src="https://habrastorage.org/webt/lo/r9/st/lor9stle7ok2tx_eiv4nx931abs.png"><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DSL规范。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该库允许您编写规范并为此提供DSL。</font><font style="vertical-align: inherit;">这是逐步描述用户操作的方式。</font><font style="vertical-align: inherit;">例如，要购买</font></font><code>subscription</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我需要执行几个步骤：我将找到一个订单，检查价格的相关性，检查用户是否负担得起。</font><font style="vertical-align: inherit;">这是一个高级描述。</font></font><br>
<img src="https://habrastorage.org/webt/pf/uy/rk/pfuyrkvzoktrxxjurabhbzfwmka.png"><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合同。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此类下，我们将针对业务场景的状态编写合同。为此，我们表示业务流程中出现的变量区域，并为每个变量分配一组验证器。</font></font><br>
<img src="https://habrastorage.org/webt/e0/qy/de/e0qydendpyyrti651302r_6dxnm.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一旦有人尝试将变量分配给该区域作为业务流程的一部分，就会制定出一组验证器。我们将确保运行时进程的状态始终正常。但是，如果没有，它会痛苦地跌落并大声尖叫。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个步骤的执行阶段</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在同一类中，</font></font><code>subscription</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们编写了一组名称与业务步骤相对应的方法。每个输入方法都可以使用一种状态，但无权对其进行修改。该方法可能返回一些标记并报告：</font></font><br>
<br>
<ul>
<li>  ,       ()   ;</li>
<li>  -   ,      .</li>
</ul><br>
<img src="https://habrastorage.org/webt/ny/pe/_-/nype_-46uz-nuannwmrcfsrhojq.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还有更复杂的标记：它们可以确认状态是否正常，建议删除或更改业务流程的某些部分。您也可以编写类。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启动故事。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何在执行时运行Story？这是一个用作方法的业务对象：我们将数据传输到输入，它会验证它们并解释步骤。正在运行的Story会记住执行历史，记录业务流程中发生的状态，并告诉我们是</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谁影响了该状态</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<img src="https://habrastorage.org/webt/o7/e7/s5/o7e7s53zun6l9mprpqg-vkerp-s.png"><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调试工具栏。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们使用Django编写并使用调试面板，则可以看到每个请求中处理了哪些业务场景及其状态。</font></font><br>
<img src="https://habrastorage.org/webt/i8/td/aq/i8tdaqss6_wf7uk0e6sdifdqhau.png"><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高温测试</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果我们用py.test编写，那么对于失败的测试，我们可以看到每行执行了哪些业务脚本以及出了什么问题。这很方便-我们无需阅读代码，而是阅读规范并了解发生了什么。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4f/pr/gc/4fprgcpruxp3bbpgcapv7rc44je.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哨兵。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更好的是，当我们收到错误500时。在常规系统中，我们忍受了并开始调查。在Sentry中，将显示有关用户为犯错所做的详细报告。在凌晨3点为您收集此类信息时，它既方便又愉快。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qk/dy/js/qkdyjspvszlg7vzy803gfqmpt5k.png"><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ELK</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。现在，我们正在积极开发一个插件，该插件将Elasticsearch中的所有内容写入Kibana堆栈并构建有效的索引。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/df/7i/7d/df7i7dk01va0ekvv7sxlkdhz9pg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，我们有一个关于业务流程状态的合同。例如，我们知道那里有什么</font></font><code>relation ID</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">报告。</font><font style="vertical-align: inherit;">与其对曾经发生的事情进行过时的研究，我们在Kibana中写了一个请求。</font><font style="vertical-align: inherit;">它将显示与特定用户相关的所有故事。</font><font style="vertical-align: inherit;">接下来，我们检查业务流程和业务场景中的状态。</font><font style="vertical-align: inherit;">我们没有写一行日志代码，但是项目是在我们感兴趣的抽象层进行日志记录的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是我想要更高层次的东西，例如轻的物体。</font><font style="vertical-align: inherit;">例如，此类对象包含与业务决策的采用相关但与数据库无关的文化数据结构和方法。</font><font style="vertical-align: inherit;">因此，我们继续进行模型驱动架构的下一部分-实体，集合和值对象。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/oh/c4/hh/ohc4hhk6ru1lrn-ohyrp83byn1w.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实体，集合和价值对象</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有这些如何相互联系？例如，用户下了一个产品订单，然后我们开票。聚合的根源是什么，什么是简单对象？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ml/4g/kc/ml4gkcmc0-hajo2sk5apaklct6y.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
强调的只是聚合的根源。我想直接与之合作：重要，有价值，全面。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从哪里开始？</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将在项目中创建一个空包，在其中放置我们的单元。聚合最好用诸如</font></font><code>dataclasses</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或的</font><font style="vertical-align: inherit;">声明性语言编写</font></font><code>attrs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<img src="https://habrastorage.org/webt/7e/0z/dx/7e0zdxqhapwuerqxbs8zf6wocse.png"><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据类</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果</font></font><code>dataclass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们指示</font><font style="vertical-align: inherit;">某种</font><font style="vertical-align: inherit;">聚合，则将使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NewType</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在其上编写注释</font><font style="vertical-align: inherit;">。在注释中，我们指示一个显式引用，该引用以类型系统表示。如果</font></font><code>dataclass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只是数据结构（实体），则将其保存在集合中。</font></font><br>
<img src="https://habrastorage.org/webt/9y/g3/fe/9yg3fe7qn2_xj6pas4m1hewhikc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在“故事”的上下文中，只能聚集。</font><font style="vertical-align: inherit;">只有通过公共方法和高级规则才能访问嵌入其中的内容。</font><font style="vertical-align: inherit;">这使您可以逻辑地，有能力地建立模型，我们将与该领域的专家一起合作。</font><font style="vertical-align: inherit;">这是同</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一种语言</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xj/ov/7s/xjov7shv-7gsu-u0w6c6aejxkq8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
问题立即出现-存储库。</font><font style="vertical-align: inherit;">我有一个通过Django处理的数据库，附近是我向其发送请求的微服务，其中包含JSON和Django模型的实例。</font><font style="vertical-align: inherit;">要接收数据并手动传输数据，仅仅是为了漂亮地调用或测试该方法？</font><font style="vertical-align: inherit;">当然不是。</font><font style="vertical-align: inherit;">Dry-python有一个Mappers库，可让您将高级抽象和域聚集映射到我们存储它们的地方。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">映射器</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们向我们的项目中添加了另一个软件包-我们将在其中存储我们的存储库</font></font><code>mappers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这就是我们将高级业务逻辑转移到现实世界的方式。</font></font><br>
<img src="https://habrastorage.org/webt/gt/w8/zu/gtw8zusqmldesc-5m-sanew8hxy.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，我们可以描述如何将一个映射</font></font><code>dataclass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到Django模型。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Django ORM。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将订单模型与Django ORM的描述进行比较-我们查看这些字段。</font></font><br>
<img src="https://habrastorage.org/webt/gw/cp/v8/gwcpv8rjs4cs592qvob0tu0t_rw.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，我们可以通过可选配置重写某些字段。将发生以下情况：</font></font><code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在声明期间，它将比较</font></font><code>dataclass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模型的</font><font style="vertical-align: inherit;">编写方式</font><font style="vertical-align: inherit;">。例如，</font><font style="vertical-align: inherit;">Django模型中的</font><font style="vertical-align: inherit;">注释</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（在</font><font style="vertical-align: inherit;">带有注释</font></font><code>Order dataclass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的字段中</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">与option </font><font style="vertical-align: inherit;">相对应</font><font style="vertical-align: inherit;">。这将</font><font style="vertical-align: inherit;">提供补充</font><font style="vertical-align: inherit;">到</font><font style="vertical-align: inherit;">，或删除</font></font><code>cost</code><font style="vertical-align: inherit;"></font><code>int</code><font style="vertical-align: inherit;"></font><code>integer field</code><font style="vertical-align: inherit;"></font><code>nullable="true"</code><font style="vertical-align: inherit;"></font><code>dataclass</code><font style="vertical-align: inherit;"></font><code>optional</code><font style="vertical-align: inherit;"></font><code>dataclass</code><font style="vertical-align: inherit;"></font><code>nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来自</font></font><code>field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过Mappers，您可以添加读取或写入内容的函数。读取器是在输入处接收聚合并返回对其的引用的函数。作家做相反的-返回单位。例如，在后台，可能会通过Django向数据库发出请求。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">昂扬的定义</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">微服务可以执行相同的操作。您可以在其上编写部分swagger方案，并检查特定服务的swagger方案与您的域模型匹配多少。此外，从请求库返回的请求将透明地转换为</font></font><code>dataclass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<img src="https://habrastorage.org/webt/sk/2k/rv/sk2krveeieqjqkd5gmcn1hxettc.png"><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GraphQL查询。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GraphQL和微服务：GraphQL接口类型架构可以很好地应对</font></font><code>dataclass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。您可以将特定的GraphQL查询转换为内部数据结构。</font></font><br>
<img src="https://habrastorage.org/webt/th/om/j0/thomj0ho9pgvu-n8_w7uhkvlmz4.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么要打扰应用程序内部的内部高级数据模型？为了说明“为什么”，我将讲一个“有趣的”故事。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的一个项目中，Web套接字通过Pusher服务工作。我们没有打扰，我们将其包装在一个接口中以免直接调用。该界面与所有故事相关，并很满意。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是业务需求已经改变。事实证明，Pusher为Web套接字提供的保证还不够。例如，您需要保证最近2分钟的邮件传递和邮件历史记录。因此，我们决定移至Ably Realtime服务。它还有一个接口-我们将编写一个适配器并将其绑定到任何地方，一切都会很棒。并不是的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pusher使用的抽象（函数参数）被捕获在每个业务对象中。</font><font style="vertical-align: inherit;">我必须修复大约100个故事，并修复我们要向其发送消息的用户渠道的形成。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回到测试。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试与模拟</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您通常如何通过外部服务测试此行为？</font><font style="vertical-align: inherit;">我们正在弄些东西，正在观察如何调用第三方库，仅此而已-我们确信一切都很好。</font><font style="vertical-align: inherit;">但是，当库更改时，参数格式也将更改。</font></font><br>
<img src="https://habrastorage.org/webt/zo/ey/34/zoey341uas00jfbgt0e5nld69ta.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您对内部模型的行为进行不同的测试，则可以节省一周的时间来重写数千个测试和数百个业务案例。</font><font style="vertical-align: inherit;">例如，类似于集成测试的内容：我们写入用户流，并且已经在适配器，Pusher或Ably内部，我们将此流转换为普通通道的名称，以免将其全部写入业务逻辑。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存关系</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这样的模型架构中，出现了许多多余的实体。</font><font style="vertical-align: inherit;">以前，我们采用了某种Django函数并编写了该函数：请求，响应，最小身体移动。</font><font style="vertical-align: inherit;">在这里，您需要初始化Mappers，放入Stories并进行初始化，处理HTTP请求的请求行，看看给出哪个答案。</font><font style="vertical-align: inherit;">所有这些都会在Django-view中产生30-50行样板调用代码Stories。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一方面，我们已经编写了接口和Mappers。</font><font style="vertical-align: inherit;">我们可以检查它们与特定业务案例的兼容性，例如，使用“依赖关系”库。</font><font style="vertical-align: inherit;">怎么样？</font><font style="vertical-align: inherit;">通过Dependency注入模式，所有内容都声明性地粘贴到最小的样板上。</font></font><br>
<img src="https://habrastorage.org/webt/w9/_5/th/w9_5thkcuryvswlpy39x8dpkoio.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们指示在服务包中上课的任务，将三个</font></font><code>mappers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，初始化Stories对象并将其提供给我们。</font><font style="vertical-align: inherit;">通过这种方法，代码中的样板数量大大减少了。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重构图</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用我所说的一切，我们开发了一种方案，通过该方案，我们使用DDD将Django信号（隐式“回调地狱”）中的一个大型项目重写为Django。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有DDD的第一步</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。最初我们没有DDD-我们编写了MVP。当他们赚到第一笔钱时，他们邀请了投资者，并说服他们转向DDD。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有合同的故事。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将项目分解成没有数据合同的逻辑业务案例。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合同和总额</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。然后，我们一个接一个地拖动每个模型的数据协定，这可以在我们的体系结构中进行跟踪。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">映射器</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。映射器编写以摆脱数据仓库模板。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依赖注入</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。摆脱粘合模式。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您的项目的MVP超过了，并且迫切需要在体系结构中进行更改，以使其不会遗留在旧系统中-请看一下DDD。</font></font><br>
<br>
<blockquote>     legacy  Python-,     ,    ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Moscow Python Conf++</a> 27 .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a>        Python       .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">unconference</a>,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>, ,   Drylabs.<br>
<br>
  DDD    Python,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TechLead Conf</a> — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">    </a>   IT-,    DDD .   8 , Call for Papers   6 .</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN487996/index.html">脚本驱动程序和服务器母亲如何接管IT</a></li>
<li><a href="../zh-CN488000/index.html">特斯拉格子。三电机驱动器布局的两个选项</a></li>
<li><a href="../zh-CN488002/index.html">一个怪胎的情况</a></li>
<li><a href="../zh-CN488006/index.html">在Moscow Python Conf ++上，与语言开发人员交谈</a></li>
<li><a href="../zh-CN488008/index.html">驯服野兽：遗留代码，测试和您</a></li>
<li><a href="../zh-CN488012/index.html">停车的缺点</a></li>
<li><a href="../zh-CN488014/index.html">9. Fortinet入门v6.0。记录和报告</a></li>
<li><a href="../zh-CN488018/index.html">验证码，特殊情况：我们用三十行代码破坏神经网络</a></li>
<li><a href="../zh-CN488020/index.html">Vivaldi 2.11-一键式美容</a></li>
<li><a href="../zh-CN488024/index.html">出色的咨询锁及其居住地</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>