<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💷 👍🏾 👨‍👨‍👦‍👦 高度なTypeScript 👨‍👩‍👧‍👧 🙎🏾 🚂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="フリーダイビング-スキューバダイビングなしのスキューバダイビング。ダイバーはアルキメデスの法則を感じています。彼は一定量の水を移動させ、それが彼を押し戻します。したがって、最初の数メートルが最も硬くなりますが、その後、上の水柱の圧力がより深く移動するのを助け始めます。このプロセスは、TypeScri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>高度なTypeScript</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/499634/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フリーダイビング-スキューバダイビングなしのスキューバダイビング。</font><font style="vertical-align: inherit;">ダイバーはアルキメデスの法則を感じています。彼は一定量の水を移動させ、それが彼を押し戻します。</font><font style="vertical-align: inherit;">したがって、最初の数メートルが最も硬くなりますが、その後、上の水柱の圧力がより深く移動するのを助け始めます。</font><font style="vertical-align: inherit;">このプロセスは、TypeScriptタイプシステムの学習とダイブを思い起こさせます。ダイブするにつれて少し簡単になります。</font><font style="vertical-align: inherit;">しかし、私たちは時間内に出現することを忘れてはなりません。</font><font color="gray"><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ワンオーシャンワンブレス</font></a></i></font></font><br>
<br>
<img src="https://habrastorage.org/webt/sh/eb/y9/sheby96u0qt6o3usirdpsc78hpg.jpeg"><br>
<font color="gray"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からの写真</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font></i></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ミハイル・バスロフ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">斉藤中村</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）-TypeScriptファンでありアマチュアフリーダイバーであるWiseBitsのシニアフロントエンドエンジニア。</font><font style="vertical-align: inherit;">TypeScriptの学習とディープダイビングの類似は偶然ではありません。</font><font style="vertical-align: inherit;">Michaelは、識別された共用体とは何か、型推論の使用方法、名目上の互換性とブランドが必要な理由を説明します。</font><font style="vertical-align: inherit;">息を止めてダイビングしてください。</font></font><a name="habracut"></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/m0uRxCCno00" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><font color="gray"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレゼンテーションとサンプルコードを含むGitHubへのリンクは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちら</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></i></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕事の種類</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
和のタイプは代数的に聞こえます-それが何であるかを理解してみましょう。</font><font style="vertical-align: inherit;">それらは、ReasonMLではバリアント、Haskellではタグ付きユニオン、F＃とTypeScriptでは識別ユニオンと呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィキペディアは次のように定義しています：「金額のタイプは作品のタイプの合計です。」</font></font><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-船長ありがとうございます！</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定義は完全に正しいですが役に立たないので、理解しましょう。</font><font style="vertical-align: inherit;">プライベートから始めて、仕事の種類から始めましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプがあるとしましょう</font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これには2つのフィールドがあります</font></font><code>id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs">type Task = { <span class="hljs-attr">id</span>: number, <span class="hljs-attr">whoCreated</span>: number }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このタイプの作業は交差点または</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交差点</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">これは、各フィールドと同じコードを個別に記述できることを意味します。</font></font><br>
<br>
<pre><code class="javascript hljs">type Task = { <span class="hljs-attr">id</span>: number } &amp; { <span class="hljs-attr">whoCreated</span>: number }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
命題代数では、これは論理積と呼ばれます。これは「AND」または「AND」演算です。</font><font style="vertical-align: inherit;">製品のタイプは、これら2つの要素の論理積です。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一連のフィールドを持つオブジェクトは、論理積で表現できます。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕事の種類はフィールドに限定されません。</font><font style="vertical-align: inherit;">私たちがプロトタイプを愛し、私たちが行方不明だと決めたと想像してください</font></font><code>leftPad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs">type RichString = string &amp; { <span class="hljs-attr">leftPad</span>: <span class="hljs-function">(<span class="hljs-params">toLength: number</span>) =&gt;</span> string }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
に追加し</font></font><code>String.prototype</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">型で表現するには、文字列と必要な値をとる関数を取ります。</font><font style="vertical-align: inherit;">メソッドと文字列は共通部分です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">協会</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
union — </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">union</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> —は、たとえば、CSSで要素の幅を設定する変数のタイプ（10ピクセルの文字列または絶対値）を表すのに役立ちます。</font><font style="vertical-align: inherit;">CSS仕様は実際にははるかに複雑ですが、簡単にするために、そのままにしておきましょう。</font></font><br>
<br>
<pre><code class="javascript hljs">type Width = string | number</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例はもっと複雑です。</font><font style="vertical-align: inherit;">タスクがあるとします。</font><font style="vertical-align: inherit;">作成、作業への受け入れ、完了の3つの状態があります。</font></font><br>
<br>
<pre><code class="javascript hljs">type InitialTask = { <span class="hljs-attr">id</span>: number, <span class="hljs-attr">whoCreated</span>: number }<font></font>
type InWorkTask = { <span class="hljs-attr">id</span>: number, <span class="hljs-attr">whoCreated</span>: number }<font></font>
type FinishTask = { <span class="hljs-attr">id</span>: number, <span class="hljs-attr">whoCreated</span>: number, <span class="hljs-attr">finishDate</span>: <span class="hljs-built_in">Date</span> }<font></font>
<font></font>
type Task = InitialTask | InWorkTask | FinishedTask</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初と2番目の状態では、タスクの</font></font><code>id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作成者と作成者、3番目の状態では完了日が表示されます。</font><font style="vertical-align: inherit;">ここに組合が現れます-これかそれとも。</font></font><br>
<br>
<strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注</font></font></em></strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">代わりに、</font></font></em><code>type</code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用できます</font></font></em><code>interface</code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">しかし、ニュアンスがあります。</font><font style="vertical-align: inherit;">ユニオンとインターセクションの結果は常にタイプです。</font><font style="vertical-align: inherit;">交差はで表現できますが</font></font></em><code>extends</code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、結合は</font></font></em><code>interface</code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">できません。</font><font style="vertical-align: inherit;">それはだ</font></font></em><code>type</code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">だけ短いです。</font></font><br>
<br>
</em><code>interface</code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宣言のマージにのみ役立ちます。</font><font style="vertical-align: inherit;">ライブラリのタイプは常にで表現する必要があり</font></font></em><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">ます。これ</font></em><em><font style="vertical-align: inherit;">により</font></em><em><font style="vertical-align: inherit;">、他の開発者がフィールドで</font></em><em><font style="vertical-align: inherit;">ライブラリタイプ</font></em></font><code>interface</code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を拡張できるようになります。</font><font style="vertical-align: inherit;">典型的な例としては、jQuery-pluginsなどがあります。</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプの互換性</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、TypeScriptには</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造型の互換性</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">という問題があり</font><font style="vertical-align: inherit;">ます。つまり、最初のタイプと2番目のタイプが同じフィールドのセットを持っている場合、これらは同じタイプの2つです。たとえば、名前は異なるが構造は同じ（フィールドが同じ）のタイプが10個あります。それらの1つを受け入れる関数に10の型のいずれかを提供する場合、TypeScriptは問題になりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
反対に、JavaまたはC＃では、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名目互換性システム</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。同一のフィールドを持つ10個のクラスと、それらの1つを取る関数を記述します。他のクラスが関数の対象となる型の直接の子孫でない場合、関数はそれを受け入れません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造的な互換性の問題は、フィールドにステータスを追加することで解決されます：</font></font><code>enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><code>string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ただし、合計タイプは、コードがデータベースに格納される方法よりも意味的にコードを表現する方法です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例として、ReasonMLを取り上げます。これが、このタイプの外観です。</font></font><br>
<br>
<pre><code class="javascript hljs">type Task =<font></font>
| Initial({ <span class="hljs-attr">id</span>: int, <span class="hljs-attr">whoCreated</span>: int })<font></font>
| InWork({ <span class="hljs-attr">id</span>: int, <span class="hljs-attr">whoCreated</span>: int })<font></font>
| Finished({<font></font>
        <span class="hljs-attr">id</span>: int,
        <span class="hljs-attr">whoCreated</span>: int,
        <span class="hljs-attr">finshDate</span>: <span class="hljs-built_in">Date</span>
    })</code></pre><br><font style="vertical-align: inherit;"></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代わり</font><font style="vertical-align: inherit;">
にを除いて、同じフィールド</font></font><code>number</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。よく見ると、我々は注意してください</font></font><code>Initial</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>InWork</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>Finished</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。それらはタイプ名の左側ではなく、定義の右側にあります。これはタイトルの単なる行ではなく、別のタイプの一部なので、最初のものと2番目のものを区別できます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライフハック</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ジェネリック型（ドメインエンティティなど）の場合、ファイル</font></font><code>global.d.ts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">作成し、</font><font style="vertical-align: inherit;">すべての型をそれに追加します。それらは、明示的なインポートを必要とせずに、TypeScriptコードベース全体で自動的に表示されます。タイプの配置場所を気にする必要がないため、これは移行に便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プリミティブReduxコードの例を使用して、これを行う方法を見てみましょう。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> taskReducer = (state, action) = &gt; {
    <span class="hljs-keyword">switch</span> (action.type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"TASK_FETCH"</span>:
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">true</span> }
        <span class="hljs-keyword">case</span> <span class="hljs-string">"TASK_SUCCESS"</span>:
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">task</span>: action.payload }
        <span class="hljs-keyword">case</span> <span class="hljs-string">"TASK_FAIL"</span>:
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">erro</span>: action.payload }<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> state<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScriptでコードを書き直します。 -のは、ファイルの名前を変更してみましょう</font></font><code>.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font></font><code>.ts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。すべての状態オプションとnoImplicitAnyオプションをオンにします。このオプションは、パラメーター・タイプが指定されていない関数を見つけ、マイグレーションの段階で役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
型付け可能</font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：追加フィールド</font></font><code>isFetching</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（することはできません）と</font></font><code>Error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs">type Task = { <span class="hljs-attr">title</span>: string }<font></font>
<font></font>
declare <span class="hljs-built_in">module</span> <span class="hljs-string">"*.jpg"</span> {
    <span class="hljs-keyword">const</span> url: string
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> url<font></font>
}<font></font>
<font></font>
declare <span class="hljs-built_in">module</span> <span class="hljs-string">"*.png"</span> {
    <span class="hljs-keyword">const</span> url: string
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> url<font></font>
}</code></pre><br>
<em><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lifehackがバサラトアリサイードの</font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScript Deep Diveを</font></font></em></a><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">のぞきました</font></em></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。少し古くなっていますが、TypeScriptを使いたい人にはまだ便利です。</font></font></em><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">Marius Schulzの</font></em></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブログで</font></font></em></a><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;"> TypeScriptの現在の状態について読んでください</font></em></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。彼は新機能とトリックについて書いています。また、勉強</font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更ログを</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、唯一の更新に関する情報が、また、それらの使用方法がありません。</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
残りのアクション。それぞれを入力して宣言します。</font></font><br>
<br>
<pre><code class="javascript hljs">type FetchAction = {
    <span class="hljs-attr">type</span>: <span class="hljs-string">"TASK_FETCH"</span><font></font>
}<font></font>
<font></font>
type SuccessAction = {<font></font>
    <span class="hljs-attr">type</span>: <span class="hljs-string">"TASK_SUCCESS"</span>,
    <span class="hljs-attr">payload</span>: Task<font></font>
<font></font>
type FailAction = {<font></font>
    <span class="hljs-attr">type</span>: <span class="hljs-string">"TASK_FAIL"</span>,
    <span class="hljs-attr">payload</span>: <span class="hljs-built_in">Error</span><font></font>
}<font></font>
<font></font>
type Actions = FetchAction | SuccessAction | FailAction</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フィールド</font></font><code>type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はすべてのタイプで異なり、単なる文字列ではなく、特定の文字列、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つまり文字列リテラル</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">これは非常に</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弁別子で</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あり、</font><font style="vertical-align: inherit;">すべてのケースを区別するためのタグです。</font><font style="vertical-align: inherit;">差別化された組合を得て、たとえば、ペイロードの内容を理解することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
元のReduxコードを更新します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> taskReducer = (state: State, <span class="hljs-attr">action</span>: Actions): State = &gt; {
    <span class="hljs-keyword">switch</span> (action.type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"TASK_FETCH"</span>:
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">true</span> }
        <span class="hljs-keyword">case</span> <span class="hljs-string">"TASK_SUCCESS"</span>:
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">task</span>: action.payload }
        <span class="hljs-keyword">case</span> <span class="hljs-string">"TASK_FAIL"</span>:
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">error</span>: action.payload }<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> state<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここに書けばここに危険が</font></font><code>string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...</font></font><br>
<pre><code class="javascript hljs">type FetchAction = {
    <span class="hljs-attr">type</span>: string<font></font>
}</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...それはもはや弁別子ではないので、すべてが壊れます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアクションでは、typeは特定の識別子ではなく、任意の文字列にすることができます。</font><font style="vertical-align: inherit;">その後、TypeScriptは1つのアクションを別のアクションと区別してエラーを見つけることができなくなります。</font><font style="vertical-align: inherit;">したがって、文字列リテラルが正確に存在する必要があります。</font><font style="vertical-align: inherit;">さらに、次のデザインを追加できます</font></font><code>type ActionType = Actions["type"]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つのオプションがプロンプトにポップアップ表示されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uf/gm/si/ufgmsit8lx5zzmmd9tvot5ibg5u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
書けば...</font></font><br>
<pre><code class="javascript hljs">type FetchAction = {
    <span class="hljs-attr">type</span>: string<font></font>
}</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... </font></font><code>string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他のすべての行はもはや重要ではないため</font><font style="vertical-align: inherit;">、プロンプトは単純</font><font style="vertical-align: inherit;">になります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z1/g1/qe/z1g1qecermtbhjq62vju5ujmwv0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはすべてタイプし、量のタイプを得ました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">徹底的なチェック</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エラー処理がコードに追加されていない架空の状況を想像してみてください。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> taskReducer = (state: State, <span class="hljs-attr">action</span>: Actions): State = &gt; {
    <span class="hljs-keyword">switch</span> (action.type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"TASK_FETCH"</span>:
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">true</span> }
        <span class="hljs-keyword">case</span> <span class="hljs-string">"TASK_SUCCESS"</span>:
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">task</span>: action.payload }
        <span class="hljs-comment">//case "TASK_FAIL":</span>
            <span class="hljs-comment">//return { isFetching: false, error: action.payload }</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> state<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">徹底的なチェック</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は私たちを助け</font><font style="vertical-align: inherit;">ます-sumのようなもう一つの有用な特性</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、すべての可能なケースを処理したことを確認する機会です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
switchステートメントの後に変数を追加します</font></font><code>const exhaustiveCheck: never = action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
決して興味深いタイプではありません：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数の戻りの結果である場合、関数は正しく終了しません（たとえば、常にエラーをスローするか、無限に実行されます）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプの場合、このタイプは追加の作業なしでは作成できません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、コンパイラーは「タイプ 'FailAction'はタイプ 'never'に割り当てられません」というエラーを表示します。</font><font style="vertical-align: inherit;">アクションには3つのタイプがありますが、処理されていません</font></font><code>"TASK_FAIL"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これは</font></font><code>FailAction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">しかし、決して、「割り当て可能」ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
処理を追加してみましょう</font></font><code>"TASK_FAIL"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。エラーは発生しません。</font><font style="vertical-align: inherit;">処理</font></font><code>"TASK_FETCH"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">済み</font></font><code>"TASK_SUCCESS"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-返却</font><font style="vertical-align: inherit;">済み、処理済み</font><font style="vertical-align: inherit;">-返却済み、処理済み</font></font><code>"TASK_FAIL"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">3つの関数をすべて処理したとき、どのようなアクションが可能ですか？</font><font style="vertical-align: inherit;">何もない- </font></font><code>never</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のアクションを追加すると、コンパイラは処理されていないアクションを通知します。</font><font style="vertical-align: inherit;">これは、すべてのアクションに応答したい場合に役立ちます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のヒント</font></font></h2><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">頑張ってください。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初はダイビングするのは難しいでしょう。合計のタイプについて読んでから、チェーン内の積、代数的データタイプなどについて読んでください。</font><font style="vertical-align: inherit;">努力する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
深く潜ると、上の水柱の圧力が上がります。</font><font style="vertical-align: inherit;">ある深さでは、浮力と私たちの上の水圧が釣り合っています。</font><font style="vertical-align: inherit;">これは無重力状態にある「中立浮力」のゾーンです。</font><font style="vertical-align: inherit;">この状態では、他の型システムや言語に目を向けることができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公称型システム</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
古代ローマでは、住民は姓、名、「ニックネーム」の3つの構成要素を持っていました。</font><font style="vertical-align: inherit;">名前自体は「名目」。</font><font style="vertical-align: inherit;">これから、名義型システム「名義型」が生まれます。</font><font style="vertical-align: inherit;">時々役に立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、このような機能コードがあります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> githubUrl = process.env.GITHUB_URL <span class="hljs-keyword">as</span> string
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> nodeEnv = process.env.NODE_ENV <span class="hljs-keyword">as</span> string<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> fetchStarredRepos = (<font></font>
    nodeEnv: string,<font></font>
    <span class="hljs-attr">githubUrl</span>: string<font></font>
): <span class="hljs-built_in">Promise</span>&lt;GithubRepo[ ]&gt; =&gt; {
    <span class="hljs-keyword">if</span> (nodeEnv = <span class="hljs-string">"production"</span>) {
        <span class="hljs-comment">// log call</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// prettier-ignore</span>
    <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">'$githubUrl}/users/saitonakamura/starred'</span>)<font></font>
        .then(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.json());<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
設定はAPIで行われます：</font></font><code>GITHUB_URL=https://api.github.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>githubUrl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API </font><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">は、アスタリスクを付けたリポジトリを引き出します。</font><font style="vertical-align: inherit;">そして、もしそうなら</font></font><code>nodeEnv = "production"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それは例えば、メトリックスのために、この呼び出しを記録します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発したい機能（UI）について。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> React, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span><font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> StarredRepos = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> [starredRepos, setStarredRepos] = useState&lt;GithubRepo[ ] | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>)<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (!starredRepos) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Loading…<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
<font></font>
    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
            {starredRepos.map(repo =&gt; (
                <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{repo.name}</span>&gt;</span>repo.name}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
            ))}
        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><font></font>
    )<font></font>
}<font></font>
<font></font>
type GithubRepo = {<font></font>
    <span class="hljs-attr">name</span>: string<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数はすでにデータの表示方法を認識しており、データがない場合はローダーです。</font><font style="vertical-align: inherit;">API呼び出しを追加してデータを入力するだけです。</font></font><br>
<br>
<pre><code class="javascript hljs">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
    fetchStarredRepos(githubUrl, nodeEnv).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> setStarredRepos(data))<font></font>
}, [ ])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、このコードを実行すると、すべてが失敗します。</font><font style="vertical-align: inherit;">開発者パネルで</font></font><code>fetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、アドレスにアクセスして</font><font style="vertical-align: inherit;">いることがわかります</font></font><code>'/users/saitonakamura/starred'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-githubUrlがどこかで消えました。</font><font style="vertical-align: inherit;">奇妙なデザインのため、すべて</font></font><code>nodeEnv</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が最初に来ることがわかりました。</font><font style="vertical-align: inherit;">もちろん、すべてを変更したくなるかもしれませんが、関数はコードベースの他の場所で使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、コンパイラが事前にこれを要求した場合はどうなりますか？</font><font style="vertical-align: inherit;">その後、起動サイクル全体を実行したり、エラーを検出したり、理由を検索したりする必要はありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブランディング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScriptには、これに対するハック、つまりブランドタイプがあります。</font></font><code>Brand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（文字列）、</font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および2つのタイプを</font><font style="vertical-align: inherit;">作成します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">と同じタイプを作成します</font></font><code>NodeEnv</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs">type Brand&lt;T, B extends string&gt; = T &amp; { readonly _brand: B }<font></font>
<font></font>
type GithubUrl = Brand&lt;string, <span class="hljs-string">"githubUrl"</span>&gt;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> githubUrl = process.env.GITHUB_URL <span class="hljs-keyword">as</span> GithubUrl<font></font>
<font></font>
type NodeEnv = Brand&lt;string, <span class="hljs-string">"nodeEnv"</span>&gt;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> nodeEnv = process.env.NODE_ENV <span class="hljs-keyword">as</span> NodeEnv</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、エラーが発生します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qi/_e/j-/qi_ej-yne7xhcj4qmozvbw6r7qc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今、</font></font><code>githubUrl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それはだ</font></font><code>nodeEnv</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、これらは公称タイプですので、お互いを割り当てることが不可能。</font><font style="vertical-align: inherit;">控えめですが、わずかです。</font><font style="vertical-align: inherit;">ここでそれらを交換することはできません-コードの別の部分で変更します。</font></font><br>
<br>
<pre><code class="javascript hljs">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
    fetchStarresRepos(nodeEnv, githubUrl).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> setStarredRepos(data))<font></font>
}, [ ])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今ではすべてが順調です-彼らは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブランドのプリミティブ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を得ました</font><font style="vertical-align: inherit;">。ブランディングは、いくつかの引数（文字列、数値）が検出された場合に役立ちます。それらには特定のセマンティクス（x、y座標）があり、混同しないでください。コンパイラが混乱していると言ったときに便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、2つの問題があります。まず、TypeScriptにはネイティブの名義型がありません。しかし、それが解決されることを望んでおり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、この問題の議論は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">言語リポジトリで進行中です</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の問題は「として」</font></font><code>GITHUB_URL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。リンクが壊れ</font><font style="vertical-align: inherit;">ていないという保証</font><font style="vertical-align: inherit;">はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
と同様に</font></font><code>NODE_ENV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ほとんどの場合、文字列だけでなく</font></font><code>"production"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">orも必要</font></font><code>"development"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<pre><code class="javascript hljs">type NodeEnv = Brand&lt;<span class="hljs-string">"production"</span> | <span class="hljs-string">"development"</span> | <span class="hljs-string">"nodeEnv"</span>&gt;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> nodeEnv = process.env.NODE_ENV <span class="hljs-keyword">as</span> NodeEnv</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このすべてをチェックする必要があります。</font><font style="vertical-align: inherit;">スマートデザイナーとSergey Cherepanovのレポート「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能的なスタイルのTypeScriptを使用したドメインの設計</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」を紹介します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目と3番目のヒント</font></font></h2><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意してください。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時々立ち止まって周りを見回す：他の言語、フレームワーク、型システムで。</font><font style="vertical-align: inherit;">新しい原則を学び、レッスンを学びます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「中立の浮力」のポイントを通過すると、水はより強く押し付けられ、私たちを引き寄せます。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リラックス。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">より深く掘り下げ、TypeScriptにその仕事を任せましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScriptでできること</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScriptは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプを出力</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でき</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createFetch = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
    <span class="hljs-attr">type</span>: <span class="hljs-string">"TASK_FETCH"</span><font></font>
})<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createSuccess = <span class="hljs-function">(<span class="hljs-params">task: Task</span>) =&gt;</span> ({
    <span class="hljs-attr">type</span>: <span class="hljs-string">"TASK_SUCCESS"</span>
    <span class="hljs-attr">payload</span>: Task<font></font>
})<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createFail = <span class="hljs-function">(<span class="hljs-params">error: <span class="hljs-built_in">Error</span></span>) =&gt;</span> ({
    <span class="hljs-attr">type</span>: <span class="hljs-string">"TASK_FAIL"</span>
    <span class="hljs-attr">payload</span>: error<font></font>
})<font></font>
<font></font>
type FetchAction = {<font></font>
    <span class="hljs-attr">type</span>: <span class="hljs-string">"TASK_FETCH"</span>,<font></font>
<font></font>
type SuccessAction = {<font></font>
    <span class="hljs-attr">type</span>: <span class="hljs-string">"TASK_SUCCESS"</span>,
    <span class="hljs-attr">payload</span>: Task<font></font>
<font></font>
type FailAction = {<font></font>
    <span class="hljs-attr">type</span>: <span class="hljs-string">"TASK_FAIL"</span>,
    <span class="hljs-attr">payload</span>: <span class="hljs-built_in">Error</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにはTypeScriptがあり</font></font><code>ReturnType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、関数から戻り値を取得します。</font></font><pre><code class="javascript hljs">type FetchAction = ReturnType&lt;<span class="hljs-keyword">typeof</span> createFetch&gt;</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その中で、関数のタイプを渡します。</font><font style="vertical-align: inherit;">関数を作成することはできません</font></font><code>typeof</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">関数や変数から型を取得するには、を作成する必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒントでわかります</font></font><code>type: string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6w/n0/tq/6wn0tq3zjhnnoqvjrk0saubafak.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは悪いことです。オブジェクトリテラルがあるため、弁別子が壊れます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createFetch = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
    <span class="hljs-attr">type</span>: <span class="hljs-string">"TASK_FETCH"</span>
})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptでオブジェクトを作成すると、デフォルトでは変更可能です。</font><font style="vertical-align: inherit;">つまり、フィールドと文字列を持つオブジェクトでは、後で文字列を別の文字列に変更できます。</font><font style="vertical-align: inherit;">したがって、TypeScriptは特定の文字列を可変オブジェクトの任意の文字列に拡張します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScriptを何らかの形で支援する必要があります。</font><font style="vertical-align: inherit;">これにはconstがあります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createFetch = <span class="hljs-function"><span class="hljs-params">( )</span> =&gt;</span> ({
    <span class="hljs-attr">type</span>: <span class="hljs-string">"TASK_FETCH"</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>
})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
追加-文字列はプロンプトですぐに消えます。</font><font style="vertical-align: inherit;">これは、行全体だけでなく、一般的にリテラル全体でも記述できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createFetch = <span class="hljs-function"><span class="hljs-params">( )</span> =&gt;</span> ({
    <span class="hljs-attr">type</span>: <span class="hljs-string">"TASK_FETCH"</span>
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、タイプ（およびすべてのフィールド）は読み取り専用になります。</font></font><br>
<br>
<pre><code class="javascript hljs">type FetchAction = {<font></font>
    readonly type: <span class="hljs-string">"TASK_FETCH"</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アクションの可変性を変更することはほとんどないので、これは便利です。</font><font style="vertical-align: inherit;">したがって、どこにでもconstとして追加します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createFetch = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
    <span class="hljs-attr">type</span>: <span class="hljs-string">"TASK_FETCH"</span>
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>)<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createSuccess = <span class="hljs-function">(<span class="hljs-params">task: Task</span>) =&gt;</span> ({
    <span class="hljs-attr">type</span>: <span class="hljs-string">"TASK_SUCCESS"</span>
    <span class="hljs-attr">payload</span>: Task<font></font>
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>)<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createFail = <span class="hljs-function">(<span class="hljs-params">error: <span class="hljs-built_in">Error</span></span>) =&gt;</span> ({
    <span class="hljs-attr">type</span>: <span class="hljs-string">"TASK_FAIL"</span>
    <span class="hljs-attr">payload</span>: error<font></font>
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>)<font></font>
<font></font>
type Actions =<font></font>
    | ReturnType&lt;<span class="hljs-keyword">typeof</span> createFetch&gt;<font></font>
    | ReturnType&lt;<span class="hljs-keyword">typeof</span> createSuccess&gt;<font></font>
    | ReturnType&lt;<span class="hljs-keyword">typeof</span> createFail&gt;<font></font>
<font></font>
type State =<font></font>
    | { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">true</span> }<font></font>
    | { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">false</span>; task: Task }<font></font>
    | { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">false</span>; error: <span class="hljs-built_in">Error</span> }<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> taskReducer = (state: State, <span class="hljs-attr">action</span>: Actions): State = &gt; {
    <span class="hljs-keyword">switch</span> (action.type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"TASK_FETCH"</span>:
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">true</span> }
        <span class="hljs-keyword">case</span> <span class="hljs-string">"TASK_SUCCESS"</span>:
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">task</span>: action.payload }
        <span class="hljs-keyword">case</span> <span class="hljs-string">"TASK_FAIL"</span>:
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">error</span>: action.payload }<font></font>
}<font></font>
<font></font>
  <span class="hljs-keyword">const</span> _exhaustiveCheck: never = action<font></font>
<font></font>
  <span class="hljs-keyword">return</span> state<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードを入力するすべてのアクションが削減され、constとして追加されました。</font><font style="vertical-align: inherit;">TypeScriptは他のすべてを理解しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScriptは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">State</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><strong><font style="vertical-align: inherit;">出力</font></strong><font style="vertical-align: inherit;">でき</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">上記のコードでは、3つの考えられるisFetching状態（true、false、またはTask）を持つユニオンによって表されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプState = ReturnTypeを使用します。</font><font style="vertical-align: inherit;">TypeScriptプロンプトは、循環依存関係があることを示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ve/jk/vu/vejkvuzbnzraxku1y7yfm5qefhu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
短くして。</font></font><br>
<br>
<pre><code class="javascript hljs">type State = ReturnType&lt;<span class="hljs-keyword">typeof</span> taskReducer&gt;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> taskReducer = <span class="hljs-function">(<span class="hljs-params">state, action: Actions</span>) =&gt;</span> {
    <span class="hljs-keyword">switch</span> (action.type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"TASK_FETCH"</span>:
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">true</span> }
        <span class="hljs-keyword">case</span> <span class="hljs-string">"TASK_SUCCESS"</span>:
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">task</span>: action.payload }
        <span class="hljs-keyword">case</span> <span class="hljs-string">"TASK_FAIL"</span>:
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">error</span>: action.payload }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> _exhaustiveCheck: never = action<font></font>
<font></font>
<span class="hljs-keyword">return</span> state<font></font>
}</code></pre><br>
<code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のろいをやめましたが、今は彼がそう</font></font><code>any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">引数を入力します。</font></font><br>
<br>
<pre><code class="javascript hljs">type State = ReturnType&lt;<span class="hljs-keyword">typeof</span> taskReducer&gt;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> taskReducer = <span class="hljs-function">(<span class="hljs-params">state: { isFetching: <span class="hljs-literal">true</span> }, action: Actions</span>) =&gt;</span> {
    <span class="hljs-keyword">switch</span> (action.type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"TASK_FETCH"</span>:
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">true</span> }
        <span class="hljs-keyword">case</span> <span class="hljs-string">"TASK_SUCCESS"</span>:
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">task</span>: action.payload }
        <span class="hljs-keyword">case</span> <span class="hljs-string">"TASK_FAIL"</span>:
            <span class="hljs-keyword">return</span> { <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">error</span>: action.payload }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> _exhaustiveCheck: never = action<font></font>
<font></font>
<span class="hljs-keyword">return</span> state<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論は準備ができています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/i-/7f/mt/i-7fmtcvakp9l6ldfo98cqxfbwy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論は、私たちがもともと持っていたものと似ています</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ここにはガベージフィールドがありますが</font></font><code>Error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、タイプ</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-フィールドはあるようですが、ないようです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4番目のヒント</font></font></h2><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">過労しないでください。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リラックスして深くダイビングしすぎると、戻るための酸素が不足する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、トレーニング：テクノロジーに夢中になりすぎて、それをどこにでも適用することにした場合は、エラーが発生する可能性が高く、その理由はわかりません。</font><font style="vertical-align: inherit;">これにより拒否が発生し、静的型を使用する必要がなくなります。</font><font style="vertical-align: inherit;">あなたの強さを評価してみてください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScriptが開発を遅らせる方法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイピングをサポートするのにしばらく時間がかかります。</font><font style="vertical-align: inherit;">UXが最適ではありません。FlowやHaskellなどの他の型システムと同様に、完全に理解できないエラーが発生する場合があります。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムの表現力が高いほど、エラーは難しくなります。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型システムの価値は、エラーが発生したときに迅速なフィードバックを提供することです。システムはエラーを表示し、エラーを見つけて修正するための時間を短縮します。エラーの修正に費やす時間が減れば、より多くのアーキテクチャソリューションが注目されるようになります。型は、それらを扱うことを学んでも開発が遅くなることはありません。</font></font><br>
<br>
<blockquote>              <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">++</a>.  -  ,   ,        (25  26 )  -      (27  — 10 ). <br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  </a>   (5900  ),  ++            IT-,    . <br>
<br>
    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">AvitoTech</a>  FrontendConf 2019    .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">youtube-</a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>  telegram <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">@FrontendConfChannel</a>,       . </blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja499624/index.html">Ansibleツールの概要</a></li>
<li><a href="../ja499626/index.html">LaravelおよびJSON-RPC 2.0上のSOA</a></li>
<li><a href="../ja499628/index.html">開発面接：友達を選ぶ</a></li>
<li><a href="../ja499630/index.html">フラッター。2020年春の更新</a></li>
<li><a href="../ja499632/index.html">WaveNetEQによるGoogle Duoオーディオ品質の向上</a></li>
<li><a href="../ja499636/index.html">小さなもののためにネイティブを反応させます。モバイル開発経験</a></li>
<li><a href="../ja499642/index.html">Pixockets：ゲームサーバー用に独自のネットワークライブラリを作成する方法</a></li>
<li><a href="../ja499644/index.html">AutoTestツールを使用したロボット作成（RPA）</a></li>
<li><a href="../ja499646/index.html">アジャイルとスクラムの5つのUX統合ルール</a></li>
<li><a href="../ja499648/index.html">「ゲームデザイナーは常にゲーマー」：スペシャリストは何をするか、どのスキルが重要か</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>