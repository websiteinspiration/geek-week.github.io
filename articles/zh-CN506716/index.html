<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚪️ 👩🏾‍💻 🌿 多线程线性列表：元素存在问题，性能改进和STL关系 🍱 👩🏻‍🔧 📤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈，亲爱的哈伯游客，您好！
 
 本文将重点介绍链表，多线程和C ++。我马上注意到，有很多机会将这项工作放在架子上，并用于少数个人项目中。取而代之的是，我仍然决定将其发布给公众法庭-突然之间，这对某人确实很有用或有趣。此外，如果事实证明有人已经做过这样的事情，请告诉我这些材料。但是，无论我如何尝试...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>多线程线性列表：元素存在问题，性能改进和STL关系</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506716/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈，亲爱的哈伯游客，您好！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文将重点介绍链表，多线程和C ++。我马上注意到，有很多机会将这项工作放在架子上，并用于少数个人项目中。取而代之的是，我仍然决定将其发布给公众法庭-突然之间，这对某人确实很有用或有趣。此外，如果事实证明有人已经做过这样的事情，请告诉我这些材料。但是，无论我如何尝试使用Google搜索该主题，所有尝试均未成功。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我还注意到，这与经典的链表无关，而与我创造性地重新思考在多线程环境中使用此数据结构有关。我正在考虑一种无序密集型多线程列表访问的方案。这意味着任何时间的任何线程，无论其他线程如何，都可以访问该列表并执行所需的操作。如果他仅添加或更改元素，那还不错。如果他还删除了这些元素，则可能会出现各种有趣的功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这个项目是我的一项业余爱好，是我的自我发展项目，出于多种原因，该项目持续了很长时间。</font><font style="vertical-align: inherit;">另外，在我进行研究时，我进行了深入的研究：该项目开始时没有STL的知识和理解，因此仅使用C ++语言本身的内部手段进行了相应的设计。</font><font style="vertical-align: inherit;">但是，后来我非常认真地修改了它，考虑到了STL，甚至在STL下也是如此。</font><font style="vertical-align: inherit;">亲爱的读者，请您判断一下，我得出的结论。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了最全面地了解此处介绍的材料，您需要阅读以下书籍：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexandrescu A.-“ C ++中的现代设计”。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richter D.，纳扎尔K.-“通过C / C ++的Windows，Visual C ++编程”。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josattis N.-“ C ++标准库。</font><font style="vertical-align: inherit;">参考指南。</font><font style="vertical-align: inherit;">第二版”或类似的STL书籍。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行列表</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
线性列表是众所周知的数据结构，自C语言或更早的时代开始就使用。它的元素是内存中的某个对象，该对象与一个或两个相邻的相似元素具有连接-这是一个双向链表的示例：</font></font><br>
<br>
<pre><code class="plaintext hljs">struct ListItem<font></font>
{<font></font>
    &lt;…   …&gt;<font></font>
    List *pNext;<font></font>
    List *pPrev;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，列表本身是执行这些元素操作的特定（子）程序。</font><font style="vertical-align: inherit;">通常，已知指向列表开头和结尾的指针：从第一个元素开始，就可以遍历其所有元素到结尾。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，我正在描述已经研究透彻且众所周知的信息：对于那些完全不知道的人来说，这是一个教育计划。</font><font style="vertical-align: inherit;">例如，有关详细信息，您可以在这里联系：</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线性列表（Wikipedia）</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
STL库具有如此出色的容器std :: list（双向链接列表），以及其孪生子-std :: forward_list（单链接列表）。</font><font style="vertical-align: inherit;">也就是说，如果您对列表的组织方式和内部功能不感兴趣，而只想将其用于任务，则可以选择建议的容器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是有一件事但是...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多线程问题</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我重复一遍，当我开始分析该主题时，我将做所有事情，仅依靠C ++内部工具而不提供任何STL支持。</font><font style="vertical-align: inherit;">如果我仍然决定在这里谈论它，那么所发生的事情的价值就会更低。</font><font style="vertical-align: inherit;">但是另一方面，我完全不受库的任何概念或限制的约束，因此不受任何约束，并寻求开放思维和独立性的方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前，在遥远的过去，绝大多数计算机是单核和单处理器的。线性列表是一个相对简单和透明的数据结构，使用它不会引起任何特殊困难。现在，即使智能手机也已成为多核。在多线程条件下，甚至链表之类的简单结构也非常复杂。确保多线程模式下的正确操作通常会严重使任何程序复杂化，这是众所周知的事实。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以密集工作的抽象场景为例，列出了不同的线程：每个线程都可以在完全任意的时间点添加，删除，更改元素等。一方面，在这种情况下使用列表应该首先是安全的：如果有任何数据冲突和程序的未定义行为，这将是完全不合适的解决方案。另一方面，我非常想尽快与他合作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要解决第一个问题，显然必须以某种方式阻止该列表，并同步对其的访问。第二个问题-性能-现在推迟了。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文仅考虑通过流阻止整个列表，以便对其进行独占访问。例如，由于以下原因，其他选项似乎令人怀疑。假设我们有一个双向链表，我们决定从其中删除该项目。为此，您必须阻止节点本身以及上一个和下一个节点。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此时，在操作开始之前，另一个线程仅删除了前一个节点。我们阻止删除的那个，并停止等待被另一个线程阻止的前一个节点的释放。并且他被阻止等待下一个等待他，即我们删除的节点。就是这样，这是一个僵局。因此这种方法不可靠。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您的线程没有存储指向特定节点的任何指针（或迭代器），则该任务将大大简化。实际上，您只能使用STL工具。流会阻止列表，引用列表中的任何元素（例如，从头开始，从头开始或通过根据某些条件对其进行搜索），处理或删除此元素，添加任何新元素而不保存链接，然后完成列表。所有这一切-仅在一个线程中阻止对列表的访问，并在所需操作的持续时间内拥有该列表。在这种情况下，使用std :: list和库锁定功能是完全合乎逻辑的。对于所有这些，应该注意的是，尽管您的线程完成了所有必需的工作，但其他线程将停止等待，即使用列表的工作将在单线程模式下进行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当线程将指针或迭代器存储到所需元素时，我考虑了另一种更为复杂的方案。</font><font style="vertical-align: inherit;">例如，您的程序进行一些复杂的计算，从列表项中获取初始数据，然后在处理后更新其值，并在其中添加计算结果。</font><font style="vertical-align: inherit;">但是，其他线程也可以访问同一列表。</font><font style="vertical-align: inherit;">我没有对应用程序的性质做任何假设：由于某种原因，另一个线程可以轻松删除此元素。</font><font style="vertical-align: inherit;">或将其移动到另一个地方。</font><font style="vertical-align: inherit;">因此，不仅由于多线程和同步的常见原因，使用列表也成为问题。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元素存在的问题</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
列表和数组之间的根本区别是什么？以</font><font style="vertical-align: inherit;">列表项</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分布式</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">排列。数组的所有元素都位于单个存储区中。即使存储指向其某些元素的指针，也可以确保对其地址的访问是正确的（当然，例如，如果数组未在内存中移动到具有其大小扩展名的其他位置）。如果您需要的元素被删除或移至另一个线程，则只需转到先前的地址，您会通过一些迹象了解到您所需的元素不在此处，然后尝试搜索，等等。当然，该计划必须提前支持这样的机会。但是，无论如何，只要您处于正确的内存限制内，它的操作就将保持正确。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
列表（以及树，图-具有分布式元素的任何数据结构）的情况完全不同。如果根据指针的元素在另一个线程中被删除，您甚至都不知道它，并且如果您尝试访问其地址，则将收到访问冲突（充其量）。即使实际上并没有从内存中删除它（例如，如果使用了智能指针），也将从列表中删除它，即不会成为它的一部分。您也不知道这一点。列表的正确工作已损坏。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同时，使用大量的多线程处理该列表会创建绝对出色的方案。您甚至可以确保元素和指向它的一切都很好-直到访问一些使用列表函数。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例。设列表的一部分，并将指向节点的指针（我们称为（＃））传递给某些函数列表方法，与此相关的节点将使用相对于其的相对编号表示。在调用该函数时，已知此元素存在并且指向它的指针正确，也就是说，该区域中列表的状态为：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让节点（＃）作为参数传递给某个列表函数。与往常一样，此功能在等待访问时被阻止。当她等待时，三个线程在她之前工作，删除了节点（＃）以及相邻的节点，以便它发生了：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yx/cx/x8/yxcxx8a21cbn2zlzko2uxgfzsb8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，另外5个线程将​​另外5个元素插入到列表中，从（-2）开始。我们将新元素表示为（nN），其中N是五个从零开始的相对数字：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，我们的流被调用，并用（＃）调用。问题是：在（＃）早已消失之后，在这种情况下他应该怎么做？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
答：这完全取决于操作以及使用列表的方案。但是，由于我们正在考虑最一般的情况而没有任何限制，因此可以做出一些一般性的假设。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果这是一个删除操作，那么只需检查指定的项目是否在列表中就足够了。如果不是，则它已被删除，无需执行其他任何操作。如果是，则删除。同样，对于读取/更改节点内容的操作：如果删除了该节点，则已经没有任何内容可读取/修改。但是最大的问题出现在插入新节点的操作以及移动到下一个/上一个节点时。一方面，指定的节点不再存在，并且可以返回故障。另一方面，必须插入节点，并且这种情况随时可能发生。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于优先级（通常情况下）仍然是安全性和可靠性，只有速度才是优先级，很明显，当线程最终获得函数内部的运行时间时，您必须确定列表中是否存在元素的事实：它甚至不存在吗？这解决了一个问题：如果那里没有请求的节点，至少我们不会破坏整个列表，并且在这方面我们将避免内存访问错误。但这并不能解决插入和过渡的问题：不清楚在哪里插入新节点并从已经删除的节点开始。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下面将详细讨论该元素存在的问题的解决方案。</font><font style="vertical-align: inherit;">当我们发现该元素不再存在但非常需要该元素时该怎么做的问题超出了本文的范围，因为它完全取决于使用列表程序的工作算法。</font><font style="vertical-align: inherit;">当然，它应该包括这样的场景和对它们的相应反应：例如，如果没有元素，则转到列表顶部或执行其他操作。</font><font style="vertical-align: inherit;">在这种情况下，需要确保的主要内容是列表的正确和安全操作以及此类情况的通知。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接项目搜索</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最简单，最直接的方法是通过顺序搜索列表中的某个元素以查找给定元素，从而检查列表中某个元素的存在。那些。只是在寻找给定的元素。如果他在名单上，我们将与他合作。如果不是，则根据功能，我们以成功还是失败退出，然后让调用程序决定在这种情况下该怎么做。最主要的是，在任何情况下，使用该列表都是正确的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种方法是安全且功能齐全的，但是，特别是对于大型列表，它会导致性能的灾难性下降。实际上，使用列表实际上是单线程的：在搜索列表中给定元素期间，该列表被阻止，其他线程无法访问它。其次，管理费用大幅增加-在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用列表进行的操作必须检查操作时是否需要一个元素，并且有很大一部分时间不是花在有用的工作上，而是在检查元素的存在。</font><font style="vertical-align: inherit;">但是，这种简单，直接的方法非常适合于小批量的列表，并且操作起来不太费劲，并且非常适合解决元素存在的问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，如果我们有一个包含大量元素的列表，并且使用起来非常费劲：那么许多线程会不断地从中添加，更改和删除元素吗？</font><font style="vertical-align: inherit;">有什么办法可以加快速度吗？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记忆力或表现</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
众所周知，程序使用的内存增加可以提高程序速度。例如，一个程序大量使用了一些计算结果。您无需预先执行所有操作，而是可以预先计算所有内容并将其结果保存在某个表或数组中。然后，程序仅访问表中的所需单元格并立即接收所需值，从而大大加快了工作速度。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我在列表的情况下就是使用这种方法。创建一个位图。除了指向下一个以及可选的上一个元素的强制指针之外，我们还将其每个元素的服务信息添加到另外两个新字段中：第一个是此列表中其唯一的编号，第二个是指向列表本身的指针。现在，在创建元素时，将为其分配一个唯一的编号，并将位图中的单位设置为相应的索引。删除元素后，该位将重置。每次创建新元素时，创建元素的数量一直在增加-已经使用过的零位将不会被重用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，当需要检查给定元素的存在时，而不是在整个列表中线性搜索它时，仅通过该元素在其中的索引访问位图，无论列表的大小如何，都可以在固定时间内立即确定其存在的事实。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种方法可以使您获得最大的性能，但是它有严重的缺点。首先，您将必须立即为整个阵列分配内存，在程序执行过程中可能根本不需要一部分存储空间，但是该内存可用于其他需求。下面将讨论此问题以及消除内存溢出的方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个缺点是更加严重和有趣-每个新列表项都是由单调递增的数字创建的。这意味着或早或晚将耗尽阵列的可用位。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不幸的是，此时您必须停止，阻止该列表并开始为其提供服务。那些。压缩此数组的位，从先前删除的中间列表项中删除所有零位，仅保留当前实际存在的元素的位，然后将所有这些位移到数组的开头。我们将不得不再次遍历整个列表，并以单线程模式重写每个元素的所有索引。与以前的方法相比，此方法的明显好处是在这种情况下将仅执行</font><b><font style="vertical-align: inherit;">一次</font></b><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">长时间 </font><font style="vertical-align: inherit;">此外，该列表可以在极快的模式下继续像以前一样工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，我并不是说仅将节点添加到列表中，因为 </font><font style="vertical-align: inherit;">在这种情况下，数组的所有位将为单个。</font><font style="vertical-align: inherit;">我正在考虑一种方案，其中会密集地任意删除和添加项目。</font><font style="vertical-align: inherit;">那些。</font><font style="vertical-align: inherit;">从开始工作起，列表项的总数可能会略有变化。</font><font style="vertical-align: inherit;">自然，选择数组大小的问题取决于程序的性质。</font><font style="vertical-align: inherit;">如果当前卷的大小不够，您也可以始终创建一个更大卷的新数组。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用先前删除的元素中的零位</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以用另一种方式来实现：创建元素时，从位图的开头查找第一个零位。这样可以优化内存消耗，但是会导致性能下降：现在，每次创建新元素时，您都将不得不做其他工作-遍历数组以寻找空闲位。但是与通过直接查看列表检查元素是否存在相比，收益显而易见：我们将看一下</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相邻元素，并且此数组的每个元素都包含许多位，即 </font><font style="vertical-align: inherit;">我们一次处理许多列表节点（对于现代系统为64位，如果使用SSE / AVX，甚至为128/256/512）。</font><font style="vertical-align: inherit;">我们正在寻找不等于具有所有单位位的词的第一个词，然后我们正在寻找该词的第一个零位。</font><font style="vertical-align: inherit;">实际上，该方法的速度介于前一种方法和直接查看方法之间。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空闲阵列位的内存消耗优化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设我们对列表进行了长时间而密集的工作，并为此列表分配了大量位。但是碰巧的是，实际上程序的工作方式有所不同：它很少访问列表，执行其他需要内存的操作。结果，在程序的其他部分，我们得到了几乎未使用的大容量和内存问题的位数组。不便之处！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
据我所知，Linux自动解决了这个问题（尽管有经验的Linux开发人员让我进行了修复）。您为阵列分配了内存，但实际上，系统</font><font style="vertical-align: inherit;">直到真正需要时才将其</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转移</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到阵列</font><font style="vertical-align: inherit;">。优化了内存使用。 Windows不允许这样做。相反，它允许，但是您必须自己做。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于那些还不是最新的人，我将解释：您的应用程序（更准确地说，是与之对应的进程），系统会分配</font><font style="vertical-align: inherit;">较大的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虚拟地址空间</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -对于64位Windows </font><font style="vertical-align: inherit;">，该</font><b><font style="vertical-align: inherit;">虚拟地址空间</font></b><font style="vertical-align: inherit;">最多为8 TB。系统中的物理内存可能要少得多-目前对于大型计算机而言为8或16 GB。操作系统</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虚拟进程空间的地址到物理内存的地址，以透明的方式进行，而无需您的直接参与。自然地，一个进程的大多数空闲虚拟内存通常是不被占用的。因此，当您要求Windows通过常规方式分配内存时，它会同时在虚拟空间和物理内存中分配此内存。如果分配大量位图，则可能会立即占用计算机上的所有可用内存，而不能保证完全需要此内存。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，人们可以采取不同的行动：在进程的虚拟空间中标记很大一部分内存，但是仅在确实需要时才将物理内存转移给它。</font><font style="vertical-align: inherit;">这可以通过Windows中的结构异常处理来完成；有关详细信息，请参阅Richter D.，Nazar K.的书-“通过C / C ++进行Windows，Visual C ++编程”。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实作</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我没有将所有这些想法付诸实践，并且不是以简单的实验程序的形式，那将仅仅是一个想法和一个理论：我在生产中尽可能地认真地进行了此工作，并打算在我的实际项目中使用它，因此您需要这种形式的东西和想象。</font><font style="vertical-align: inherit;">我认为，如果它对许多开发人员有用或至少只是有趣的话，那么将我在有限数量的项目中所做的事情应用于工作将是不公平且过于自私的。</font><font style="vertical-align: inherit;">另一方面，Boost库和其他更专业的库的创建者绝对免费地向所有人提供他们的作品。</font><font style="vertical-align: inherit;">为什么我不能这样做？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象-没有数据的列表</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将列表分为两个逻辑级别。第一级是列表，其每个元素不包含任何有用的数据，而仅包含辅助信息：指向相邻元素的指针，以及（可选）这两个附加字段，以加快检查列表中元素的存在。但是，已经在此级别上可以对列表执行所有基本操作：添加和删除元素，拆分和合并列表等。实际上，我主要专注于此级别。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二级是将实际数据添加到列表项，以及将新操作添加到列表以使用此数据。所有这些都通过继承在C ++中提供。但是细节将在下面讨论。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样将实现分解为两个级别是有意义的：如果整个系列的操作绝不依赖于这些数据，为什么还要考虑特定数据的可用性呢？对于任何给定的列表项，您仍然必须删除它们并将新项添加到列表中，以及执行其他典型操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我从一个非常简单而不复杂的概念开始，该概念取自本文开头的C语言构造，在列表的内部和外部都使用了C和C ++内部指针。唯一的不同是，如上所述，数据的添加被推迟到以后的日期。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
令列表中的某个元素不包含数据，仅包含指向相邻元素的一个或多个指针。然后，它的相应代码可以如下所示：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span>	<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListElement_OneLinked</span>			//   ( )
{</span>
	ListElement_OneLinked *pNext;	<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>		// 
{</span>
	<span class="hljs-comment">//</span><font></font>
<font></font>
        <span class="hljs-comment">//   </span>
	ListElement *pFirst = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span>
	ListElement *pLast = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span><font></font>
<font></font>
	SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//    </span><font></font>
<font></font>
	&lt;…m- () &gt;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
单链列表的元素本身包含指向下一个元素的指针，仅此而已。列表类由该元素的类型参数化，这意味着在添加数据的阶段将更改此类型。它包含指向其中的第一个和最后一个元素的指针。由于我最初仅将此项目定位于Windows，因此还包括了SRWLock之类的关键部分以阻止该列表。接下来，定义构造函数，析构函数以及使用列表的所有必需函数。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此实现一次包含两个问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先是对元素的服务信息内容的开放访问。这意味着获得访问某个节点的权限，即具有指向该节点的指针，我们可以直接引用下一个或上一个元素。</font></font><br>
<br>
<i>       <b></b>.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是不可接受的，主要是因为此转换绕过了锁定，因此保护了列表。实际上，假设有一个指向某个pCurr元素的指针，我们将值保存到pNext指针中与其相对的下一个元素，如下所示：pNext = pCurr-&gt; pNext。之后，我们对该pCurr节点执行一些冗长的操作。同时，其他线程删除了有关pCurr的以下列表项。完成pCurr的工作后，当前线程使用存储在本地pNext中的旧值移动到下一个元素，并收到访问错误或未定义的行为，因为本地pNext地址处的元素不再存在，并且您需要访问更新后的值pCurr-&gt; pNext，如果当前项目位于pCurr，也仍然存在。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从此示例可以得出两个结论来防止这种情况：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从列表外部转到下一个/上一个节点，通常仅通过锁定列表并确保对列表的访问安全的列表类的函数（方法）来对列表元素进行任何操作；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在访问元素之前立即对其进行访问（例如，获取指向下一个元素的指针pNext = list.GetNext（pCurr）并非事先，而是在需要移动至下一个节点之前）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就是为什么为了实施第一段的结论，应禁止从外部访问指向相邻元素的指针：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement_OneLinked *pNext;		<span class="hljs-comment">//    	</span><font></font>
<font></font>
<span class="hljs-keyword">friend</span> List_OneLinked;    <span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个问题更加棘手。为了理解它，应该更详细地描述类的结构。列表类被定义为模板，不适用于ListElement_OneLinked类型的元素，但与ListElement类型一起作为模板参数传递。这样做是为了能够使用类中的数据创建新节点。为此，您需要知道要创建的节点的确切类型。列表节点的确切类型尚不清楚：稍后将与数据一起确定。元素创建函数为其分配内存，初始化指针，然后将指针返回到调用函数中创建的元素。因此，在派生类的调用函数中，可以初始化该类特有的元素的其他属性，以后再定义。换一种说法，列表节点的类型的确切定义留待将来使用，为了使列表正常运行，仅重要的是其元素包含pNext指针，其余的都无关紧要。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，基于ListElement_OneLinked，随后通过继承，将为具有特定数据的元素创建一个新类，并通过template参数将其传递给List_OneLinked类。同时，将基于List_OneLinked创建一个新的派生类，该类进一步定义对此新数据的操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，即使此选项也不是完全正确的。在列表类的早期版本中，多次使用了reinterpret_cast &lt;ListElement *&gt;（...）类型的显式转换操作。事实是，模板类使用ListElement模板参数类型，该参数类型是从ListElement_OneLinked / ListElement_TwoLinked派生的。在类函数中，将在以下类型的表达式中创建变量：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ListElement * pNext = pCurr-&gt; pNext;</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pCurr-&gt; pNext此处是指向ListElement_OneLinked / ListElement_TwoLinked的指针，它们是基类的成员。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
输出：声明一个变量，该变量指示显式基本类型ListElement_OneLinked / ListElement_TwoLinked，或将其显式转换为派生类型。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，即使是基本类型的显式定义也不正确，例如，在列表删除（清除）函数中：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   </span><font></font>
ListElement *pCurr = pFirst;<font></font>
ListElement *pNext = <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
{<font></font>
	pNext = <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr-&gt;pNext);
	<span class="hljs-keyword">delete</span> pCurr;<font></font>
	pCurr = pNext;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果更改指针的类型：</font></font><br>
<br>
<pre><code class="cpp hljs">ListElement_OneLinked *pCurr = pFirst;<font></font>
ListElement_OneLinked *pNext = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这意味着它们将被操作删除</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> pCurr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仅列表中每个节点的基础部分，这是错误的。</font><font style="vertical-align: inherit;">或者，作为一种选择，pCurr指针将必须转换为其派生类型：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，无论如何，使用这种类结构都无法摆脱显式的reinterpret_cast转换，这不是最佳解决方案（更确切地说，这确实很糟糕）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，为了摆脱这种显式转换，决定更改元素的基类（对于双链表-类似）：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement *pNext;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">friend</span> List_OneLinked&lt;ListElement&gt;;	<span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
简而言之，它可以描述如下：列表的基本元素包含一个指向另一个元素的指针，但是该指针的类型尚不清楚，因为它是由template参数传递的（将来会保留此类型的确切定义）。换句话说：在此阶段，列表节点的类型（即最后的列表节点）尚未确定，稍后将确定。但是现在，我们保留了指向将来某个未知类型的元素的指针。列表节点的结果类型在此处作为模板参数传递。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，无需转换，因为在列表类和节点类中到处都使用了相同ListElement类型的指针。这里和列表类中的ListElement是具有特定数据的项目的最终类。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这意味着列表类现在已从其特定内容变得尽可能抽象：仅知道其节点包含指向其他此类节点的指针，并使用此信息在列表类中执行对其上具有相应多线程锁的所有基本操作。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决元素存在的问题-简单搜索（2018年1月3日版）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一个版本非常简单明了，并且没有超出上述框架的范围。</font><font style="vertical-align: inherit;">使用了C ++内部指针，使用新操作分配了元素的内存，并使用delete删除了元素，列表在其中包含的关键部分被阻止。</font><font style="vertical-align: inherit;">我不了解或怀疑STL库的功能，也不了解它们在C ++中带来编程的水平。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，在这个阶段，我已经遇到了前面描述的元素存在的问题，并意识到仅锁定列表是不够的。</font><font style="vertical-align: inherit;">我在使用所有预防措施的情况下使用适当的功能浏览了该列表，该列表已被正确阻止，但该程序仍在不同时间间隔成功崩溃。</font><font style="vertical-align: inherit;">那时我发现必须检查一个元素的存在，这导致了关键功能逻辑的改变。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我举一个在给定元素后添加元素的功能的示例：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">ListElement* <span class="hljs-title">AddAfter</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-title">throw</span> <span class="hljs-params">(FailElemCreation, Nullptr, NotPartOfList)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();			<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListExclusive();<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (!FindElement(pElem, <span class="hljs-literal">true</span>))<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
	}<font></font>
<font></font>
	ListElement *pCurr = <span class="hljs-keyword">new</span> ListElement;
	<span class="hljs-keyword">if</span> (!pCurr)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> FailElemCreation();		<span class="hljs-comment">//        </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (pFirst == <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		pFirst = pLast = pCurr;<font></font>
		pCurr-&gt;pNext = <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
	<span class="hljs-keyword">else</span><font></font>
	{<font></font>
		<span class="hljs-comment">//         </span><font></font>
		ListElement *pNext = pElem-&gt;pNext;<font></font>
		pElem-&gt;pNext = pCurr;<font></font>
		pCurr-&gt;pNext = pNext;<font></font>
		<span class="hljs-comment">//,     </span>
		<span class="hljs-keyword">if</span> (pElem == pLast)<font></font>
			pLast = pCurr;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListExclusive();<font></font>
<font></font>
	<span class="hljs-keyword">return</span> pCurr;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以看出，在创建新元素之前，它将通过调用FindElement（...）函数来检查列表中是否存在指定的元素：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FindElement</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-title">throw</span> <span class="hljs-params">(Nullptr)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();	<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span><font></font>
	ListElement *pCurr = pFirst;<font></font>
	<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (pCurr == pElem)<font></font>
		{<font></font>
			bResult = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">break</span>;<font></font>
		}<font></font>
		pCurr = pCurr-&gt;pNext;<font></font>
	}<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">return</span> bResult;<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多线程列表类的进一步复杂-策略类（版本18.02.2019，11.27.2019）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初，该项目严格针对Windows。但是我想在某个时候，为什么不增加灵活性呢？为什么只有窗户？毕竟，该列表实际上是用纯C ++实现的，而从Windows来看，它只有一件事：SRWLock的关键部分。到那时，我已经熟悉了策略类的概念。您可以在Alexandrescu A.-“ C ++中的现代设计”一书中详细了解此内容。它描述了许多不寻常且令人惊奇的事情，即使这本书已经有12年的历史了，即使到现在也仍然有用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
策略类别就是其中之一。实际上，策略类是通过模板改变类的行为，正如斯特拉斯特鲁普（B. Straustrup）在他的著名著作中提到的那样。仅在Alexandrescu的书中，这个主题才被广泛披露。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设您的班级执行一项特定的操作。</font><font style="vertical-align: inherit;">您可以在类之外获取此操作的定义，根据该操作创建一个单独的类，并将其作为模板参数传递给源类。</font><font style="vertical-align: inherit;">这使代码，其阅读和理解变得复杂，但是它极大地增加了您的类的灵活性：要用其他类似的动作替换此特定动作，您只需编写另一种类似的策略并将其作为模板参数传递给您的类。</font><font style="vertical-align: inherit;">其余工作将由编译器完成。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">锁定策略</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将其应用到描述的列表中，我通过SRWLock将锁带入了一个单独的策略，然后编写了其他一些策略：通过Windows的通常关键部分，通过C ++ STL互斥锁等。</font><font style="vertical-align: inherit;">这样就有可能添加纯Linux特定的方法。</font><font style="vertical-align: inherit;">因此，该类不仅适用于Windows，而且只要指定所需的策略，我始终可以以最佳方式迅速将其重新配置为Windows。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//    SRWLock</span>
<span class="hljs-comment">//     SRWLock -   ,      (      </span>
<span class="hljs-comment">//   : ++11)</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLockingWin_SRWLock</span>			//    <span class="hljs-title">SRWLock</span>
{</span>
	<span class="hljs-keyword">mutable</span> SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//     SRWLock</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ThreadLockingWin_SRWLock(<span class="hljs-keyword">bool</span> bInitialize = <span class="hljs-literal">true</span>)<font></font>
	{<font></font>
		<span class="hljs-comment">//; bInitialize -  ,     </span>
		<span class="hljs-keyword">if</span>(bInitialize)<font></font>
			InitializeSRWLock(&amp;csSRW);		<span class="hljs-comment">//   SRWLock</span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Lock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>						<span class="hljs-comment">//  </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Unlock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//  </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记忆策略</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这一点上，我还认真地开始研究STL，并且在该库的第一个工具中，我熟悉了智能指针。</font><font style="vertical-align: inherit;">然后我想：为什么我不能在列表中添加智能指针支持？</font><font style="vertical-align: inherit;">然后，我取出了指针的类型，并在单独的策略中创建和删除列表项的数据：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        C/++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>   <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type[]&gt;   //   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type[size];
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>	  <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span> ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span>[] ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = Type * ;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;			<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = ptrType;		<span class="hljs-comment">//   </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-comment">// : Args - -     Type</span>
		<span class="hljs-comment">// :      Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//   ,       </span>
		<span class="hljs-comment">// : pObject -      , DeleterFunc -   -</span><font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pObject)<font></font>
		{<font></font>
			Deleter::Delete(pObject);		<span class="hljs-comment">//     </span>
			pObject = <span class="hljs-literal">nullptr</span>;<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> &amp;obj;<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
智能指针的类似策略：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        shared_ptr/weak_ptr ++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type&gt;(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type[]&gt;(size);
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;					<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;						<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;				<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = <span class="hljs-built_in">std</span>::weak_ptr&lt;Type&gt;;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      ;   -  ,    ,    </span>
		<span class="hljs-comment">// </span>
		Deleter::Delete(pObject);	<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;(&amp;obj);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内存策略采用三个参数：Type对象的类型以及内存分配器和删除器。根据对象的类型，策略根据策略创建指向该类型的指针的类型-Type *或std :: shared_ptr，还提供用于创建和删除对象的相应功能。这些函数，如果我们默认谈论分配器和删除器，则可以通过新的Type操作或通过std :: make_shared（...）函数来创建对象。由于C ++内置指针和智能std :: shared_ptr的指针解引用是相同的，因此所有这些工作均有效。当然，在双链表和智能指针的情况下，为避免循环指针的令人讨厌的功能，std :: weak_ptr用于指向前一个元素的指针，然后在双链列表的编译时，根据所选的内存策略，选择如何取消引用它（这是C ++ 17的新功能）：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  pPrev  weak_ptr,          shared_ptr    lock()</span>
<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, SmartSharedPointer&lt;ListElement&gt;&gt;)</span>		<span class="hljs-comment">//C++17: if constexpr</span>
	pFirst-&gt;pPrev.<span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>= <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">else</span>
	pFirst-&gt;pPrev = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，该列表现在不会创建其自己的元素：它将调用重定向到相应的策略。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物品供应策略</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，我将元素存在的问题的解决方案放在单独的策略中：如果列表需要检查其某些元素的存在，则只需将调用重定向到相应的策略。最初的，直接且笨拙的方法已成为DirectSearch直接搜索策略。接下来，我根据前面介绍的两种方法，按照位图的描述顺序，开发了另外两种策略：SearchByIndex_BitArray和SearchByIndex_BitArray2。对于Windows，为了在位图填充时逐渐占用位图的可能性，他还添加了另外两种策略：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SearchByIndex_BitArray_MemoryOnRequestLocal和SearchByIndex_BitArray2_MemoryOnRequestLocal。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如前所述，要使这些高级策略起作用，列表项必须在位图中包含索引和指向列表基类的指针（请参见下文）。</font><font style="vertical-align: inherit;">定义如下：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//          </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked_CP</span>			//   ( )
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext;	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex;	<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt; *pList;		<span class="hljs-comment">//  - </span><font></font>
<font></font>
	<span class="hljs-comment">//          ;    ,   </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span><font></font>
<font></font>
	<span class="hljs-comment">//    "+" </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt; <span class="hljs-title">operator</span>+&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;(<span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;, <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;) <span class="hljs-title">noexcept</span>;</span>	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-comment">//        </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">DirectSearch</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray2</span>;</span>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记忆策略和元素检查策略之间的相关性</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
经过详细检查，结果发现内存策略和检查元素存在的策略之间的关系存在陷阱。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设您将智能指针用作存储策略，以及将位图用于快速检查列表中项目的策略。您删除一个项目，内存策略将重置其指针。但是，实际上不会从内存中删除此元素，因为在调用程序中还有另一个指向它的智能指针。将来，您将使用带有此元素的列表，它会参考其数据-位图中的索引和指向列表的指针正确进行检查。实际上，仅当不再有链接到某个元素时，该元素才会从内存中删除。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用C ++内置指针时不是这种情况。在这种情况下，内存策略</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将使用删除操作从内存中删除该项目。将来，与前面的情况一样，您将使用此元素来引用列表，并且它将尝试</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此地址处的元素，以便读取位图的索引和指向列表的指针。但是您无法执行此操作：某个元素已从内存中删除！最好的情况是，当C ++库，运行时库或仅操作系统在此处写入列表考虑的完全任意值并尝试从列表中确定列表中存在某个元素的事实时，您将收到访问冲突，这是最糟糕的未定义行为。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，事实证明内部指针仅与DirectSearch直接检查策略兼容，在这种情况下，智能指针不仅提供其固有的安全性，而且还提高了性能：只有使用它们，才能使用位数组，从而显着增加列表的工作量。多线程模式！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了确保一致性并消除不兼容的策略配置，我在每个列表类中包括以下检查：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,    ++ (Type *)          (DirectSearch)</span>
<span class="hljs-keyword">static_assert</span>(!(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, InternalPointer&lt;ListElement&gt;&gt; == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElement, <span class="hljs-literal">false</span>&gt;, DirectSearch&lt;ListElement, <span class="hljs-literal">false</span>&gt;&gt; == <span class="hljs-literal">false</span>), <span class="hljs-string">"Internal C++ pointer memory policy can be used only with DirectSearch policy."</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它比较传递给列表的策略类，如果它们不兼容，则停止编译并显示相应的错误消息。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异常或错误返回</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初，列表错误处理仅通过异常进行。</font><font style="vertical-align: inherit;">但是以某种方式，在我不记得的某个论坛上，我读到异常会减慢程序速度，并且为了获得最佳性能，您应该使用传统的错误返回。</font><font style="vertical-align: inherit;">他通过在原始类的基础上创建两个新类来做到这一点，只重写它们以返回错误。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列出基类</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上述用于检查元素是否存在的策略的实施揭示了一个重要问题。我们记得，列表元素除了包含此列表中唯一的数字外，还包含指向该列表的指针：毕竟，我们在程序中可以有两个或更多列表，每个列表都包含自己的标志位数组，以表示该元素的存在。如何确保此元素属于此特定列表而不属于另一个列表？仅通过将指向整个列表的指针存储在每个元素内。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在的问题是，通过在列表类中添加各种策略，我们大大复杂了其</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。假设我们有两个不同的列表，它们具有相同的元素类型和相同的存储策略，但是具有不同的策略来锁定和检查其中的元素。对于编译器，这些将是两种不同</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列表。指向要存储在元素中的类型的指针？而且，该元素的类不预先知道将应用哪种策略，因此必须考虑</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些策略</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还回想一下阻塞策略，检查元素是否存在的策略，甚至列表的连接性（简单连接或双重连接）仅指列表本身的行为，而与它存储的</font><b><font style="vertical-align: inherit;">数据</font></b><font style="vertical-align: inherit;">无关</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，作为此类的最终用户，我们对数据感兴趣！</font><font style="vertical-align: inherit;">因此，一方面，使用策略类别，我们为自己增加了灵活性，另一方面，我们使生活复杂化并增加了问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是否有可能以某种方式使狼饱满而绵羊安全呢？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
能够。</font><font style="vertical-align: inherit;">您可以从列表的类（即，从类型）推断指向数据的指针。</font><font style="vertical-align: inherit;">除了上面列出的列表的两个组织级别之外，还出现了一个-0：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListBase</span>
{</span>
	<span class="hljs-keyword">using</span> ptrListElement = <span class="hljs-keyword">typename</span> ListElement::MemoryPolicy::ptrType;		<span class="hljs-comment">//             </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:<font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	ptrListElement pFirst{ <span class="hljs-literal">nullptr</span> };<font></font>
	ptrListElement pLast{ <span class="hljs-literal">nullptr</span> };<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，因为 </font><font style="vertical-align: inherit;">列表的真实类是从其继承的，如果我们要访问列表数据而不考虑其实际类型，则应引用其基类ListBase。</font><font style="vertical-align: inherit;">我们可以访问列表的开头和结尾，然后根据需要使用其数据。</font><font style="vertical-align: inherit;">列表的具体类型以及其中使用的策略组合都无关紧要。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">迭代器</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我已经在一个真实的项目中（而不是我的:)与STL紧密合作，并且继续在书籍中对其进行研究，我提请注意集合中的for循环。</font><font style="vertical-align: inherit;">毕竟，该循环不仅仅是STL的一部分，它已经成为该语言的内部部分。</font><font style="vertical-align: inherit;">我以为我也可以在我的项目中添加对此的支持。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，您需要添加对迭代器的支持，从使用指针和在列表中导航的特定方式中抽象出来。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
迭代器示例：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListIterator</span>		//    
{</span>
	ptrListElement pCurrElement{ <span class="hljs-literal">nullptr</span> };					<span class="hljs-comment">// ,    </span>
	<span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//  ,    </span>
	<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>;								<span class="hljs-comment">// ,     </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListIterator() {}<font></font>
	ListIterator(ptrListElement pElem, <span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>)
		<span class="hljs-keyword">noexcept</span> : pCurrElement(pElem), pList(pList), bProtected(bProtected) {}<font></font>
	ListIterator(<span class="hljs-keyword">const</span> ListIterator&amp; li) <span class="hljs-keyword">noexcept</span> : pCurrElement(li.pCurrElement), pList(li.pList) {}<font></font>
<font></font>
	ptrListElement&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		ptrListElement&amp; pli = pCurrElement;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> pli;<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement != <span class="hljs-literal">nullptr</span>; }
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ptrListElement</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement; }<font></font>
<font></font>
	<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>++()		<span class="hljs-comment">// : ++it</span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
	}<font></font>
<font></font>
	ListIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span>								<span class="hljs-comment">// : it++</span><font></font>
	{<font></font>
		ListIterator itPrev = *<span class="hljs-keyword">this</span>;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> itPrev;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = (pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">if</span> (pList == <span class="hljs-literal">nullptr</span> || li.pList == <span class="hljs-literal">nullptr</span>)<font></font>
			bResult = !(pCurrElement == li.pCurrElement);<font></font>
		<span class="hljs-keyword">else</span><font></font>
			bResult = !(pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
};<font></font>
 ,       <span class="hljs-keyword">for</span>  ,       begin()  end():<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">begin</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">if</span>(!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span>
	<span class="hljs-function">ListIterator <span class="hljs-title">lit</span><span class="hljs-params">(ListBase&lt;ListElement&gt;::pFirst, <span class="hljs-keyword">this</span>)</span></span>;
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">return</span> lit;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">return</span> ListIterator();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在可以编写如下：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">using</span> List = ListData&lt;List_TwoLinked&lt;ListElement, ThreadLockingWin_SRWLock, SearchByIndex_BitArray, <span class="hljs-literal">true</span>&gt;, <span class="hljs-literal">true</span>&gt;;<font></font>
List <span class="hljs-built_in">list</span>;
<span class="hljs-keyword">try</span><font></font>
{<font></font>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; leValue : <span class="hljs-built_in">list</span>)<font></font>
          _tprintf_s(TEXT(<span class="hljs-string">"%I64u\n"</span>), leValue-&gt;u64Value);<font></font>
}<font></font>
<span class="hljs-keyword">catch</span>(…)<font></font>
{<font></font>
      …<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
leValue具有指向列表项的指针类型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初，我仅在受异常支持的列表上包括迭代器支持。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原因很简单：由于循环内的代码不可用，因此无法正确处理错误。</font><font style="vertical-align: inherit;">剩下的就是通过将循环包装在try块中来处理异常。</font><font style="vertical-align: inherit;">通常，在其他线程需要大量使用的情况下以这种方式遍历列表不是一个好主意：最好自己阻止该列表，然后在单线程模式下冷静地通过它。</font><font style="vertical-align: inherit;">但是，如果由于某种原因您想要做与上例完全相同的操作，那么现在就有机会这样做了。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于检查任意容器上元素是否存在的策略的一般化；</font><font style="vertical-align: inherit;">列表的迭代器，无例外</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，我最初计划（并且仍然计划）不仅制作多线程列表，而且制作树。对于他们的一些需求。该图也是可能的，但首先，我不需要它，其次，该图是具有非常平凡的算法的复杂事物，并且我不想在没有任何特殊需要的情况下深入研究它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在初始版本中，用于检查元素是否存在的策略仅针对列表，并且其功能接受指向元素的指针和指向列表的基类（ListBase *）的指针。随后，我想：但是对于一棵树，您必须做完全相同的事情！做一个单独的但实际上是完全相同的策略吗？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解决方案很简单：忽略列表。</font><font style="vertical-align: inherit;">这意味着现在输入将不是通过指向元素的指针而是通过迭代器接收的。</font><font style="vertical-align: inherit;">函数将变成样板，接受指向任何合适类型的容器的指针。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在是原始功能，例如在位图中注册列表</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RegisterList</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ListBase&lt;ListElement&gt;* <span class="hljs-keyword">const</span> pList, ptrListElement <span class="hljs-keyword">const</span> pStart, ptrListElement <span class="hljs-keyword">const</span> pEnd = <span class="hljs-literal">nullptr</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pList -   ,       , pStart -   ,</span>
	<span class="hljs-comment">//pEnd -   </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		ptrListElement pCurr = pStart;<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">while</span> (pCurr != pEnd &amp;&amp; pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
		{<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pList-&gt;pFirst);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pList = <span class="hljs-keyword">const_cast</span>&lt;ListBase&lt;ListElement&gt; *&gt;(pList);<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
			pCurr = pCurr-&gt;pNext;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
变成了容器注册功能：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Container, class Iterator&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterContainer</span><span class="hljs-params">(Container* <span class="hljs-keyword">const</span> pContainer, Iterator itStart, Iterator itEnd = Iterator{})</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pContainer -   ,       ; itStart -   </span>
	<span class="hljs-comment">//, itEnd -    </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = itStart; it != itEnd; ++it)<font></font>
		{<font></font>
			ptrElementType&amp; pCurr = *it;<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pContainer);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pContainer = pContainer;<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
指针通过列表进行的转换已使用迭代器转换为通过抽象容器进行的转换。</font><font style="vertical-align: inherit;">现在，树就足以实现其迭代器，并且已经提供了对这些策略的支持。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就要求将迭代器无一例外地返回到列表，但要使其从外部不可访问，并且只能供内部使用。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据适配器</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在与STL进行了非常深入的工作之后，并从书籍中键入，启动和学习了培训计划，我提请注意使用STL容器的简单性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，请注意以下代码：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = { <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : v)<font></font>
     i = <span class="hljs-number">1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我通过将向量传递给我所需的类型来创建向量，仅此而已！如果我不需要更改默认情况下设置的某些其他参数（大多数情况下通常不会发生），则容器可以立即开始工作！对我来说，从列表的三级组织开始，在每种情况下，我都必须首先为元素创建一个新类，然后为包含数据的列表编写一个类，以实现特定于最终列表的操作。想象一下有多少工作！而且，如果您需要为其他数据创建另一个列表，则必须重新做一遍，或者在极端情况下，请复制先前的代码，并稍作更改。这已经与C语言和Windows API相似，只需为每个基本操作填充结构所需的所有必要数据，然后调用所需的函数即可。并且要么记住这一切或者也经常阅读MSDN，研究每个新功能的论点！例行和非常不舒服！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我开始寻找机会，以类似于STL容器的方式创建列表，这样我就不必每次都做同样的事情：为任何新元素创建一个单独的类，然后为该元素创建一个单独的列表类类型。</font><font style="vertical-align: inherit;">因此，有一个用于包含数据数据列表的适配器。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
包含数据的列表的适配器是一个类，在该模板的模板参数中，您会立即传递所需的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">，而不是元素。</font><font style="vertical-align: inherit;">元素的类型，我称其为元素的复合类型，是根据</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它自己</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的数据而得出</font><b><font style="vertical-align: inherit;">的</font></b><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementCompound_OneLinked_CP</span>
{</span>
	ElementData ed;		<span class="hljs-comment">//</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> ListElement = ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;;
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... Args&gt; <span class="hljs-title">ListElementCompound_OneLinked_CP</span><span class="hljs-params">(Args... args)</span> : <span class="hljs-title">ed</span><span class="hljs-params">(args...)</span> </span>{}<font></font>
	ListElementCompound_OneLinked_CP(<span class="hljs-keyword">const</span> ElementData&amp; ed) : ed(ed) {}<font></font>
<font></font>
	ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ElementData</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex = <span class="hljs-number">0</span>;			<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt;* pContainer = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">//  - </span><font></font>
<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
值得一提的另一点是访问项目数据。</font><font style="vertical-align: inherit;">元素类型包含运算符“ *”：</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> ed;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这意味着，如果有一个指向pElement元素的指针，则要访问存储在其中的数据，必须将其取消引用两次：</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; li = **pCurrElement;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一次-通过其指针访问ListElementCompound_OneLinked类型的对象：ListElementCompound_OneLinked＆le = * pCurrElement，第二次-通过操作'*'访问数据：ElementData＆li = * le。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这看起来很奇怪而且很不典型，但是假设您不是通过指针（为此，初始版本已经准备好），而是通过迭代器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，在基于适配器创建列表时，请像以前一样指定所需的策略。</font><font style="vertical-align: inherit;">根据您的所有参数，适配器将自动创建必要的类型，并将其传递给基本内部列表，从该内部列表中继承该类型。</font><font style="vertical-align: inherit;">通用类定义：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span> = <span class="hljs-title">SmartSharedPointer</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span> = <span class="hljs-title">ThreadLocking_STDMutex</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span> = <span class="hljs-title">DirectSearch</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span> = <span class="hljs-title">true</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
列表的特殊化，但有以下例外：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>&lt;ElementData, _MemoryPolicy, LockingPolicy, CheckingPresenceElementPolicy, true&gt; :</span> 
<span class="hljs-keyword">public</span> List_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;, DirectSearch&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;&gt;, ListElementCompound_OneLinked&lt;ElementData, _MemoryPolicy&gt;, ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;&gt;, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">true</span>&gt;<font></font>
{<font></font>
	…<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它看起来非常笨重，多层且丑陋。我知道。但是，此定义会自动执行所需的所有操作，而无需计划使用它的程序员的直接参与。在std :: conditional_t和std :: is_same_v的帮助下，将检查您提交的元素是否存在的策略与直接搜索策略进行比较，并根据结果选择列表元素的相应类型：在位图中有索引，并且有指向列表的指针。如果您使用直接搜索策略，则由于每个节点内不必要的附加数据，这将节省您的内存。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在类内部，仅实现特定于其的迭代器，以及与STL类比所需的push_back（）/ push_front（）函数，该函数将调用重定向到基本多线程列表。</font><font style="vertical-align: inherit;">您可以稍后添加其他功能，以使列表与STL的列表非常相似。</font><font style="vertical-align: inherit;">但是同时，它将具有在多线程环境中提高生产率的所有必要保护和选项。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用数据适配器的工作开始像这样。</font><font style="vertical-align: inherit;">创建列表对象：</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;<font></font>
List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您对所有默认策略和参数都满意，那么创建列表将变得非常简单：</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>&gt; list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，在外观上与STL绝对没有区别，只是列表类的名称不同。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，您可以通过基类的功能像以前一样使用它：</font></font><br>
<br>
<pre><code class="cpp hljs">list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">2</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，从0到3的数字顺序地添加到列表的末尾。要获得在创建类型时传递给所创建类型的构造函数的参数，您必须明确地放下前三个参数的值。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> x = *list0.GetLast();			<span class="hljs-comment">//   ,   auto    ListElementCompound_TwoLinked_CP&lt;...&gt;</span>
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"x = "</span> &lt;&lt; x &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是的，在显式指示类型方面存在一定的不便，但这是尝试通过使用指针的先前函数再次访问列表的结果。</font><font style="vertical-align: inherit;">如果将back（）函数添加到返回迭代器的适配器中，则通过它进行操作将不会遇到这样的问题：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> x = *list0.back();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在将迭代器调整为STL的要求之后：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   STL</span>
<span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;
<span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">const</span> ElementData;
<span class="hljs-keyword">using</span> difference_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">ptrdiff_t</span>;
<span class="hljs-keyword">using</span> pointer = <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> List::ptrListElement;
<span class="hljs-keyword">using</span> reference = <span class="hljs-keyword">const</span> ElementData&amp;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以在库算法中使用列表：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; dElem : list1)
	<span class="hljs-built_in">cout</span> &lt;&lt; i++ &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; dElem &lt;&lt; <span class="hljs-built_in">endl</span>;<font></font>
transform(list1.begin(), list1.end(), list1.begin(), [](<span class="hljs-keyword">double</span>&amp; dElem1)<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> dElem1 * dElem1;<font></font>
});<font></font>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(list1.cbegin(), list1.cend())</span></span>;<font></font>
…<font></font>
copy(v.begin(), v.end(), list1.begin());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，您将必须组织对异常的拦截和处理：以上所有示例都是在一个线程中工作的，以便测试与STL的兼容性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
STL算法的使用使一个有趣的观点成为可能：您可以一次使用多种算法，并在多个线程中并行运行它们。如果无法访问列表类的内部内容，则无法通过常规方式（例如，使用std :: list和阻止方式）来完成此操作。仅在整个算法期间阻止整个列表。当然，这将加快执行算法的线程的工作，但会使其他线程无法访问该列表。但是，如果您应用相同的“瘦” SRWLock锁，则即使它们不修改此列表，也可以在列表上同时执行几种算法。但是要写入的第一个线程将站起来，等待所有其他线程完成列表的读取操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
建议的列表选项使您可以更灵活地组织工作。</font><font style="vertical-align: inherit;">例如，您可以以这样的方式组织列表的工作，即由多个线程同时在列表的前半部分执行非修改算法，而许多其他线程可以在列表的后半部分添加或更改某些内容。</font><font style="vertical-align: inherit;">在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作而不是整个算法</font><font style="vertical-align: inherit;">期间阻止列表的事实</font><font style="vertical-align: inherit;">，将允许通过读取列表的操作序列来“写入”写入操作，这将使其更灵活，高效和高效地工作。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将具有和没有例外支持的列表类的两种变体组合为一个带有布尔参数的变体</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初，这些列表只有例外。</font><font style="vertical-align: inherit;">然后，我添加了新的-没有错误返回的异常，并在类名List_OneLinked_E和List_TwoLinked_E中添加了字母“ E”来重命名了旧的。</font><font style="vertical-align: inherit;">这要求在各处指示列表类的四个声明。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后我认为这有很多不便之处。</font><font style="vertical-align: inherit;">如果这是具有或没有异常支持的相同列表，为什么我们需要两个完全不同的类？</font><font style="vertical-align: inherit;">我将每种类型的两个列表都合并到带有附加布尔参数的单个类中，它们的特定实现（有无）是指定布尔参数的单个类的两个特化。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模板列表合并操作</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前，合并列表的模板操作仅适用于相同类型的列表。它仅合并了单个连接列表或仅合并了两个列表。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，如果您考虑一下，操作涉及的列表类型实际上并不重要：简单连接还是双重连接。它们的阻塞策略也不重要，它们用于检查元素是否存在的策略是什么，以及它们是否支持异常处理。所有这些仅适用于列表的组织，不适用于列表中包含的数据。重要的是只有元素的数据类型和存储策略匹配。因此，现在，在将列表与带有有关异常的布尔参数组合之后，输入操作将接受具有其参数的所有变体的任何类型的列表：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy1</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy2</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy1</span>,
<span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy2</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions1</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions2</span>,
<span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType1</span>, <span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType2</span>&gt;
<span class="hljs-title">auto</span> <span class="hljs-title">operator</span>+(<span class="hljs-title">ListType1</span>&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;&amp; <span class="hljs-title">list1</span>, <span class="hljs-title">ListType2</span>&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&amp; <span class="hljs-title">list2</span>) <span class="hljs-title">noexcept</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，作为列表类型的结果，编译器根据外部参数ce_bGetMinLinksList的设置选择一个具有最小或最大连接性的列表，并根据此解决方案使用其对应的参数：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMinLinksNumber = <span class="hljs-built_in">std</span>::min(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(), <font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMaxLinksNumber = <span class="hljs-built_in">std</span>::max(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(),<font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<font></font>
<span class="hljs-keyword">using</span> ListTypeResultMinLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResultMaxLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResult = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ce_bGetMinLinksList, ListTypeResultMinLinks, ListTypeResultMaxLinks&gt;;<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMinLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMaxLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResult = ce_bGetMinLinksList ? bExceptionsResultMinLinks : bExceptionsResultMaxLinks;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基于所选参数，将创建结果列表：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">ListTypeResult <span class="hljs-title">list</span><span class="hljs-params">(list1.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>) + list2.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>), <span class="hljs-literal">false</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，在此列表上，将指针设置为第一个列表的开头和第二个列表的结尾：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// ,   (       ,   )</span>
<span class="hljs-keyword">if</span> (list1.GetFirst(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list1.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list1.GetLast(<span class="hljs-literal">true</span>))<font></font>
	list1.GetLast(<span class="hljs-literal">true</span>)-&gt;pNext = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list2.GetLast(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list2.GetLast(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list1.GetLast(<span class="hljs-literal">true</span>);<font></font>
<font></font>
<span class="hljs-comment">//       </span>
<span class="hljs-built_in">list</span>.CheckingPresenceElementPolicyResult::RegisterContainer(&amp;<span class="hljs-built_in">list</span>, <span class="hljs-keyword">typename</span> ListTypeResult::iterator{ <span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst, &amp;<span class="hljs-built_in">list</span> });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，清除之前的列表，然后函数退出。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此功能的弱点是对具有潜在死锁的列表进行双重锁定：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// :  -   ;            std::lock(mutex1, mutex2)</span><font></font>
list1.LockListExclusive();<font></font>
list2.LockListExclusive();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以引入一些功能来在单个原子操作中同时锁定两个列表，例如std :: lock（mutex1，mutex2），但是，并非所有锁定策略都支持同时锁定两个同步对象，例如std :: lock（...）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，两个列表可能具有不同的锁定策略。</font><font style="vertical-align: inherit;">这个问题的解决方案（如果有的话）留待将来解决。</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux编译</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过ListDataAdapterTest项目检查编译，该项目最初是在Linux Ubuntu 16.04 LTS（g ++ 8.2.0编译器）上以纯C ++编写的，没有Windows特定功能。大多数细微的差别很容易修复，并且项目已成功编译，并且程序的输出与Windows下的相同输出一致。但是，如果通过操作“ +”注释掉合并列表的行，就是这种情况：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> list3 = list00 + list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果按原样保留它，则上述“ +”操作中将发生编译错误，就像在列表的复合元素的类中未将其声明为特权一样。直接检查策略中针对DirectSearch元素的存在发生类似的错误。在Visual C ++中，这里一切都很好，但是，如果在复合元素类和列表类中注释掉特权组合列表和DirectSearch的操作的声明，则会出现这些相同的错误。似乎g ++只是跳过了这些声明，而抱怨相应类的私有/受保护成员。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（在g ++版本9（Ubuntu 20.04）中，出现相同的错误。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我不明白为什么会跳过特权公告以及如何解决它。</font><font style="vertical-align: inherit;">我不擅长GCC编译器的功能。</font><font style="vertical-align: inherit;">此刻也留给未来。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除此细微差别外，没有其他严重的编译错误。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">头文件结构的描述</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
亲爱的读者，我在GitHub上通过LGPL 3.0许可发布了一个完整的项目，</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网址</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">github.com/SkyCloud555/ListMT。</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
这是一个由多个测试项目组成的解决方案。</font><font style="vertical-align: inherit;">多线程列表的主要代码（通过模板实现）位于几个头文件中：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List.h-不带数据的列表的基类，它实现了带列表的所有基本操作，可能无需定义特定数据以及类似的数据STL适配器。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListE.h-具有例外支持的列表版本。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListElement.h-列表项的基类的定义。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListErrors.h-异常的代码和错误类的定义。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除了列出的主文件，还实现了以下内容：</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MemoryPolicy.h-处理内存的策略；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadLocking.h-阻止策略。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SearchContainerElement.h-用于检查列表中元素是否存在的策略，对于具有迭代器的任何容器都进行了抽象描述。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除最终项目外，我还在“旧版本”文件夹中添加了三个旧版本，以便您可以简要评估项目在开发过程中的变化。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试中</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
名为List的主要项目是一个带有Windows接口的程序，该接口通过Windows API来实现（我不知道怎么做）。在此程序中，选择列表的类型（简单连接或双重连接），并指示元素的初始数量和所需的线程数量。列表项包含单个64位值。创建列表后，循环中每个线程中的程序在列表中向前或向后跳转到随机数量的元素，然后添加或删除元素。通过该列表没有做任何真正有用的工作，并且所有的精力都花在了加热大气上，但这不是必需的：我们只需要在密集的多线程环境中评估该列表的可操作性和性能即可。性能的度量是所有线程每秒执行的上述循环的迭代次数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过在程序代码中指示适当的策略然后重新编译来设置列表。在主模块ListMain.cpp中指定了主程序的所有策略，在ListDataExample.h中选择了存储策略。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般来说，我做了一些实验。老实说，我承认。主要是因为在许多情况下，项目列表会发生重大变化。为了保证实验的纯度，为了测量性能，有必要进行测试，以使平均元素数量在研究期间不发生变化或变化不大。只有在这样的条件下，才可以根据平均值评估生产率的值。如果有人感兴趣，我建议自己组织这样的实验。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于以下原因，我没有更正测试的初始组织。</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，我只是懒惰。</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，我认为没有人对绩效的确切量化值感兴趣</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有计算出的错误</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：重要的是评估</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">质量</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和清单的性能</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">其次，这使您能够评估列表性能随列表数量的增长而变化，这也是非常重要且有趣的信息。</font><font style="vertical-align: inherit;">由于这些原因，我没有更改原始实验。</font><font style="vertical-align: inherit;">第三，对列表的所有变体执行相同的测试代码，从这种意义上说，它们处于相同的条件：在这种情况下它们的行为不同，这一事实使我们能够判断更改的质量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要启用性能计量，请将ListMain.cpp模块中的ce_bPerformanceMeasure标志设置为true。</font><font style="vertical-align: inherit;">该程序将创建一个文件“ PerformanceMeasure.txt”，其对为“元素数-循环数/秒”，并用“：”符号分隔。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绩效评估结果</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，我没有对列表的所有可能配置进行测试，因为其中有很多。</font><font style="vertical-align: inherit;">我只关注关键问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
测试是按照我已经过时但仍然非常令人讨厌的配置Intel Core i7-3930K，DDR3-1333、4通道内存控制器的顺序进行的。</font><font style="vertical-align: inherit;">编译是通过Visual Studio 2019 for Release x64模式（Windows 7 x64操作系统）进行的。</font><font style="vertical-align: inherit;">我没有处理线程数量，因此在所有测试中，始终使用此系统中可用的最大12个线程。</font><font style="vertical-align: inherit;">除上一次测试外，始终创建包含10,000个随机选择项目的列表。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内存策略测试</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如前所述，使用内置指针时，只能使用直接搜索策略来检查列表中的项目。因此，为了使比较正确，并且对于智能指针，仅将此策略应用于此测试。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为锁定策略，具有薄锁的关键部分被选为Windows中生产力最高的部分（请参见下文）：ThreadLockingWin_SRWLock。错误处理是通过返回错误代码进行的，即选项无一例外。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fr/pu/f0/frpuf0zcgkd3dep1rbzgtpk3ciq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该图显示了每秒所有线程总共执行的周期数，具体取决于测试的持续时间（以秒为单位）。显然，由于访问列表的线程具有随机性，因此性能不一致。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pz/km/sw/pzkmsw49rqqqihzv-poyko_co-w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二张图显示了测试期间列表项的数量如何变化。除了明显的内容外，我将不做任何深思熟虑的陈述：很明显，它们的工作方式略有不同，并且列表的连接性与内存策略共同起作用。具有内部指针的双向链接列表是唯一在整个测试过程中平均大小都没有意外变化的列表。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所测期间的平均生产率（周期/秒）：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ky/ux/kd/kyuxkd-1_uzoxhu65prxxyvfcfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
至少可以说，带有智能指针的list选项比带有内置指针的list选项要慢。</font><font style="vertical-align: inherit;">在这两种情况下，都以某种方式证明单连接比双连接要快，这再次表明在多线程模式下，许多熟悉的事物可以改变。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试商品可用性策略</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最有趣的是对检查元素是否存在的策略进行测试。作为一种存储策略，出于上述原因，自然会指示智能指针。其余部分是相同的：使用ThreadLockingWin_SRWLock锁定并通过返回错误代码来处理错误。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ua/lp/ck/ualpckuzqwqhhsdq9o8oqtljtfa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以肯定地说，所有策略的工作原理都差不多。这是可以理解的：在单链接列表中，当删除其项目时，您每次必须查看该列表以指示要删除的项目。这将使所有优化列表访问和加快检查列表中元素是否存在的努力无效。因此，单链表不是密集无序多线程工作的最佳选择。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我不会给出元素数量的图表：那里没有有趣的东西。我只注意到现在所有列表中的元素数量都在增加。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于双链表会出现完全不同的情况。为了使图形看起来更漂亮，我什至排除了直接查看DirectSearch列表的策略，因为从结果来看，它显然“落伍了”。此外，我将元素的限制数量增加了4倍，直到达到极限，测试才停止。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/th/hd/9x/thhd9xyuvi7avo9gmcscfra0tp0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，访问列表的性能（以及处理器负载，变为99-100％）已经显着提高！第二，顺序填充数组位的一对策略具有与测试期间不变的大致相同的性能。第二对策略的速度非线性降低。为什么会这样，从图中可以清楚地看到列表中的节点数。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/ge/mi/bugemimboyskkxkygick6axhxls.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
具有第一对策略的列表的元素数量呈线性增长。第二对提供了明显的非线性增长，并且列表中元素的数量越多，增长越慢。这是可以理解的，因为随着创建新元素时元素数量的增加，平均而言，有必要遍历数组中的更多位以查找空闲元素。第一组策略不处理此问题，它为每个新元素使用一个新位。因此，具有这种策略的列表具有最大的访问性能，并且最接近经典列表：创建和删除元素的操作均在恒定的时间内执行，而与元素的数量无关。但是，它确实在多线程环境中提供了完整性和安全性的某些保证，尽管是以一定数量的内存为代价的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，带有第二对策略的列表明显较慢。但是，它仍然比直接检查选项要快得多。因此，您确实可以推荐它为性能的中级产品，但在内存消耗方面更为理想。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，使用直接搜索策略的列表也会随着其中元素数量的增加而更加缓慢地工作：每次都必须查看更多元素。只是在测试过程中，尽管性能波动比较混乱，但列表并没有设法增长到足以引起注意的程度。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vw/ck/_p/vwck_pj1r6wmaxgowihhqbzltq8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
平均性能值显示，在顺序填充期间使用位图的策略可以将访问列表的效率提高约200倍，即 </font><font style="vertical-align: inherit;">与直接搜索策略相比，数量级提高了2个数量级。</font><font style="vertical-align: inherit;">这是一个非常根本的变化。</font><font style="vertical-align: inherit;">如上所述，具有存储器最佳位填充功能的选件的性能当然明显较慢，但仍比具有直接验证的选件快得多。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还值得注意的是，按需使用内存传输机制会稍微减慢对列表的访问。</font><font style="vertical-align: inherit;">不是太关键，但是效果是显着的，尤其是在经济使用内存的变体中（图上的黄线）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阻止策略测试</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们看看选择不同的锁定策略时列表的性能将如何变化。</font><font style="vertical-align: inherit;">我使用了三种类型的锁：SRWLock“薄”锁，常规Windows关键部分和STL互斥锁。</font><font style="vertical-align: inherit;">对于其余设置，使用了最快的列表版本：双连接，智能指针，用于检查元素是否存在的策略-SearchByIndex_BitArray，这是无例外的变体。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6a/jb/pz/6ajbpzqugu7mgtv9mtcim4y221w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所料，“薄”锁将性能提高了近25％。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows关键部分和STL互斥体的工作速度大致相同。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6n/qz/wv/6nqzwvldymyqvb-rt1dgjgigwdm.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外情况</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了评估异常对性能的影响，我进行了三个测试。</font><font style="vertical-align: inherit;">前两个使用双向链表，智能指针，元素存在检查策略-SearchByIndex_BitArray和SRWLock的关键部分。</font><font style="vertical-align: inherit;">最后一次测试使用了相同的测试，只是将锁替换为通常的关键部分以进行比较。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7_/at/9u/7_at9uiygpgn_mnrznps8yjwbp0.png"><br>
<br>
<img src="https://habrastorage.org/webt/pf/ac/e9/pface9frjlrsbtcbc9ryxnqv8we.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以看出，对异常的支持确实会降低工作速度，特别是如果您使用更“粗暴”的阻止选项。</font><font style="vertical-align: inherit;">但是，请记住，在这种情况下，将不支持STL和集合中的循环。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发现</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对我来说，这是一个非常大规模的实验。我的意思不是上面的测试，而是整个项目。他没想到自己会被拖累。但是，我完全按照计划进行了实施。当然，最后，这仍然不是最终版本，而只是一些可行的原型，即本文开头描述的想法的实现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据测试结果，很明显，在Windows下，它是带有智能指针的最快的双向链接列表，这是一种检查SearchByIndex_BitArray元素，SRWLock的关键部分是否存在的策略，没有例外。在此配置中，列表提供了最佳性能，并且可以从各种流中对其进行密集的混乱访问，并且行为与经典列表最接近，并且在多线程模式下具有安全性保证。具有更经济的内存消耗的选件也非常有生产力（与DirectDirectSearch相比），但是它仍然明显比前一个慢，并且其性能会随着元素数量的增加而降低。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您认为我将在这里竞选自己做过的一件很酷的事情，以及使用它有多棒，那么您就不会这样做：事实上，我将从劝阻您开始。</font><font style="vertical-align: inherit;">确实：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑是否可以使用具有不同元素排列的容器：例如，数组。</font><font style="vertical-align: inherit;">它没有像列表这样的问题。</font></font></li>
<li>          ,      std::list    .            .    ,        ,          .      ,   <s>,     </s>.    , <s>    ,</s>       <s>,    </s>.</li>
<li> ,    .       :    ,  ,  ,    ,        . ,    –       ,      ,    .</li>
<li>                ,      .   ,       ,               .</li>
<li>   ,    ,     ,            .  ,             .              . ,    ,       ,   –     .    . ,   –          .     ,        ,    .           ,        .. ,          ,            , ,     ,          ,   :   .                       .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按需将内存转移到位阵列的策略也至少部分地将多线程列表近似为经典列表：至少直到内存阵列完全装满为止，它所占用的空间将与实际所需的一样多。</font><font style="vertical-align: inherit;">但是，这导致性能降低。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 该项目的缺点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前面提到的合并列表操作中相互阻塞的可能性。</font></font></li>
<li>       ,    . ,     :   ,     RAII:          .       ,      ,   -  ,       .   ,     . ,   ,      - .</li>
<li>         ,    .     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
希望这很有趣。初学者可能会有用，因为一切都从简单到复杂都可以考虑。我请专业人士说，您认为此处描述的想法在实际项目中实际适用多少？就您的活动而言，是否存在某种情况，您需要一个列表或树，而不是另一个容器，但是由于此处描述的问题，它成为了程序中的瓶颈？或者，您必须极大地更改或复杂化该程序。如果您以前曾遇到过此问题，那么您如何解决此问题？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，从本质上讲，该项目只是我自己对解决此问题的看法的实现。</font><font style="vertical-align: inherit;">可能有更好的选择。</font><font style="vertical-align: inherit;">我从一开始就重复了自己最初是为自己做的想法，并且不打算将其公开展示。</font><font style="vertical-align: inherit;">但是，我还是出于此处所述的理由这样做了，因此，我很乐意接受建设性的批评。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">经过仔细检查代码，您可能会遇到这样的设计：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  (        )</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};			<span class="hljs-comment">//-,       ,   ListElementData_OneLinked/ListElementData_TwoLinked</span><font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked1</span> :</span> <span class="hljs-keyword">public</span> ListElement_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked1&lt;&gt;, DerivedListElement&gt;, MemoryPolicy&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>;						<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked1(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : u64Value(u64Value) {}		<span class="hljs-comment">//</span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked2</span> :</span> <span class="hljs-keyword">public</span> ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">using</span> ListElementBase = ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;;<font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ucSomeData[<span class="hljs-number">1024</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">decltype</span>(ListElementBase::u64Value))];	<span class="hljs-comment">//     </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked2(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : ListElementBase(u64Value) {}		<span class="hljs-comment">//</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种黑魔法值得单独写一篇文章。</font><font style="vertical-align: inherit;">没错，这比这里描述的多线程列表还不实用，但是它具有自己的奇特功能。</font><font style="vertical-align: inherit;">如果您对它的来源以及出现的原因感兴趣，并且希望我以后再详细讨论，请在评论中写下。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN506702/index.html">根据Backblaze Q1 2020最可靠的硬盘</a></li>
<li><a href="../zh-CN506704/index.html">为什么在2020年用PHP编写？Holivarim是本周四在YouTube上的互动播客</a></li>
<li><a href="../zh-CN506706/index.html">现代Java在处理大量数据时的性能，第1部分</a></li>
<li><a href="../zh-CN506708/index.html">VPN / Mikrotik两因素身份验证-简单且可扩展</a></li>
<li><a href="../zh-CN506710/index.html">在Zimbra Collaboration Suite开源版中管理多个通讯录</a></li>
<li><a href="../zh-CN506726/index.html">使用Rutoken技术进行系统中用户注册和授权的经验（第2部分）</a></li>
<li><a href="../zh-CN506730/index.html">Snort或Suricata。第1部分：选择免费的IDS / IPS保护企业网络</a></li>
<li><a href="../zh-CN506732/index.html">组织范围内对UI组件的重用</a></li>
<li><a href="../zh-CN506734/index.html">电网中的瞬态计算</a></li>
<li><a href="../zh-CN506736/index.html">一个班级应该有多少种方法？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>