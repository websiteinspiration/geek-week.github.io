<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♨️ 🧘🏽 🔹 C配列のサイズがライブラリバイナリインターフェイスの一部になった方法 😼 📁 🦁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ほとんどのCコンパイラでは、extern境界が定義されていない配列にアクセスできます。次に例を示します。
 
 

extern int external_array[];  int array_get (long int index) { return external_array[index];...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C配列のサイズがライブラリバイナリインターフェイスの一部になった方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451182/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほとんどのCコンパイラでは、</font></font><code>extern</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">境界が定義されていない</font><font style="vertical-align: inherit;">配列にアクセスできます。</font><font style="vertical-align: inherit;">次に例を示します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> external_array[];<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">array_get</span> <span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> index)</span>
</span>{
  <span class="hljs-keyword">return</span> external_array[index];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
external_arrayの定義は別の翻訳単位にある可能性があり、次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> external_array[<span class="hljs-number">3</span>] = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、この個別の定義が次のように変更されるとどうなるかです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> external_array[<span class="hljs-number">4</span>] = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とか、ぐらい：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> external_array[<span class="hljs-number">2</span>] = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span> };</code></pre><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイナリー・インターフェースは保持されますか（アプリケーションが実行時に配列のサイズを判別できるようにするメカニズムがある場合）？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
奇妙なことに、多くのアーキテクチャーで</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、配列のサイズを大きくすると、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイナリー・インターフェース互換性（ABI）に違反します。</font><font style="vertical-align: inherit;">アレイのサイズを小さくすると、互換性の問題が発生する可能性もあります。</font><font style="vertical-align: inherit;">この記事では、ABIの互換性を詳しく調べ、問題を回避する方法について説明します。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行可能ファイルのデータセクション内のリンク</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列のサイズがバイナリインターフェイスの一部になる方法を理解するには、まず実行可能ファイルのデータセクションのリンクを調べる必要があります。</font><font style="vertical-align: inherit;">もちろん、詳細は特定のアーキテクチャによって異なります。ここでは、x86-64アーキテクチャに焦点を当てます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
x86-64アーキテクチャは、プログラムカウンターに関連するアドレス指定をサポートします。つまり、上記の関数のように、グローバル配列変数へのアクセスは、</font></font><code>array_get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つの命令にコンパイルできます</font></font><code>movl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs">array_get:
	<span class="hljs-function">movl	<span class="hljs-title">external_array</span><span class="hljs-params">(,%rdi,<span class="hljs-number">4</span>)</span>, %eax
	ret</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これから、アセンブラは、命令がとしてマークされているオブジェクトファイルを作成します</font></font><code>R_X86_64_32S</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">0000000000000000 :<font></font>
   0:	mov    0x0(,%rdi,4),%eax<font></font>
			3: R_X86_64_32S	external_array<font></font>
   7:	retq   </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この移動は</font><font style="vertical-align: inherit;">、実行可能ファイルを作成するときに、リンク中に</font></font><code>ld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">対応する変数の場所を設定する方法を</font><font style="vertical-align: inherit;">リンカー（</font><font style="vertical-align: inherit;">）に</font><font style="vertical-align: inherit;">指示します</font></font><code>external_array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これには2つの重要な結果があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数のオフセットはビルド時に決定されるため、実行時にそれを決定するオーバーヘッドはありません。</font><font style="vertical-align: inherit;">唯一の代償は、メモリ自体へのアクセスです。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オフセットを決定するには、すべての変数データのサイズを知る必要があります。</font><font style="vertical-align: inherit;">そうしないと、レイアウト中にデータセクションの形式を計算できなくなります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNU / Linuxのように、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行可能ファイルとリンク形式（ELF）を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
指向するC実装の場合</font><font style="vertical-align: inherit;">、変数参照に</font></font><code>extern</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はオブジェクトサイズが含まれません。</font><font style="vertical-align: inherit;">この例で</font></font><code>array_get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、オブジェクト</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">サイズはコンパイラーにとっても不明です。</font><font style="vertical-align: inherit;">実際、</font></font><code>-fno-asynchronous-unwind-tables</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブラー</font><font style="vertical-align: inherit;">ファイル全体は次のようになります（</font><font style="vertical-align: inherit;">psABIに準拠するために技術的に必要な</font><font style="vertical-align: inherit;">cからのプロモーション情報のみを省略してい</font><font style="vertical-align: inherit;">ます）。</font></font><br>
<br>
<pre><code class="plaintext hljs">	.file	"get.c"<font></font>
	.text<font></font>
	.p2align 4,,15<font></font>
	.globl	array_get<font></font>
	.type	array_get, @function<font></font>
array_get:<font></font>
	movl	external_array(,%rdi,4), %eax<font></font>
	ret<font></font>
	.size	array_get, .-array_get<font></font>
	.ident	"GCC: (GNU) 8.3.1 20190223 (Red Hat 8.3.1-2)"<font></font>
	.section	.note.GNU-stack,"",@progbits</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアセンブラファイルでは、通常、サイズに関する情報はありません。</font></font><code>external_array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シンボルへの参照は命令の行にあり、命令の</font></font><code>movl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数値データは配列要素のサイズ（</font></font><code>movl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4を掛けたもの）だけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ELFが未定義の変数の次元を必要とする場合、関数をコンパイルすることさえ不可能</font></font><code>array_get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リンカは実際の文字サイズをどのように取得しますか？</font><font style="vertical-align: inherit;">彼はキャラクターの定義を見て、そこで見つけたサイズ情報を使用します。</font><font style="vertical-align: inherit;">これにより、コンパイラはデータセクションのレイアウトを計算し、適切なオフセットでデータの動きを埋めることができます。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的なELFオブジェクト</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ELFのC実装では、ソースコードマークアップを追加して、関数または変数が現在のオブジェクト（ライブラリまたはメイン実行可能ファイル）または別のオブジェクトにあるかどうかを示す必要はありません。リンカとダイナミックローダーがこれを処理します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、コンパイルモデルを変更してもパフォーマンスが低下しないように、実行可能ファイルが必要でした。つまり、メインプログラムのソースコードをコンパイルするとき（つまり、なし</font></font><code>-fPIC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、この特定のケースでは、なし</font></font><code>-fPIE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、関数は</font><i><font style="vertical-align: inherit;">、</font></i><font style="vertical-align: inherit;">動的共有オブジェクトを導入する前</font><i><font style="vertical-align: inherit;">に、まったく同じ</font></i><font style="vertical-align: inherit;">コマンドシーケンスに</font></font><code>array_get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイルされ</font><font style="vertical-align: inherit;">ます。また、変数が定義されているかどうかは関係ありません</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><code>external_array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最も基本的な実行可能ファイルまたは一部の共有オブジェクトでは、実行時に個別にロードされます。コンパイラーが作成する命令は、どちらの場合も同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはどのようにして可能ですか？結局のところ、一般的なELFオブジェクトは位置に依存しません。これらは</font><font style="vertical-align: inherit;">、実行時に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予測不可能なランダム化されたアドレスに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読み込ま</font><font style="vertical-align: inherit;">れます。ただし、コンパイラーは</font><font style="vertical-align: inherit;">、プログラムの開始前に、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンク中に計算さ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れた</font><i><font style="vertical-align: inherit;">固定オフセット</font></i><font style="vertical-align: inherit;">にこれらの変数を配置する必要があるマシンコードシーケンスを生成し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、読み込まれたオブジェクト（メインの実行可能ファイル）はこれらの固定オフセットを使用します。他のすべてのオブジェクト（ダイナミックローダー自体、Cランタイムライブラリ、およびプログラムで使用されるその他のライブラリ）は、完全に位置独立オブジェクト（PIC）としてコンパイルおよびコンパイルされます。このようなオブジェクトの場合、コンパイラーは、グローバルオフセットテーブル（GOT）から各変数の実際のアドレスをロードします。我々は例をコンパイルする場合我々は、このラウンドアバウトを見ることができる</font></font><code>array_get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とともに</font></font><code>-fPIC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、このようなアセンブラコードにつながります：</font></font><br>
<br>
<pre><code class="plaintext hljs">array_get:<font></font>
	movq	external_array@GOTPCREL(%rip), %rax<font></font>
	movl	(%rax,%rdi,4), %eax<font></font>
	ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、変数のアドレスは</font></font><code>external_array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハードコードされなくなり、実行時にGOTレコードを適切に初期化することで変更できます。これは、実行時に、定義</font></font><code>external_array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が同じ共有オブジェクト、別の共有オブジェクト、またはメインプログラムにある可能性が</font><font style="vertical-align: inherit;">あることを意味し</font><font style="vertical-align: inherit;">ます。ダイナミックローダーは、ELF文字検索ルールに基づいて適切な定義を見つけ、GOTレコードを実際のアドレスに更新することにより、未定義の文字参照をその定義に関連付けます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数</font></font><code>array_get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がメインプログラム</font><font style="vertical-align: inherit;">にある元の例に戻り</font><font style="vertical-align: inherit;">、変数のアドレスを直接指定します。リンカに実装されている重要なアイデアは、メインプログラムが変数の定義を提供することです</font></font><code>external_array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえ実行時に共通オブジェクトで実際に定義されていても</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ダイナミックローダーは、共有オブジェクトで変数の初期定義を指定する代わりに</font><font style="vertical-align: inherit;">、実行可能ファイルのデータセクションで変数の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コピーを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">選択し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これには2つの重要な意味があります。</font><font style="vertical-align: inherit;">まず、</font></font><code>external_array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次のように定義され</font><font style="vertical-align: inherit;">ていることを思い出してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> external_array[<span class="hljs-number">3</span>] = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインの実行可能ファイルの定義に適用する必要がある初期化子がここにあります。</font><font style="vertical-align: inherit;">これを行うには、メインの実行可能ファイル</font><font style="vertical-align: inherit;">に、シンボルの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コピー</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コピーの場所</font><font style="vertical-align: inherit;">へのリンクを配置し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">チーム</font></font><code>readelf -rW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はそれを移動として示します</font></font><code>R_X86_64_COPY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オフセット0x408の再配置セクション '.rela.dyn'には、3つのエントリが含まれています。</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    オフセット情報タイプシンボルの値シンボルの名前+加数</font></font><font></font>
0000000000403ff0  0000000100000006 R_X86_64_GLOB_DAT      0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0<font></font>
0000000000403ff8  0000000200000006 R_X86_64_GLOB_DAT      0000000000000000 __gmon_start__ + 0<font></font>
0000000000404020  0000000300000005 R_X86_64_COPY          0000000000404020 external_array + 0</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他の動きと同様に、コピーの動きはダイナミックローダーによって処理されます。</font><font style="vertical-align: inherit;">単純なビット単位のコピー操作が含まれています。</font><font style="vertical-align: inherit;">コピーのターゲットは、ディスプレイスメントオフセット（</font></font><code>0000000000404020</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例）</font><font style="vertical-align: inherit;">によって決定され</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">ソースは、シンボル名（</font></font><code>external_array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）とその値に</font><font style="vertical-align: inherit;">基づいて実行時に決定されます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">コピーを作成するとき、ダイナミックローダーは文字のサイズも調べて、コピーする必要のあるバイト数を取得します。</font><font style="vertical-align: inherit;">これをすべて可能にする</font></font><code>external_array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ために、実行時にダイナミックローダーに表示される</font><font style="vertical-align: inherit;">ように、シンボルは</font><font style="vertical-align: inherit;">実行可能ファイルから特定のシンボルとして自動的にエクスポートされます。</font></font><code>.dynsym</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次のコマンドで示すように、</font><font style="vertical-align: inherit;">動的シンボルテーブル（</font><font style="vertical-align: inherit;">）はこれを反映してい</font><font style="vertical-align: inherit;">ます</font></font><code>readelf -sW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シンボルテーブル '.dynsym'には4つのエントリがあります。</font></font><font></font>
   Num:    Value          Size Type    Bind   Vis      Ndx Name<font></font>
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND <font></font>
     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.2.5 (2)<font></font>
     2: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__<font></font>
     3: 0000000000404020    12 OBJECT  GLOBAL DEFAULT   22 external_array</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトのサイズに関する情報はどこから来ていますか（この例では12バイト）？リンカはすべての一般的なオブジェクトを開き、その定義を検索して、サイズに関する情報を取得します。以前と同様に、これにより、リンカーはデータセクションのレイアウトを計算できるため、固定オフセットを使用できます。この場合も、メイン実行可能ファイルの定義のサイズは固定されており、実行時に変更できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
動的リンカーは、共有オブジェクトのシンボリックリンクをメイン実行可能ファイルの移動されたコピーにリダイレクトします。これにより、プログラム全体で、Cのセマンティクスで必要とされる変数のコピーが1つだけ存在することが保証されます。そうでない場合、初期化後に変数が変更されると、メインの実行可能ファイルからの更新が動的共有オブジェクトから見えなくなり、その逆も同様です。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイナリ互換性への影響</font></font></h1><br><font style="vertical-align: inherit;"></font><code>external_array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メインプログラムをリンク（または再コンパイル）せずに共通オブジェクトの</font><font style="vertical-align: inherit;">
定義を変更するとどうなり</font><font style="vertical-align: inherit;">ますか？</font><font style="vertical-align: inherit;">まず、</font><font style="vertical-align: inherit;">配列要素を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font><i><font style="vertical-align: inherit;">ことを</font></i><font style="vertical-align: inherit;">検討し</font><i><font style="vertical-align: inherit;">てください</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> external_array[<span class="hljs-number">4</span>] = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、実行時にダイナミックローダーから警告が表示されます。</font></font><br>
<br>
<code>main-program: Symbol `external_array' has different size in shared object, consider re-linking</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインプログラムには、</font></font><code>external_array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12バイトのみのスペースを</font><font style="vertical-align: inherit;">持つ定義</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">まだ含まれてい</font><font style="vertical-align: inherit;">ます。これは、コピーが不完全であることを意味します。配列の最初の3つの要素のみがコピーされます。その結果、配列要素へのアクセス</font></font><code>extern_array[3]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は定義されません。このアプローチは、メインプログラムだけでなく、プロセス内のコード全体にも影響します。これは、その参照がすべて</font></font><code>extern_array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メインプログラムの定義にリダイレクトされたためです。これには、定義を提供する汎用オブジェクトが含まれます</font></font><code>extern_array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。彼はおそらく、自分の定義の配列要素が消えた状況に対応する準備ができていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要素を削除して反対方向に変更してみませんか？</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> external_array[<span class="hljs-number">2</span>] = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span> };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムが配列の要素へのアクセスを回避する場合、</font></font><code>extern_array[2]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何らかの方法で配列の短縮された長さを検出するため、これは機能します。</font><font style="vertical-align: inherit;">配列の後には、未使用のメモリがいくらかありますが、これによってプログラムが壊れることはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、次のルールが適用されます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グローバル配列変数に要素を追加すると、バイナリ互換性に違反します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">削除されたアイテムへのアクセスを回避するメカニズムがない場合、アイテムを削除すると互換性が失われる可能性があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、ダイナミックローダーの警告は実際よりも害が少ないように見えます。リモート要素の場合、警告はまったくありません。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この状況を回避する方法</font></font></h1><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libabigail</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
などのツールを使用すると、ABIの変更を簡単に検出できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況を回避する最も簡単な方法は、配列のアドレスを返す関数を実装することです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> local_array[<span class="hljs-number">3</span>] = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> *
<span class="hljs-title">get_external_array</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
  <span class="hljs-keyword">return</span> local_array;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライブラリでの使用方法が原因で配列の定義を静的にできない場合は、代わりにその可視性を非表示にしてエクスポートを防止し、その結果、切り捨ての問題を回避できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> local_array[<span class="hljs-number">3</span>] __attribute__ ((visibility (<span class="hljs-string">"hidden"</span>))) =<font></font>
  { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下位互換性のために配列変数をエクスポートすると、すべてがはるかに複雑になります。ライブラリの配列は切り捨てられるため、配列定義が短い古いメインプログラムは、同じグローバル配列で使用される場合、新しいクライアントコードの完全配列へのアクセスを提供できません。代わりに、アクセス関数は別の（静的または非表示の）配列、または最後に追加された要素に別の配列を使用する場合があります。欠点は、下位互換性のために配列変数がエクスポートされる場合、連続配列にすべてを格納することができないことです。セカンダリインターフェイスの設計はこれを反映する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文字のバージョン管理を使用すると、特定のバージョンでサイズを変更することなく、サイズの異なる複数のバージョンをエクスポートできます。</font><font style="vertical-align: inherit;">このモデルを使用すると、新しい関連プログラムは常に、おそらく最大サイズの最新バージョンを使用します。</font><font style="vertical-align: inherit;">シンボルのバージョンとサイズは同時にリンクエディターによって固定されるため、常に一貫しています。</font><font style="vertical-align: inherit;">GNU Cライブラリは、歴史的変数</font></font><code>sys_errlist</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font><font style="vertical-align: inherit;">に対してこのアプローチを使用します</font></font><code>sys_siglist</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、これでも単一の連続配列は提供されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのことを考慮すると、アクセス関数（</font></font><code>get_external_array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上記</font><font style="vertical-align: inherit;">の関数の</font><font style="vertical-align: inherit;">ような）は、このABI互換性の問題を回避するための最良のアプローチです。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja451172/index.html">ジュリア：関数と関数としての構造</a></li>
<li><a href="../ja451174/index.html">ZXスペクトラムのプログラムを最新の手段でTR-DOSに適合させます。パート1</a></li>
<li><a href="../ja451176/index.html">OpenStreetMap No. 458の世界からのニュース（2019年4月23日-2019年4月9日）</a></li>
<li><a href="../ja451178/index.html">搭乗員ドラゴンパラシュート着陸時の衝突試験</a></li>
<li><a href="../ja451180/index.html">PCBは2つのリニアモーターを置き換えます</a></li>
<li><a href="../ja451184/index.html">ブルーオリジンブルームーンプロジェクト：2024年までの月面の人々</a></li>
<li><a href="../ja451186/index.html">LINSTORリポジトリとOpenNebulaとの統合</a></li>
<li><a href="../ja451188/index.html">ズベルバンクまたはあちらこちら</a></li>
<li><a href="../ja451196/index.html">顧客とフリーランサーのプロファイルの分離</a></li>
<li><a href="../ja451204/index.html">コラボレーション用の無料のテキストエディター</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>